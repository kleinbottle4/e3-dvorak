     1                                  ;--------------------------------------------------------------------
     2                                  ;
     3                                  ;  e3.asm v2.7.1 Copyright (C) 2000-2007 Albrecht Kleine <kleine@ak.sax.de>
     4                                  ;
     5                                  ;  This program is free software; you can redistribute it and/or modify
     6                                  ;  it under the terms of the GNU General Public License as published by
     7                                  ;  the Free Software Foundation; either version 2 of the License, or
     8                                  ;  (at your option) any later version.
     9                                  ;
    10                                  ;  This program is distributed in the hope that it will be useful,
    11                                  ;  but WITHOUT ANY WARRANTY; without even the implied warranty of
    12                                  ;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    13                                  ;  GNU General Public License for more details.
    14                                  ;
    15                                  ;  You should have received a copy of the GNU General Public License
    16                                  ;  along with this program; if not, write to the Free Software
    17                                  ;  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
    18                                  ;
    19                                  ;----------------------------------------------------------------------
    20                                  ;
    21                                  %include "e3.h"
     1                              <1> ;--------------------------------------------------------------------------
     2                              <1> ;  e3.asm v2.7.0 Copyright (C) 2000-06 Albrecht Kleine <kleine@ak.sax.de>
     3                              <1> ;
     4                              <1> ;  see GNU copyright details in e3.asm
     5                              <1> ;--------------------------------------------------------------------------
     6                              <1> 
     7                              <1> %define WS 1
     8                              <1> %define EM 2
     9                              <1> %define PI 4
    10                              <1> %define VI 8
    11                              <1> %define NE 16
    12                              <1> %define DEFAULT_MODE WS			;<---- select one of WS, EM, NE, PI, VI
    13                              <1> %define MAKE_BACKUP
    14                              <1> %define LESSWRITEOPS
    15                              <1> ;-------
    16                              <1> %define UTF8				;for UTF8 console or xterm e.g. @ Suse 9.1
    17                              <1> ;%define UTF8RTS				;runtime detection of UTF8 console display
    18                              <1> ;-------
    19                              <1> %define BEEP_IN_VI			;undef if you hate beeping computers
    20                              <1> %define USE_MATH			;undef if you don't use the numerics
    21                              <1> %define USE_PIPE			;undef if you don't use piping through sed/ex
    22                              <1> %define USE_BUILTINHELP			;undef if you really don't need help (saves some space)
    23                              <1> %define USE_UNDO			;undef if there is low memory
    24                              <1> ;;;%define USE_EXT_MOVE			;smart move mode for Home,End,BOF,EOF keys
    25                              <1> ;
    26                              <1> ;-------
    27                              <1> ;
    28                              <1> ;	D O   N O T   C H A N G E   B E L O W   L I N E
    29                              <1> ;----------------------------------------------------------------------
    30                              <1> %ifndef LINUX
    31                              <1>  %undef UTF8
    32                              <1> %endif
    33                              <1> 
    34                              <1> %ifndef UTF8
    35                              <1>   %undef UTF8RTS
    36                              <1> %endif
    37                              <1> 
    38                              <1> %ifdef NETBSD
    39                              <1> %define FREEBSD
    40                              <1> %endif
    41                              <1> %ifdef OPENBSD
    42                              <1> %define FREEBSD
    43                              <1> %endif
    44                              <1> ;
    45                              <1> ;beware of SYS_... constants > 255! (see NetBSD)
    46                              <1> ;
    47                              <1> %ifdef BEOS
    48                              <1> 	;posix/termios.h				;termios eq termio
    49                              <1> 	%define TERMIOS_SET 8001h			;TCSETA
    50                              <1> 	%define TERMIOS_GET 8000h			;TCGETA
    51                              <1> 	%define TERMIOS_WSIZE 800Ch			;TIOCGWINSZ
    52                              <1> 	%define NCCS 11
    53                              <1> 	%define VMIN 4
    54                              <1> 	%define speed_t1		resb
    55                              <1> 	%undef USE_PIPE
    56                              <1> %define SYS_exit	63
    57                              <1> %define SYS_read	2
    58                              <1> %define SYS_write	3
    59                              <1> %define SYS_open	0
    60                              <1> %define SYS_close	1
    61                              <1> %define SYS_unlink	39
    62                              <1> %define SYS_lseek	5
    63                              <1> %define SYS_rename	38
    64                              <1> %define SYS_ioctl	4
    65                              <1> 
    66                              <1> MAXERRNO	equ 30
    67                              <1> ERRNOMEM	equ 12
    68                              <1> ERRNOIO		equ 5
    69                              <1> 
    70                              <1> 	%macro errortext 0
    71                              <1> db "Op not permitted",10		;1
    72                              <1> db "No such file|directory",10		;2
    73                              <1> db 10					;3
    74                              <1> db 10					;4
    75                              <1> db "Input/output",10			;5
    76                              <1> db "No such device",10			;6
    77                              <1> db 10					;7
    78                              <1> db 10					;8
    79                              <1> db "Bad file descriptor",10		;9
    80                              <1> db "No child processes",10		;10
    81                              <1> db 10					;11		
    82                              <1> db "Memory exhausted",10		;12
    83                              <1> db "Permission denied",10		;13
    84                              <1> db 10					;14
    85                              <1> db 10					;15
    86                              <1> db "Device|resource busy",10		;16
    87                              <1> db "File exists",10			;17
    88                              <1> db 10					;18
    89                              <1> db "No such device",10			;19
    90                              <1> db 10					;20
    91                              <1> db "Is a directory",10			;21
    92                              <1> db "Invalid argument",10		;22
    93                              <1> db "Too many open files",10		;23
    94                              <1> db "Too many open files",10		;24
    95                              <1> db "Inappropriate ioctl",10		;25
    96                              <1> db "Text file busy",10			;26
    97                              <1> db "File too large",10			;27
    98                              <1> db "No space on device",10		;28
    99                              <1> db "Illegal seek",10			;29
   100                              <1> db "R/O file system",10			;30
   101                              <1> 	%endmacro
   102                              <1> 
   103                              <1> %else
   104                              <1> %ifdef QNX
   105                              <1> 	;termios.h
   106                              <1> 	;sys/ioctl.h
   107                              <1> 	%define TERMIOS_SET   804c7414h	;TIOCSETA
   108                              <1> 	%define TERMIOS_GET   404c7413h	;TIOCGETA
   109                              <1> 	%define TERMIOS_WSIZE 40087468h	;TIOCGWINSZ
   110                              <1> 	;		      rw	
   111                              <1> 	;		        size
   112                              <1> 	;			  't'
   113                              <1> 	;			    nr.
   114                              <1> 	%define NCCS 40
   115                              <1> 	%define VMIN 6
   116                              <1> 	%define speed_t2	resd
   117                              <1> ;-------
   118                              <1> ;the QNX version is linked against libc
   119                              <1> %define LIBC
   120                              <1> extern open,read,write,close,lseek,rename,_exit,ioctl,fstat,fchown,select,unlink
   121                              <1> extern errno
   122                              <1> %undef USE_PIPE
   123                              <1> 	%define SYS_fstat		;dummy
   124                              <1> 	struc stat_struc
   125                              <1> .st_ino:	resd 2 
   126                              <1> .st_size:	resd 2
   127                              <1> .st_dev:	resd 1
   128                              <1> .st_rdev:	resd 1
   129                              <1> .st_uid:	resd 1;24
   130                              <1> .st_gid:	resd 1;28
   131                              <1> .st_ctime:	resd 1;
   132                              <1> .st_atime:	resd 1;
   133                              <1> .st_mtime:	resd 1;40
   134                              <1> .st_mode:	resd 1;44
   135                              <1> .st_dummy:	resd 20		;who cares?
   136                              <1> 	endstruc
   137                              <1> MAXERRNO	equ 30
   138                              <1> ERRNOMEM	equ 12
   139                              <1> ERRNOIO		equ 5
   140                              <1> 
   141                              <1> 	%macro errortext 0
   142                              <1> db "Op not permitted",10		;1
   143                              <1> db "No such file|directory",10		;2
   144                              <1> db 10					;3
   145                              <1> db 10					;4
   146                              <1> db "Input/output",10			;5
   147                              <1> db "No such device",10			;6
   148                              <1> db 10					;7
   149                              <1> db 10					;8
   150                              <1> db "Bad file descriptor",10		;9
   151                              <1> db "No child processes",10		;10
   152                              <1> db 10					;11		
   153                              <1> db "Memory exhausted",10		;12
   154                              <1> db "Permission denied",10		;13
   155                              <1> db 10					;14
   156                              <1> db 10					;15
   157                              <1> db "Device|resource busy",10		;16
   158                              <1> db "File exists",10			;17
   159                              <1> db 10					;18
   160                              <1> db "No such device",10			;19
   161                              <1> db 10					;20
   162                              <1> db "Is a directory",10			;21
   163                              <1> db "Invalid argument",10		;22
   164                              <1> db "Too many open files",10		;23
   165                              <1> db "Too many open files",10		;24
   166                              <1> db "Inappropriate ioctl",10		;25
   167                              <1> db "Text file busy",10			;26
   168                              <1> db "File too large",10			;27
   169                              <1> db "No space on device",10		;28
   170                              <1> db "Illegal seek",10			;29
   171                              <1> db "R/O file system",10			;30
   172                              <1> 	%endmacro
   173                              <1> 
   174                              <1> %else
   175                              <1> %ifdef ATHEOS	;--------------------- A T H E O S -----------------------
   176                              <1> 	;posix/termbits.h
   177                              <1> 	%define TERMIOS_SET 5406h
   178                              <1> 	%define TERMIOS_GET 5405h
   179                              <1> 	%define TERMIOS_WSIZE 5413h
   180                              <1> 	%define NCCS 19
   181                              <1> 	%define VMIN 6
   182                              <1> 	;posix/stat.h
   183                              <1> 	struc stat_struc
   184                              <1> .st_dev:	resd 1
   185                              <1> .st_ino:	resd  2
   186                              <1> .st_mode:	resd 1
   187                              <1> .st_nlink:	resd 1
   188                              <1> .st_uid:	resd 1
   189                              <1> .st_gid:	resd 1
   190                              <1> .st_rdev:	resd 1
   191                              <1> .st_size:	resd  2
   192                              <1> .st_blksize:	resd 1
   193                              <1> .st_blocks:	resd  2
   194                              <1> .st_atime:	resd 1
   195                              <1> .__unused1:	resd 1
   196                              <1> .st_mtime:	resd 1
   197                              <1> .__unused2:	resd 1
   198                              <1> .st_ctime:	resd 1
   199                              <1> .__unused3:	resd 1
   200                              <1> .__unused4:	resd 1
   201                              <1> .__unused5:	resd 1
   202                              <1> 	endstruc
   203                              <1> 	%undef USE_PIPE
   204                              <1> 
   205                              <1> %define SYS_exit	6
   206                              <1> %define SYS_read	3
   207                              <1> %define SYS_write	4
   208                              <1> %define SYS_open	1
   209                              <1> %define SYS_close	2
   210                              <1> %define SYS_unlink	20
   211                              <1> %define SYS_lseek	13
   212                              <1> %define SYS_kill	92
   213                              <1> %define SYS_rename	7
   214                              <1> %define SYS_ioctl	116
   215                              <1> %define SYS_sigaction	93
   216                              <1> %define SYS_fchown	86
   217                              <1> %define SYS_fstat	11
   218                              <1> %define SYS_select	42
   219                              <1> 
   220                              <1> SIGCONT		equ 18
   221                              <1> SIGSTOP		equ 19
   222                              <1> 
   223                              <1> 
   224                              <1> MAXERRNO	equ 30
   225                              <1> ERRNOMEM	equ 12
   226                              <1> ERRNOIO		equ 5
   227                              <1> 
   228                              <1> 	%macro errortext 0
   229                              <1> db "Op not permitted",10		;1
   230                              <1> db "No such file|directory",10		;2
   231                              <1> db 10					;3
   232                              <1> db 10					;4
   233                              <1> db "Input/output",10			;5
   234                              <1> db "No such device",10			;6
   235                              <1> db 10					;7
   236                              <1> db 10					;8
   237                              <1> db "Bad file descriptor",10		;9
   238                              <1> db "No child processes",10		;10
   239                              <1> db 10					;11		
   240                              <1> db "Memory exhausted",10		;12
   241                              <1> db "Permission denied",10		;13
   242                              <1> db 10					;14
   243                              <1> db 10					;15
   244                              <1> db "Device|resource busy",10		;16
   245                              <1> db "File exists",10			;17
   246                              <1> db 10					;18
   247                              <1> db "No such device",10			;19
   248                              <1> db 10					;20
   249                              <1> db "Is a directory",10			;21
   250                              <1> db "Invalid argument",10		;22
   251                              <1> db "Too many open files",10		;23
   252                              <1> db "Too many open files",10		;24
   253                              <1> db "Inappropriate ioctl",10		;25
   254                              <1> db "Text file busy",10			;26
   255                              <1> db "File too large",10			;27
   256                              <1> db "No space on device",10		;28
   257                              <1> db "Illegal seek",10			;29
   258                              <1> db "R/O file system",10			;30
   259                              <1> 	%endmacro
   260                              <1> %else
   261                              <1> %ifdef LINUX	;----------------------- L I N U X -----------------------
   262                              <1> 	;asm/termbits.h
   263                              <1> 	;asm/ioctls.h
   264                              <1> 	%define TERMIOS_SET 5402h			;TCSETS
   265                              <1> 	%define TERMIOS_GET 5401h			;TCGETS
   266                              <1> 	%define TERMIOS_WSIZE 5413h			;TIOCGWINSZ
   267                              <1> 	%define NCCS 19
   268                              <1> 	%define VMIN 6
   269                              <1> ;-------
   270                              <1> %ifndef AMD64
   271                              <1> 	;asm/stat.h
   272                              <1> 	%define UIDGID_WORD
   273                              <1> 	struc stat_struc
   274 00000000 <res 00000004>      <1> .st_dev:	resd 1
   275 00000004 <res 00000004>      <1> .st_ino:	resd 1		;unsigned long  st_ino;
   276 00000008 <res 00000002>      <1> .st_mode:	resw 1		;unsigned short st_mode;
   277 0000000A <res 00000002>      <1> .st_nlink:	resw 1
   278 0000000C <res 00000002>      <1> .st_uid:	resw 1
   279 0000000E <res 00000002>      <1> .st_gid:	resw 1
   280 00000010 <res 00000004>      <1> .st_rdev:	resd 1
   281 00000014 <res 00000004>      <1> .st_size:	resd 1
   282 00000018 <res 00000004>      <1> .st_blksize:	resd 1
   283 0000001C <res 00000004>      <1> .st_blocks:	resd 1
   284 00000020 <res 00000004>      <1> .st_atime:	resd 1
   285 00000024 <res 00000004>      <1> .__unused1:	resd 1
   286 00000028 <res 00000004>      <1> .st_mtime:	resd 1
   287 0000002C <res 00000004>      <1> .__unused2:	resd 1
   288 00000030 <res 00000004>      <1> .st_ctime:	resd 1
   289 00000034 <res 00000004>      <1> .__unused3:	resd 1
   290 00000038 <res 00000004>      <1> .__unused4:	resd 1
   291 0000003C <res 00000004>      <1> .__unused5:	resd 1
   292                              <1> 	endstruc
   293                              <1> 
   294                              <1> %define SYS_exit	1
   295                              <1> %define SYS_fork	2
   296                              <1> %define SYS_read	3
   297                              <1> %define SYS_write	4
   298                              <1> %define SYS_open	5
   299                              <1> %define SYS_close	6
   300                              <1> %define SYS_unlink	10
   301                              <1> %define SYS_execve	11
   302                              <1> %define SYS_lseek	19
   303                              <1> %define SYS_utime	30
   304                              <1> %define SYS_kill	37
   305                              <1> %define SYS_rename	38
   306                              <1> %define SYS_pipe	42
   307                              <1> %define SYS_brk		45
   308                              <1> %define SYS_ioctl	54
   309                              <1> %define SYS_dup2	63
   310                              <1> %define SYS_sigaction	67
   311                              <1> %define SYS_rt_sigaction 174
   312                              <1> %define SYS_readlink	85
   313                              <1> %define SYS_fchmod	94
   314                              <1> %define SYS_fchown	95
   315                              <1> %define SYS_fstat	108
   316                              <1> %define SYS_wait4	114
   317                              <1> %define SYS_select	142
   318                              <1> %ifndef ARMCPU
   319                              <1> %define time_t	resd
   320                              <1> %endif
   321                              <1> %else				;;--------- AMD64
   322                              <1> 	struc stat_struc
   323                              <1> .st_dev:	resq 1
   324                              <1> .st_ino:	resq 1
   325                              <1> .st_nlink:	resq 1
   326                              <1> .st_mode:	resd 1
   327                              <1> .st_uid:	resd 1
   328                              <1> .st_gid:	resd 1
   329                              <1> .__unused0:	resd 1
   330                              <1> .st_rdev:	resq 1
   331                              <1> .st_size:	resq 1
   332                              <1> .st_blksize:	resq 1
   333                              <1> .st_blocks:	resq 1
   334                              <1> .st_atime:	resq 1
   335                              <1> .__unused1:	resq 1
   336                              <1> .st_mtime:	resq 1
   337                              <1> .__unused2:	resq 1
   338                              <1> .st_ctime:	resq 1
   339                              <1> .__unused3:	resq 1
   340                              <1> .__unused4:	resq 1
   341                              <1> .__unused5:	resq 1
   342                              <1> 	endstruc
   343                              <1> %define SYS_exit	60
   344                              <1> %define SYS_fork	57
   345                              <1> %define SYS_read	0
   346                              <1> %define SYS_write	1
   347                              <1> %define SYS_open	2
   348                              <1> %define SYS_close	3
   349                              <1> %define SYS_unlink	87
   350                              <1> %define SYS_execve	59
   351                              <1> %define SYS_lseek	8
   352                              <1> %define SYS_utime	132	;30
   353                              <1> %define SYS_kill	62
   354                              <1> %define SYS_rename	82
   355                              <1> %define SYS_pipe	22
   356                              <1> %define SYS_brk		12
   357                              <1> %define SYS_ioctl	16
   358                              <1> %define SYS_dup2	33
   359                              <1> %define SYS_rt_sigaction 13
   360                              <1> %define SYS_rt_sigreturn 15
   361                              <1> %define SYS_readlink	89
   362                              <1> %define SYS_fchmod	91
   363                              <1> %define SYS_fchown	93
   364                              <1> %define SYS_fstat	5
   365                              <1> %define SYS_wait4	61
   366                              <1> %define SYS_select	23	;142
   367                              <1> 
   368                              <1> %define time_t	resq
   369                              <1> %endif
   370                              <1> 
   371                              <1> %ifndef ARMCPU
   372                              <1> 	struc utimbuf_struc
   373 00000000 <res 00000004>      <1> .actime: time_t  1
   374 00000004 <res 00000004>      <1> .modtime:time_t 1
   375                              <1> 	endstruc
   376                              <1> %else
   377                              <1> 	struc utimbuf_struc
   378                              <1> .actime: resd  1
   379                              <1> .modtime:resd 1
   380                              <1> 	endstruc
   381                              <1> %endif
   382                              <1> %ifdef CRIPLED_ELF
   383                              <1> %define USE_SPECIAL_HEADER		;special ELF header etc
   384                              <1> %endif
   385                              <1> 
   386                              <1> ;-------
   387                              <1> %ifdef UTF8
   388                              <1>  %define NEW_CURSOR_MGNT		;switch cursor depending of 'INSERT'-mode
   389                              <1>  %undef CURSORMGNT			;switch cursor depending of 'INSERT'-mode
   390                              <1>  ;no more support of CURSORMGNT for UTF-8 thus replaced by:
   391                              <1>  ;8.Juni 2004: see /usr/src/linux/Documentation/VGA-softcursor.txt
   392                              <1> %else
   393                              <1>  %define CURSORMGNT
   394                              <1>  ;trad style
   395                              <1>  %ifdef AMD64
   396                              <1>   %undef CURSORMGNT			;work around January 2006
   397                              <1>  %endif
   398                              <1> %endif
   399                              <1> ;--------
   400                              <1> 
   401                              <1> SIGCONT		equ 18
   402                              <1> SIGSTOP		equ 19
   403                              <1> 
   404                              <1> %define CAPTURE_STDERR
   405                              <1> %ifdef EX
   406                              <1>  %define USE_EX_NO_SED
   407                              <1>  %define EX_PATH '/usr/bin/ex'		;(ex is usually a symlink to vi)   [ old was /bin/ex ]
   408                              <1> %else
   409                              <1>  %undef USE_EX_NO_SED
   410                              <1>  %ifndef PERLPIPE
   411                              <1>  %define SEDPATH '/bin/sed'		;DEFAULT
   412                              <1>  %else
   413                              <1>  %define SEDPATH '/usr/bin/perl'
   414                              <1>  %endif
   415                              <1> %endif
   416                              <1> 
   417                              <1> MAXERRNO	equ 32
   418                              <1> ERRNOMEM	equ 12
   419                              <1> ERRNOIO		equ 5
   420                              <1> ERRNOEXEC	equ 31
   421                              <1> 	%macro errortext 0
   422                              <1> db "Op not permitted",10		;1
   423                              <1> db "No such file|directory",10		;2
   424                              <1> db 10					;3
   425                              <1> db 10					;4
   426                              <1> db "Input/output",10			;5
   427                              <1> db "No such device",10			;6
   428                              <1> db 10					;7
   429                              <1> db 10					;8
   430                              <1> db "Bad file descriptor",10		;9
   431                              <1> db "No child processes",10		;10
   432                              <1> db 10					;11		
   433                              <1> db "Memory exhausted",10		;12
   434                              <1> db "Permission denied",10		;13
   435                              <1> db 10					;14
   436                              <1> db 10					;15
   437                              <1> db "Device|resource busy",10		;16
   438                              <1> db "File exists",10			;17
   439                              <1> db 10					;18
   440                              <1> db "No such device",10			;19
   441                              <1> db 10					;20
   442                              <1> db "Is a directory",10			;21
   443                              <1> db "Invalid argument",10		;22
   444                              <1> db "Too many open files",10		;23
   445                              <1> db "Too many open files",10		;24
   446                              <1> db "Inappropriate ioctl",10		;25
   447                              <1> db "Text file busy",10			;26
   448                              <1> db "File too large",10			;27
   449                              <1> db "No space on device",10		;28
   450                              <1> db "Illegal seek",10			;29
   451                              <1> db "R/O file system",10			;30
   452                              <1> db "Can't exec "			;31
   453                              <1> %ifdef USE_EX_NO_SED
   454                              <1> db EX_PATH,10
   455                              <1> %else
   456                              <1> db SEDPATH,10
   457                              <1> %endif
   458                              <1> db "Broken pipe",10			;32
   459                              <1> 	%endmacro
   460                              <1> %ifdef LIBC
   461                              <1>  extern open,read,write,close,lseek,rename,_exit,ioctl,fstat,fchown,select,unlink,fchmod
   462                              <1>  extern _errno
   463                              <1>  %undef SYS_readlink
   464                              <1>  %undef SYS_brk
   465                              <1>  %undef SYS_kill
   466                              <1>  %undef SYS_sigaction
   467                              <1>  %undef SYS_rt_sigaction
   468                              <1>  %undef USE_PIPE
   469                              <1> %endif
   470                              <1> %ifdef ARMCPU
   471                              <1>  %undef USE_MATH
   472                              <1>  %undef USE_UNDO
   473                              <1>  %undef USE_PIPE
   474                              <1> %endif
   475                              <1> %else
   476                              <1> %ifdef FREEBSD	;----------------------- FREE B S D -----------------------
   477                              <1> 	;sys/termios.h
   478                              <1> 	%define TERMIOS_SET   802c7414h		;TIOCSETA
   479                              <1> 	%define TERMIOS_GET   402c7413h		;TIOCGETA
   480                              <1> 	%define TERMIOS_WSIZE 40087468h
   481                              <1> 	;		      rw	
   482                              <1> 	;		        size
   483                              <1> 	;			  't'
   484                              <1> 	;			    nr.
   485                              <1> 	%define NCCS 20
   486                              <1> 	%define VMIN 16
   487                              <1> 	%define speed_t3	resd
   488                              <1> 	%define ICRNL	0x100 
   489                              <1> 	%define IXON	0x200
   490                              <1> 	%define ICANON	0x100
   491                              <1> 	%define ISIG	0x80
   492                              <1> 	%define ECHO	0x8
   493                              <1> 	%define TSize   word			;due oversized ICANON
   494                              <1> ;------
   495                              <1> 
   496                              <1> 	struc stat_struc
   497                              <1> .st_dev:	resd 1
   498                              <1> .st_ino:	resd 1
   499                              <1> %ifdef OPENBSD
   500                              <1> .st_mode:	resw 1				;for syscall 279
   501                              <1> .st_nlink:	resw 1				;ditto
   502                              <1> %else
   503                              <1> .st_mode:	resd 1
   504                              <1> .st_nlink:	resd 1
   505                              <1> %endif
   506                              <1> .st_uid:	resd 1
   507                              <1> .st_gid:	resd 1
   508                              <1> .st_rdev:	resd 1
   509                              <1> .st_atime:	resd 1
   510                              <1> .st_atimes:	resd 1
   511                              <1> .st_mtime:	resd 1
   512                              <1> .st_mtimes:	resd 1
   513                              <1> .st_ctime:	resd 1
   514                              <1> .st_ctimes:	resd 1
   515                              <1> .st_size:	resd 2
   516                              <1> .st_blocks:	resd 2
   517                              <1> .st_blksize:	resd 1
   518                              <1> .st_flags:	resd 1
   519                              <1> .st_gen:	resd 1
   520                              <1> .st_spare:	resd 5
   521                              <1> 	endstruc
   522                              <1> 
   523                              <1> %define SYS_exit	1
   524                              <1> %define SYS_fork	2
   525                              <1> %define SYS_read	3
   526                              <1> %define SYS_write	4
   527                              <1> %define SYS_open	5
   528                              <1> %define SYS_close	6
   529                              <1> %define SYS_unlink	10
   530                              <1> %define SYS_execve	59
   531                              <1> %define SYS_lseek	199	;old was 19
   532                              <1> %define SYS_utime	138
   533                              <1> %define SYS_kill	37
   534                              <1> %define SYS_rename	128
   535                              <1> %define SYS_pipe	42
   536                              <1> %define SYS_ioctl	54
   537                              <1> %define SYS_dup2	90
   538                              <1> %define SYS_sigaction	46	;also 342 *** take care if >255 cause only register al used
   539                              <1> %define SYS_readlink	58
   540                              <1> %define SYS_fchown	123
   541                              <1> %define SYS_fchmod      124
   542                              <1> %define SYS_fstat	279	;old was 189
   543                              <1> %define SYS_wait4	7
   544                              <1> %define SYS_select	93
   545                              <1> 
   546                              <1> %ifdef OPENBSD
   547                              <1> %undef SYS_kill
   548                              <1> %undef SYS_sigaction
   549                              <1> %undef  SYS_fstat	
   550                              <1> %define SYS_fstat	189	;could not test 292
   551                              <1> %endif
   552                              <1> 
   553                              <1> %ifdef NETBSD
   554                              <1> %undef SYS_kill		;both
   555                              <1> %undef SYS_sigaction	;currently only for old COMPAT layer working
   556                              <1> %endif
   557                              <1> 
   558                              <1> 
   559                              <1> %define time_t	resd
   560                              <1> 
   561                              <1> 	struc utimbuf_struc
   562                              <1> .actime: time_t  2
   563                              <1> .modtime:time_t 2
   564                              <1> 	endstruc
   565                              <1> 	
   566                              <1> %undef CAPTURE_STDERR
   567                              <1> %ifdef EX
   568                              <1>  %define USE_EX_NO_SED
   569                              <1>  %define EX_PATH '/usr/bin/ex'		;(ex is usually a symlink to vi)   [ old was /bin/ex ]
   570                              <1> %else
   571                              <1>  %undef USE_EX_NO_SED
   572                              <1>  %ifndef PERLPIPE
   573                              <1>  %define SEDPATH '/usr/bin/sed'		;DEFAULT
   574                              <1>  %else
   575                              <1>  %define SEDPATH '/usr/bin/perl'
   576                              <1>  %endif
   577                              <1> %endif
   578                              <1> 
   579                              <1> MAXERRNO	equ 32
   580                              <1> ERRNOMEM	equ 12
   581                              <1> ERRNOIO		equ 5
   582                              <1> ERRNOEXEC	equ 31
   583                              <1> ERRNOREGFILE	equ 21
   584                              <1> 	%macro errortext 0
   585                              <1> db "Op not permitted",10		;1
   586                              <1> db "No such file|directory",10		;2
   587                              <1> db 10					;3
   588                              <1> db 10					;4
   589                              <1> db "Input/output",10			;5
   590                              <1> db "No such device",10			;6
   591                              <1> db 10					;7
   592                              <1> db 10					;8
   593                              <1> db "Bad file descriptor",10		;9
   594                              <1> db "No child processes",10		;10
   595                              <1> db 10					;11		
   596                              <1> db "Memory exhausted",10		;12
   597                              <1> db "Permission denied",10		;13
   598                              <1> db 10					;14
   599                              <1> db 10					;15
   600                              <1> db "Device busy",10			;16
   601                              <1> db "File exists",10			;17
   602                              <1> db 10					;18
   603                              <1> db "No such device",10			;19
   604                              <1> db 10					;20
   605                              <1> db "Is a directory",10			;21
   606                              <1> db "Invalid argument",10		;22
   607                              <1> db "Too many open files",10		;23
   608                              <1> db "Too many open files",10		;24
   609                              <1> db "Inappropriate ioctl",10		;25
   610                              <1> db "Text file busy",10			;26
   611                              <1> db "File too large",10			;27
   612                              <1> db "No space on device",10		;28
   613                              <1> db "Illegal seek",10			;29
   614                              <1> db "R/O file system",10			;30
   615                              <1> db "Can't exec "			;31
   616                              <1> %ifdef USE_EX_NO_SED
   617                              <1> db EX_PATH,10
   618                              <1> %else
   619                              <1> db SEDPATH,10
   620                              <1> %endif
   621                              <1> db "Broken pipe",10			;32
   622                              <1> 	%endmacro
   623                              <1> %ifdef LIBC
   624                              <1>  extern open,read,write,close,lseek,rename,_exit,ioctl,fstat,fchown,select,unlink,fchmod
   625                              <1>  extern errno
   626                              <1>  %undef SYS_readlink
   627                              <1>  %undef SYS_brk
   628                              <1>  %undef SYS_kill
   629                              <1>  %undef SYS_sigaction
   630                              <1>  %undef USE_PIPE
   631                              <1> %endif
   632                              <1> 
   633                              <1> %else
   634                              <1> %ifdef W32	;----------------------- W I N  32 -----------------------
   635                              <1> %define W32LF				;<-- controls linefeed style
   636                              <1> 
   637                              <1> STD_INPUT_HANDLE	equ -10
   638                              <1> STD_OUTPUT_HANDLE	equ -11
   639                              <1> ENABLE_WINDOW_INPUT	equ 8
   640                              <1> FILE_ATTRIBUTE_NORMAL	equ 128
   641                              <1> OPEN_EXISTING		equ 3
   642                              <1> CREATE_ALWAYS		equ 2
   643                              <1> GENERIC_READ		equ $80000000
   644                              <1> GENERIC_WRITE		equ $40000000
   645                              <1> INVALID_HANDLE_VALUE	equ -1
   646                              <1> FOREGROUND_BLUE		equ 1
   647                              <1> FOREGROUND_GREEN	equ 2
   648                              <1> FOREGROUND_RED		equ 4
   649                              <1> FOREGROUND_INTENSITY	equ 8
   650                              <1> DARKWHITE		equ (FOREGROUND_GREEN|FOREGROUND_BLUE|FOREGROUND_RED)
   651                              <1> WHITE			equ (DARKWHITE|FOREGROUND_INTENSITY)
   652                              <1> BACKGROUND_BLUE		equ 16
   653                              <1> YELLOW_BLUE		equ FOREGROUND_GREEN|FOREGROUND_RED|FOREGROUND_INTENSITY|BACKGROUND_BLUE
   654                              <1> YELLOW_BLUE_TWICE	equ YELLOW_BLUE| (YELLOW_BLUE<<16)
   655                              <1> LEFT_ALT_PRESSED	equ 2
   656                              <1> CTRL_PRESSED		equ 12
   657                              <1> VK_SPACE		equ 0x0020
   658                              <1> VK_PRIOR		equ 0x0021
   659                              <1> VK_DELETE		equ 0x002E
   660                              <1> CF_OEMTEXT		equ 7
   661                              <1> 
   662                              <1> extern MessageBoxA,MessageBeep,ExitProcess
   663                              <1> extern GetStdHandle,GetCommandLineA,GetLastError,SetConsoleTextAttribute
   664                              <1> extern SetConsoleMode,GetConsoleScreenBufferInfo,SetConsoleCursorPosition
   665                              <1> extern WriteFile,ReadFile,CreateFileA,CloseHandle,SetFilePointer,MoveFileA,DeleteFileA
   666                              <1> extern FillConsoleOutputAttribute,WaitForSingleObject,ReadConsoleA,ReadConsoleInputA
   667                              <1> extern FlushConsoleInputBuffer,WriteConsoleOutputCharacterA,WriteConsoleOutputAttribute
   668                              <1> extern HeapCreate,HeapAlloc,HeapFree,HeapDestroy,OpenClipboard,EmptyClipboard
   669                              <1> extern SetClipboardData,GetClipboardData,IsClipboardFormatAvailable,CloseClipboard
   670                              <1> 	%define W32_EXTENDED_IO
   671                              <1> 	%undef USE_PIPE
   672                              <1> 
   673                              <1> MAXERRNO	equ 32
   674                              <1> ERRNOMEM	equ 8
   675                              <1> ERRNOIO		equ 7
   676                              <1> 
   677                              <1> 	%macro errortext 0
   678                              <1> db "invalid function",10		;1
   679                              <1> db "file not found",10			;2
   680                              <1> db "path not found",10			;3
   681                              <1> db "too many open files",10		;4
   682                              <1> db "access denied",10			;5
   683                              <1> db "invalid handle",10			;6
   684                              <1> db "I/O error",10			;7
   685                              <1> db "not enough memory",10		;8
   686                              <1> db 10					;9
   687                              <1> db 10					;10
   688                              <1> db 10					;11
   689                              <1> db 10					;12
   690                              <1> db 10					;13
   691                              <1> db 10					;14
   692                              <1> db 10					;15
   693                              <1> db 10					;16
   694                              <1> db 10					;17
   695                              <1> db 10					;18
   696                              <1> db 10					;19
   697                              <1> db 10					;20
   698                              <1> db 10					;21
   699                              <1> db 10					;22
   700                              <1> db 10					;23
   701                              <1> db 10					;24
   702                              <1> db 10					;25
   703                              <1> db 10					;26
   704                              <1> db 10					;27
   705                              <1> db 10					;28
   706                              <1> db 10					;29
   707                              <1> db 10					;30
   708                              <1> db 10					;31
   709                              <1> db "sharing violation",10  		;32
   710                              <1> 	%endmacro
   711                              <1> 
   712                              <1> %else		;----------------------- END OS -----------------------
   713                              <1> %error no OS defined
   714                              <1> %endif
   715                              <1> %endif
   716                              <1> %endif
   717                              <1> %endif
   718                              <1> %endif
   719                              <1> %endif
   720                              <1> 
   721                              <1> 
   722                              <1> %ifdef TERMIOS_SET
   723                              <1> %ifdef ARMCPU
   724                              <1>  	struc termios_struc
   725                              <1> .c_iflag:	resd 1
   726                              <1> .c_oflag:	resd 1
   727                              <1> .c_cflag:	resd 1
   728                              <1> .c_lflag:	resd 1
   729                              <1> .c_line:	resb 1
   730                              <1> .c_cc:		resb NCCS
   731                              <1> 	endstruc
   732                              <1> %else
   733                              <1> %define tcflag_t	resd
   734                              <1> %define cc_t		resb
   735                              <1>  	struc termios_struc
   736 00000000 <res 00000004>      <1> .c_iflag:	tcflag_t 1
   737 00000004 <res 00000004>      <1> .c_oflag:	tcflag_t 1
   738 00000008 <res 00000004>      <1> .c_cflag:	tcflag_t 1
   739 0000000C <res 00000004>      <1> .c_lflag:	tcflag_t 1
   740 00000010 <res 00000001>      <1> .c_line:	cc_t 1
   741                              <1> %ifdef speed_t1
   742                              <1> c_ixxxxx:	speed_t1 1
   743                              <1> c_oxxxxx:	speed_t1 1
   744                              <1> %endif
   745 00000011 <res 00000013>      <1> .c_cc:		cc_t NCCS
   746                              <1> %ifdef speed_t2
   747                              <1> res:		resd 3
   748                              <1> c_ixxxxx:	speed_t2 1
   749                              <1> c_oxxxxx:	speed_t2 1
   750                              <1> %endif
   751                              <1> %ifdef speed_t3
   752                              <1> c_ispeed speed_t3 1
   753                              <1> c_ospeed speed_t3 1
   754                              <1> %endif
   755                              <1> 	endstruc
   756                              <1> %endif
   757                              <1> 	struc winsize_struc
   758 00000000 <res 00000002>      <1> .ws_row:resw 1
   759 00000002 <res 00000002>      <1> .ws_col:resw 1
   760 00000004 <res 00000002>      <1> .ws_xpixel:resw 1
   761 00000006 <res 00000002>      <1> .ws_ypixel:resw 1
   762                              <1> 	endstruc
   763                              <1> 
   764                              <1> %ifndef IXON				;all except *BSD
   765                              <1> %define ICRNL	0000400q
   766                              <1> %define IXON	0002000q
   767                              <1> %define ICANON	0000002q
   768                              <1> %define ISIG	0000001q
   769                              <1> %define ECHO	0000010q
   770                              <1> %define TSize   byte
   771                              <1> %endif
   772                              <1> %endif
   773                              <1> 
   774                              <1> ;-------
   775                              <1> %ifndef LINUX
   776                              <1>  %undef CRIPLED_ELF
   777                              <1>  %undef UTF8
   778                              <1> %endif
   779                              <1> ;--------
   780                              <1> ;
   781                              <1> stdtxtlen	equ 10			;do not move this to EOF: code size would increase
   782                              <1> 
   783                              <1> %ifdef FREEBSD
   784                              <1> SIGCONT		equ 19
   785                              <1> SIGSTOP		equ 17
   786                              <1> O_WRONLY_CREAT_TRUNC equ 601h		;see fcntl.h
   787                              <1> %else
   788                              <1> %ifdef QNX
   789                              <1> O_WRONLY_CREAT_TRUNC equ 1401q
   790                              <1> %else
   791                              <1> O_WRONLY_CREAT_TRUNC equ 1101q
   792                              <1> %endif
   793                              <1> %endif
   794                              <1> 
   795                              <1> O_RDONLY	equ 0
   796                              <1> PERMS		equ 644q
   797                              <1> stdin		equ 0
   798                              <1> stdout 		equ 1
   799                              <1> optslen		equ 124
   800                              <1> TAB		equ 8
   801                              <1> TABCHAR		equ 09h
   802                              <1> SPACECHAR	equ ' '
   803                              <1> CHANGED		equ '*'
   804                              <1> UNCHANGED	equ SPACECHAR
   805                              <1> LINEFEED	equ 0ah
   806                              <1> NEWLINE		equ LINEFEED
   807                              <1> RETURN		equ 0dh
   808                              <1> SEDBLOCK	equ 4096
   809                              <1> 
   810                              <1> 
   811                              <1> 
   812                              <1> 
   813                              <1> ;--------------------------------------------------------------------------
   814                              <1> %ifdef CRIPLED_ELF
   815                              <1> ;
   816                              <1> ; building e3 via "nasm -f bin ...."  using an idea from
   817                              <1> ;"A Whirlwind Tutorial on Creating Really Teensy ELF Executables for Linux"
   818                              <1> ;
   819                              <1>        %macro ELFheader 0
   820                              <1> ehdr:	db 0x7F, "ELF", 1, 1, 1, 0	;Elf32_Ehdr starts here
   821                              <1> 	dd 0,0
   822                              <1> 	dw 2				;e_type
   823                              <1> 	dw 3				;e_machine
   824                              <1> 	dd 1				;e_version
   825                              <1> 	dd _start			;e_entry
   826                              <1> 	dd phdr1- $$			;e_phoff
   827                              <1> 	dd 0				;e_shoff
   828                              <1> 	dd 0				;e_flags
   829                              <1> 	dw ehdrsize			;e_ehsize
   830                              <1> 	dw phdrsize			;e_phentsize
   831                              <1> 	dw 2				;e_phnum
   832                              <1> phdr1:					;Elf32_Phdr starts here
   833                              <1> 	dd 1				;both p_type and e_shentsize,e_shnum
   834                              <1> 	dw 0				;both p_offset and e_shstrndx
   835                              <1> ehdrsize equ $ - ehdr
   836                              <1> 	dw 0
   837                              <1> 	dd $$				;p_vaddr
   838                              <1> 	dd $$				;p_paddr
   839                              <1> 	dd filesize			;p_filesz
   840                              <1> 	dd filesize			;p_memsz
   841                              <1> 	dd 5				;p_flags i.e. READ/EXECUTE
   842                              <1> 	dd 0;  0x1000			;p_align
   843                              <1> phdrsize equ $ - phdr1
   844                              <1> phdr2:					;another Elf32_Phdr starts here
   845                              <1> 	dd 1				;p_type
   846                              <1> 	dd filesize
   847                              <1> 	dd $$+filesize
   848                              <1> 	dd $$+filesize
   849                              <1> 	dd 0				;p_filesz
   850                              <1> 	dd bsssize			;p_memsz
   851                              <1> 	dd 6				;p_flags i.e. READ/WRITE
   852                              <1> 	dd 0;  0x1000			;p_align
   853                              <1> 	%endmacro
   854                              <1> %endif
   855                              <1> ;-------
   856                              <1> %ifndef ARMCPU
   857                              <1> 	%macro ORGheader 0
   858                              <1> %ifdef USE_SPECIAL_HEADER
   859                              <1> %ifdef TINLINK
   860                              <1> 	org 0x800004A			;see file contrib/README.tinlink624
   861                              <1> %else
   862                              <1> 	org 0x8048000
   863                              <1> 	ELFheader
   864                              <1> 	times 0xC79 db 0
   865                              <1> %endif
   866                              <1> %else
   867                              <1> 	;nothing
   868                              <1> %endif
   869                              <1> 	%endmacro
   870                              <1> %endif
   871                              <1> ;-------
   872                              <1> %ifdef DYN				;DYN == "libc dynamic linked"
   873                              <1>  %define _start main			;call it "main", libc startup code expects this name
   874                              <1> %endif
   875                              <1> 
   876                              <1> ;-------
   877                              <1> %ifdef AMD64
   878                              <1>   %macro PUSH_ALL 0
   879                              <1>   	push rax
   880                              <1> 	push rbx
   881                              <1> 	push rcx
   882                              <1> 	push rdx
   883                              <1> 	push rsi
   884                              <1> 	push rdi
   885                              <1> 	push rbp
   886                              <1>   %endmacro
   887                              <1>   %macro POP_ALL 0
   888                              <1> 	pop  rbp
   889                              <1> 	pop  rdi
   890                              <1> 	pop  rsi
   891                              <1> 	pop  rdx
   892                              <1> 	pop  rcx
   893                              <1> 	pop  rbx
   894                              <1> 	pop  rax
   895                              <1>   %endmacro
   896                              <1> %else
   897                              <1>   %macro PUSH_ALL 0
   898                              <1> 	pusha
   899                              <1>   %endmacro
   900                              <1>   %macro POP_ALL 0
   901                              <1> 	popa
   902                              <1>   %endmacro
   903                              <1> %endif
   904                              <1> ;--------------------------------------------------------------------------
    22                                  ;
    23                                  section .text
    24                                  bits 32
    25                                  	ORGheader
    25                              <1> %ifdef USE_SPECIAL_HEADER
    25                              <1> %ifdef TINLINK
    25                              <1>  org 0x800004A
    25                              <1> %else
    25                              <1>  org 0x8048000
    25                              <1>  ELFheader
    25 00000000 7F454C4601010100    <2> ehdr: db 0x7F, "ELF", 1, 1, 1, 0
    25 00000008 0000000000000000    <2>  dd 0,0
    25 00000010 0200                <2>  dw 2
    25 00000012 0300                <2>  dw 3
    25 00000014 01000000            <2>  dd 1
    25 00000018 [E70C0000]          <2>  dd _start
    25 0000001C 2E000000            <2>  dd phdr1- $$
    25 00000020 00000000            <2>  dd 0
    25 00000024 00000000            <2>  dd 0
    25 00000028 3400                <2>  dw ehdrsize
    25 0000002A 2000                <2>  dw phdrsize
    25 0000002C 0200                <2>  dw 2
    25                              <2> phdr1:
    25 0000002E 01000000            <2>  dd 1
    25 00000032 0000                <2>  dw 0
    25                              <2> ehdrsize equ $ - ehdr
    25 00000034 0000                <2>  dw 0
    25 00000036 [00000000]          <2>  dd $$
    25 0000003A [00000000]          <2>  dd $$
    25 0000003E 00400000            <2>  dd filesize
    25 00000042 00400000            <2>  dd filesize
    25 00000046 05000000            <2>  dd 5
    25 0000004A 00000000            <2>  dd 0
    25                              <2> phdrsize equ $ - phdr1
    25                              <2> phdr2:
    25 0000004E 01000000            <2>  dd 1
    25 00000052 00400000            <2>  dd filesize
    25 00000056 [00400000]          <2>  dd $$+filesize
    25 0000005A [00400000]          <2>  dd $$+filesize
    25 0000005E 00000000            <2>  dd 0
    25 00000062 ECDC1000            <2>  dd bsssize
    25 00000066 06000000            <2>  dd 6
    25 0000006A 00000000            <2>  dd 0
    25 0000006E 00<rept>            <1>  times 0xC79 db 0
    25                              <1> %endif
    25                              <1> %else
    25                              <1> 
    25                              <1> %endif
    26                                  global _start
    27                                  ;
    28                                  ; start with OUTER editor loop
    29                                  ;
    30 00000CE7 E8521B0000              _start:	call SetTermStruc
    31                                  %ifdef SELFTEST
    32                                  	mov eax,mode
    33                                  	mov byte [eax],WS		;store current editor mode:  WS only..
    34                                  	mov esi,pipein			;...because the test file expects WS "syntax"
    35                                  %else
    36                                  %ifdef W32
    37                                  	push byte 0
    38                                  	push dword 8192			;initial size (to be extended)
    39                                  	push byte 0
    40                                  	call HeapCreate
    41                                  	mov [heap],eax
    42                                  ;------
    43                                  	mov eax,mode
    44                                  	mov byte [eax],DEFAULT_MODE	;store default editor mode
    45                                  	call GetCommandLineA		;eax points to  either	D:\PATH\E3.EXE args1 args2 args3...
    46                                  	xchg eax,esi			;               or	"d:\path\e3.exe"
    47                                  	;-- for debug only --		;		or	e3.exe "args"
    48                                  	;PUSH_ALL
    49                                  	;push dword 0			;single OK button
    50                                  	;push dword esi
    51                                  	;push dword esi
    52                                  	;push dword 0
    53                                  	;call MessageBoxA		;show cmd line
    54                                  	;POP_ALL
    55                                  	;--------------------
    56                                  	cld
    57                                  	xor ebx,ebx
    58                                  	cmp byte [esi],'"'		;due above mentined 2 different cmd line ways
    59                                  	jnz prog
    60                                  	dec ebx				;ebx -1 due pending '"'
    61                                  prog:	lodsb
    62                                  	or al,al
    63                                  	jz prog9
    64                                  	cmp al,SPACECHAR		;TODO chk TABs
    65                                  	ja prog
    66                                  	inc esi
    67                                  prog9:	dec esi
    68                                  prog0:	push esi
    69                                  	lea esi,[esi+ebx-4-5]		;-4 due suffix ".exe"
    70                                  	call SetEditMode
    71                                  	jz prog1
    72                                  	mov byte [eax],DEFAULT_MODE	;store current editor mode
    73                                  prog1:	pop esi
    74                                  	xor edx,edx			;no args
    75                                  prog2:	lodsb
    76                                  	or al,al
    77                                  	jz prog3
    78                                  	cmp al,SPACECHAR
    79                                  	jbe prog2
    80                                  	dec esi
    81                                  	jmp short prog5
    82                                  prog3:	mov esi,edx
    83                                  prog5:
    84                                  %else
    85                                  %ifdef BEOS ;-----------------------------------------------------------
    86                                  	pop eax
    87                                  	pop ebx				;args counter (1....x)
    88                                  	pop esi
    89                                  	mov esi,[esi]			;points to our_name0[args]0env.....
    90                                  	cld
    91                                  prog:	lodsb
    92                                  	or al,al
    93                                  	jne prog
    94                                  	mov edx,esi			;store arg ptr
    95                                  	lea esi,[esi-5]
    96                                  	call SetEditMode
    97                                  	jz prog1
    98                                  	mov byte [eax],DEFAULT_MODE	;store current editor mode
    99                                  prog1:	xor esi,esi			;init for 'no args'
   100                                  	dec ebx
   101                                  	jz noarg
   102                                  	mov esi,edx
   103                                  noarg:
   104                                  %else
   105                                  %ifdef DYN ;------------------------------------------------------------
   106                                  ; This is to be called from dynamic linked libc startup code 
   107                                  ; just like you would expect:  int main(int argc,char**argv)
   108                                  ; (for experimental purpose only)
   109                                  ;
   110                                  	xor esi,esi			;init to "no args"
   111                                  	mov ecx,[esp+4]			;"int argc"
   112                                  	cmp ecx,1
   113                                  	je NoArg
   114                                  	mov esi,[esp+8]			;"char**argv"
   115                                  	mov esi,[esi]
   116                                  	cld
   117                                  Argl:	lodsb
   118                                  	or al,al
   119                                  	jne Argl
   120                                  NoArg:	mov eax,mode
   121                                  	mov byte [eax],DEFAULT_MODE	;store current editor mode (WS only)
   122                                  %undef CURSORMGNT
   123                                  %else	;-------------- i.e. Linux, FreeBSD, QNX, Ath ------------------
   124                                  %ifdef SYS_rt_sigaction
   125 00000CEC E8391C0000              	call SetSigHandler
   126                                  %else
   127                                  %ifdef SYS_sigaction
   128                                  	call SetSigHandler
   129                                  %endif
   130                                  %endif
   131                                  ;-------
   132                                  %ifdef ATHEOS
   133                                  	pop edx
   134                                  	pop edx
   135                                  	pop edx
   136                                  %endif
   137 00000CF1 5A                      	pop edx				;Linux: arguments #
   138 00000CF2 5E                      	pop esi				;Linux: argv[0]
   139 00000CF3 FC                      	cld
   140 00000CF4 AC                      prog:	lodsb
   141 00000CF5 08C0                    	or al,al
   142 00000CF7 75FB                    	jne prog			;get program name
   143                                  %ifdef AMD64
   144                                  	lea rsi,[rsi-5]
   145                                  %else
   146 00000CF9 8D76FB                  	lea esi,[esi-5]
   147                                  %endif
   148 00000CFC E89C1A0000              	call SetEditMode
   149 00000D01 7403                    	jz prog1
   150 00000D03 C60001                  	mov byte [eax],DEFAULT_MODE	;store current editor mode
   151                                  prog1:
   152                                  ;-------
   153 00000D06 5E                      	pop esi				;Linux: esi points to first arg (filename)
   154                                  %ifdef NEW_CURSOR_MGNT
   155 00000D07 E8681B0000              	call SetCursorBlock
   156                                  %endif
   157                                  %endif
   158                                  %endif
   159                                  %endif
   160                                  %endif
   161                                  ;-------
   162                                  %ifdef CURSORMGNT
   163                                  	or esi,esi
   164                                  	jz moreenv
   165                                  morearg:pop ecx				;arguments until NULL
   166                                  	or ecx,ecx
   167                                          jnz morearg
   168                                  ;-------
   169                                  moreenv:pop ecx
   170                                  	jecxz ReStart
   171                                  %ifndef ARMCPU
   172                                  	cmp dword[ecx],'TERM'		;a short test for "TERM=linux"
   173                                  	jnz moreenv
   174                                  	cmp dword[ecx+5],'linu'
   175                                  %else
   176                                  	cmp byte[ecx],'T'
   177                                  	jnz moreenv
   178                                  	cmp byte[ecx+1],'E'
   179                                  	jnz moreenv
   180                                  	cmp byte[ecx+2],'R'
   181                                  	jnz moreenv
   182                                  	cmp byte[ecx+3],'M'
   183                                  	jnz moreenv
   184                                  	cmp byte[ecx+5],'l'
   185                                  	jnz ReStart
   186                                  	cmp byte[ecx+6],'i'
   187                                  	jnz ReStart
   188                                  	cmp byte[ecx+7],'n'
   189                                  	jnz ReStart
   190                                  	cmp byte[ecx+8],'u'
   191                                  %endif
   192                                  	jnz ReStart
   193                                  	add byte[revvoff],boldlen	;special inverse cursor on linux terminals
   194                                  %endif
   195                                  %ifdef UTF8RTS
   196                                  	mov ecx,getPos 			;second argument: pointer to message to write
   197                                  	push byte gPlen			;third argument: message length
   198                                  	pop edx
   199                                  	call WriteFile0
   200                                  	mov ecx,screenbuffer		;pointer to buf
   201                                  	push byte 10
   202                                  	pop edx
   203                                  	call ReadFile0			;get cursor pos
   204                                  	mov al,[ecx+eax-2]		;al == '2' @ UTF8 terminal,  else al == '3'
   205                                  	sub al,'3'
   206                                  	mov byte [isUTF8],al
   207                                  %endif
   208                                  ;-------
   209 00000D0C E815150000              ReStart:call NewFile
   210 00000D11 7248                    	jc E3exit
   211 00000D13 E88E1D0000              MainCharLoop:call ChkCursPos
   212 00000D18 E84A0A0000              	call IsViMode
   213 00000D1D 751C                    	jnz MCL
   214 00000D1F 8B0D[182F0100]          	mov ecx,[blockbegin]
   215 00000D25 E314                    	jecxz MCL
   216 00000D27 57                      	push edi
   217 00000D28 89CF                    	mov edi,ecx			;for vi only: keep Begin/End-line marker together
   218 00000D2A E8EC090000              	call KeyEnd
   219                                  	; <------prev line------------>
   220                                  	; BegM......marker line........EndM
   221                                  	; <-------next line----------->
   222 00000D2F 893D[1C2F0100]          	mov [blockende],edi		;set WS's "blockende" to one after EOL for VI marker
   223 00000D35 5F                      	pop edi
   224 00000D36 E80A070000              	call ShowBl1			;i.e. "mov byte [showblock],1"
   225                                  ;-------
   226 00000D3B E8370A0000              MCL:	call DispNewScreen
   227 00000D40 E8E1160000              	call RestoreStatusLine
   228 00000D45 E83E000000              	call HandleChar
   229                                  %ifdef W32LF
   230                                  	cmp byte [edi],RETURN		;never stay at character 0dh
   231                                  	jnz MCL2
   232                                  	inc edi				;(rather stay at following 0ah)
   233                                  MCL2:
   234                                  %endif
   235 00000D4A BB[202F0100]            	mov ebx,endeedit
   236 00000D4F 803B00                  	cmp byte [ebx],0
   237 00000D52 74BF                    	je MainCharLoop
   238 00000D54 31F6                    	xor esi,esi			;just like if no arg is present
   239 00000D56 803B02                  	cmp byte [ebx],2
   240 00000D59 74B1                    	je ReStart			;^KD repeat edit using another file
   241 00000D5B E8EC110000              E3exit:	call KursorStatusLine
   242                                  %ifdef W32
   243                                  	push dword w32result		;reset all to standard colors
   244                                  	push byte 0
   245                                  	mov eax,[lines]
   246                                  	inc eax
   247                                  	mov ebx,[columns]
   248                                  	mul bl
   249                                  	push eax
   250                                  	push byte DARKWHITE		;equ 7
   251                                  	push dword [hout]
   252                                  	call FillConsoleOutputAttribute
   253                                  %endif
   254 00000D60 B9[EC3C0100]            	mov ecx,text			;enter next line on terminal NEWLINE is @ byte [text]
   255 00000D65 E82E1B0000              	call WriteFile00
   256                                  %ifdef NEW_CURSOR_MGNT
   257 00000D6A E8FB1A0000              	call SetCursorNormal
   258                                  %endif
   259                                  ;-------
   260 00000D6F BB[3E2F0000]            	mov ebx,tempfile2		;undo info (if exist)
   261 00000D74 E89F1B0000              	call Unlink
   262                                  %ifdef W32
   263                                  	push dword [heap]
   264                                  	call HeapDestroy
   265                                  	push byte 0			;return code
   266                                  	call ExitProcess		;Ready&Exit
   267                                  %else
   268 00000D79 B902540000              	mov ecx,TERMIOS_SET 
   269 00000D7E E8011B0000              	call IOctlTerminal0		;restore termios settings
   270 00000D83 E9411B0000              	jmp Exit
   271                                  %endif
   272                                  ;----------------------------------------------------------------------
   273                                  ;
   274                                  ; MAIN function for processing keys
   275                                  ;
   276 00000D88 E82F0E0000              HandleChar:call ReadChar
   277 00000D8D 80FCFF                  	cmp ah,0xFF			;normal chars get 0xFF in ah
   278 00000D90 0F8527010000            	jne near ExtAscii		;go handling Cursor-Keys
   279 00000D96 BE[A0380100]            	mov esi,mode
   280 00000D9B F60606                  	test byte [esi], EM | PI
   281 00000D9E 741A                    	jz NO_EM01
   282 00000DA0 3C0B                    	cmp al,11
   283 00000DA2 7407                    	je IsCtrlK
   284 00000DA4 C605[78380100]00        	mov byte [EmaCtrlK],0
   285 00000DAB 3C13                    IsCtrlK:cmp al,13h			;^S
   286 00000DAD 740B                    	je IsCtrlS
   287 00000DAF 3C12                    	cmp al,12h			;^R
   288 00000DB1 7407                    	je IsCtrlS
   289 00000DB3 C605[79380100]00        	mov byte [EmaCtrlS],0
   290                                  IsCtrlS:
   291 00000DBA 803E08                  NO_EM01:cmp byte [esi],VI
   292 00000DBD 7426                    	jz ISVI1
   293 00000DBF 3C20                    	cmp al,32			;in WS,EM,PI,NE: handle control chars
   294 00000DC1 733A                    	jae NormChar
   295 00000DC3 88C3                    	mov bl,al
   296 00000DC5 80C355                  	add bl,jumps1
   297 00000DC8 803E01                  	cmp byte [esi],WS
   298 00000DCB 7413                    	je CJump
   299 00000DCD 80C320                  	add bl,32
   300 00000DD0 803E02                  	cmp byte [esi],EM
   301 00000DD3 740B                    	je CJump
   302 00000DD5 80C320                  	add bl,32
   303 00000DD8 803E04                  	cmp byte [esi],PI
   304 00000DDB 7403                    	je CJump
   305 00000DDD 80C320                  	add bl,32
   306 00000DE0 E9E6000000              CJump:	jmp CompJump2
   307                                  ISVI1:					;in VI: most control is done in command mode...
   308 00000DE5 3C07                    	cmp al,7			;... so maintaining another table for <Return>...
   309 00000DE7 0F848E020000            	je near KeyDel			;... <Del> and <DelLeft> is useless
   310 00000DED 3C08                    	cmp al,8
   311 00000DEF 0F847F020000            	je near KeyDell
   312 00000DF5 3C0D                    	cmp al,RETURN
   313 00000DF7 0F8414010000            	je near KeyRet
   314                                  ;-------
   315 00000DFD F605[A0380100]06        NormChar:test byte [mode], EM | PI
   316 00000E04 7405                    	jz NOEM0
   317 00000E06 E842060000              	call ShowBl0			;i.e. "mov byte [showblock],0"
   318                                  NOEM0:	
   319                                  %ifdef UTF8
   320                                  %ifdef UTF8RTSx_wont			;won't overwrite more than one single ASCII byte at once...
   321                                  	cmp byte [isUTF8],0		;...with a 2- or 3-byte UTF-8 character entered from keyboard.
   322                                  	je noUTF_A			;So @ non-UTF8 consoles byte 2,3,... are always inserted.
   323                                  %endif
   324 00000E0B 88C3                    	mov bl,al
   325 00000E0D 80E3C0                  	and bl,0C0h
   326 00000E10 80FB80                  	cmp bl,080h			;byte 2,3,4.. always insert
   327 00000E13 740E                    	je NormCh2
   328                                  noUTF_A:
   329                                  %endif
   330 00000E15 E8EE0F0000              	call CheckMode
   331                                  %ifdef USE_UNDO
   332 00000E1A 7407                    	jz NormCh2
   333 00000E1C E8FC1F0000              	call DataForUndoOverwrite
   334 00000E21 EB09                    	jmp short OverWriteChar
   335                                  %else
   336                                  	jnz OverWriteChar
   337                                  %endif	
   338 00000E23 50                      NormCh2:push eax
   339                                  %ifdef W32LF
   340                                  	call CheckEof
   341                                  	jz noEOL
   342                                  	cmp word [edi-1],RETURN|(NEWLINE<<8)
   343                                  	jnz noEOL
   344                                  	dec edi				;move back to 0Dh
   345                                  noEOL:
   346                                  %endif
   347 00000E24 E8F0110000              	call Insert1Byte
   348 00000E29 58                      	pop eax
   349 00000E2A 721D                    	jc InsWriteEnd			;error: text buffer full
   350 00000E2C FC                      OverWriteChar:cld
   351 00000E2D AA                      	stosb
   352                                  %ifdef UTF8
   353                                  %ifdef UTF8RTSx_wont			;won't produce incomplete UTF8 characters: ....
   354                                  	cmp byte [isUTF8],0		;...so one single ASCII will overwrite a complete...
   355                                  	je noUTF_B			;...UTF8 byte sequence at once.
   356                                  %endif
   357 00000E2E 31C0                    	xor eax,eax
   358 00000E30 48                      	dec eax
   359 00000E31 40                      OWCloopUTF8:inc eax
   360 00000E32 8A1C07                  	mov bl,byte [edi+eax]
   361 00000E35 80E3C0                  	and bl,0C0h
   362 00000E38 80FB80                  	cmp bl,080h			;delete byte 2,3,4,....
   363 00000E3B 74F4                    	je OWCloopUTF8
   364 00000E3D E8AD110000              	call DeleteByte
   365                                  noUTF_B:
   366                                  %endif
   367 00000E42 C605[0C2F0100]2A        SetChg:	mov byte [changed],CHANGED
   368 00000E49 C3                      InsWriteEnd:ret
   369                                  ;-------
   370 00000E4A E87A0E0000              KeyVICmdr:call ReadOneChar		;repl one char (except newline)
   371 00000E4F 803F0A                  	cmp byte [edi],NEWLINE
   372 00000E52 74F5                    	je InsWriteEnd
   373 00000E54 3C0D                    	cmp al,RETURN
   374 00000E56 7502                    	jnz KeyVICmdr1
   375 00000E58 B00A                    	mov al,NEWLINE
   376                                  KeyVICmdr1:
   377                                  %ifdef USE_UNDO
   378 00000E5A E8BE1F0000              	call DataForUndoOverwrite
   379                                  %endif	
   380 00000E5F 8807                    KeyVICmdr2:mov byte [edi],al
   381 00000E61 EBDF                    	jmp short SetChg
   382                                  ;-------
   383 00000E63 BE[CD2F0000]            KeyEmaCtrlQ:mov esi,asknumber
   384 00000E68 E87F180000              	call GetOctalToInteger
   385 00000E6D 76DA                    	jbe InsWriteEnd
   386 00000E6F 91                      	xchg eax,ecx			;using decimal input for ASCII value
   387 00000E70 3D00010000              	cmp eax,256
   388 00000E75 72AC                    	jb NormCh2
   389 00000E77 C3                      	ret
   390                                  ;-------
   391                                  ;
   392                                  ; helper for HandleChar
   393                                  ;
   394 00000E78 BB[8C300000]            CtrlKMenu:mov ebx,Ktable
   395 00000E7D B04B                    	mov al,'K'
   396 00000E7F EB20                    	jmp short Menu
   397 00000E81 BB[A7300000]            CtrlQMenu:mov ebx,Qtable
   398 00000E86 EB0E                    	jmp short PicoQM
   399 00000E88 BB[DD300000]            PicoJMenu:mov ebx,PicoJtable
   400 00000E8D B04A                    	mov al,'J'
   401 00000E8F EB10                    	jmp short Menu
   402 00000E91 BB[F8300000]            PicoQMenu:mov ebx,PicoQtable
   403 00000E96 B051                    PicoQM:	mov al,'Q'
   404 00000E98 EB07                    	jmp short Menu
   405 00000E9A BB[C2300000]            CtrlXMenu:mov ebx,Xtable
   406 00000E9F B058                    	mov al,'X'
   407 00000EA1 B95E202020              Menu:	mov ecx,2020205eh
   408 00000EA6 88C5                    	mov ch,al
   409                                  ;-------
   410 00000EA8 E8BE0A0000              MakeScanCode:call WriteTwo		;ebx expects xlat-table
   411 00000EAD 53                      	push ebx
   412 00000EAE E8160D0000              	call GetChar
   413 00000EB3 5B                      	pop ebx
   414 00000EB4 241F                    	and al,01fh
   415 00000EB6 3C1B                    	cmp al,Ktable_size
   416 00000EB8 738F                    	jnb InsWriteEnd			;if no valid scancode
   417 00000EBA D7                      	xlatb
   418 00000EBB 88C4                    	mov ah,al			;=pseudo "scancode"
   419                                  ;------- cont
   420 00000EBD 88E3                    ExtAscii:mov bl,ah			;don't use al (carries char e.g. TAB)
   421 00000EBF 80FB55                  	cmp bl,jumps1
   422 00000EC2 7385                    	jae InsWriteEnd
   423 00000EC4 31C0                    	xor eax,eax
   424 00000EC6 A3[78380100]            	mov [EmaCtrl],eax
   425 00000ECB B700                    CompJump2:mov bh,0
   426                                  %ifdef YASM
   427                                  	and ebx,0ffh
   428                                  %else
   429 00000ECD 678D1F                  	lea ebx,[bx]			;1 byte shorter than 'and ebx,0ffh'
   430                                  %endif
   431 00000ED0 0FB79C1B[13310000]      	movzx ebx,word [2*ebx+jumptab1] ;2*ebx is due 2 byte per entry
   432                                  ;;;%ifdef YASM
   433                                  ;;;%ifdef AMD64
   434                                  ;;;	add rbx,0x400000b0
   435                                  ;;;%else
   436                                  ;;;	add ebx,0x08048080		;most ugly work around ever written
   437                                  ;;;%endif
   438                                  ;;;%else
   439 00000ED8 81C3[E70C0000]          	add ebx,_start			;offset inside code
   440                                  ;;;%endif
   441                                  ;-------
   442 00000EDE FFD3                    	call ebx			;the general code jump dispatcher
   443                                  ;-------
   444 00000EE0 803D[482F0100]01        	cmp byte [numeriere],1		;after return from functions...
   445 00000EE7 7523                    	jnz BZNret			;...decide whether count current line number
   446 00000EE9 57                      	push edi
   447 00000EEA BE[ED3C0100]            	mov esi,sot
   448 00000EEF 87F7                    	xchg esi,edi
   449 00000EF1 31D2                    	xor edx,edx
   450 00000EF3 42                      BZNLoop:inc edx				;edx=linenr counter
   451 00000EF4 E8220E0000              	call LookForward
   452 00000EF9 47                      	inc edi				;point to start of next line
   453 00000EFA 39F7                    	cmp edi,esi
   454 00000EFC 76F5                    	jbe BZNLoop
   455 00000EFE 8915[2C2F0100]          	mov [linenr],edx
   456 00000F04 5F                      	pop edi
   457 00000F05 C605[482F0100]00        	mov byte [numeriere],0
   458 00000F0C C3                      BZNret:	ret
   459                                  ;----------------------------------------------------------------------
   460                                  ;
   461                                  ; processing special keys: cursor, ins, del
   462                                  ;
   463 00000F0D 31C0                    KeyRetNoInd:xor eax,eax
   464 00000F0F EB28                    	jmp short KeyRetNInd
   465                                  KeyRet:	
   466                                  ;;; %define NO_AUTO_INDENT		;for Izzy
   467                                  %ifndef NO_AUTO_INDENT
   468                                  %ifdef SELFTEST
   469                                  	xor eax,eax
   470                                  %else
   471 00000F11 E8F20E0000              	call CheckMode
   472 00000F16 7542                    	jnz  OvrRet
   473 00000F18 E8420F0000              	call CountToLineBegin		;set esi / returns eax
   474 00000F1D 46                      	inc esi
   475 00000F1E 46                      	inc esi
   476 00000F1F 09C0                    	or eax,eax
   477 00000F21 7416                    	jz KeyRetNInd
   478 00000F23 89C3                    	mov ebx,eax	
   479 00000F25 31C0                    	xor eax,eax
   480 00000F27 48                      	dec eax
   481 00000F28 40                      KeyRetSrch:inc eax			;search non (SPACE or TABCHAR)
   482 00000F29 39D8                    	cmp eax,ebx
   483 00000F2B 730C                    	jae KeyRetNInd
   484 00000F2D 803C0620                	cmp byte [esi+eax],SPACECHAR
   485 00000F31 74F5                    	je KeyRetSrch
   486 00000F33 803C0609                	cmp byte [esi+eax],TABCHAR
   487 00000F37 74EF                    	je KeyRetSrch
   488                                  %endif
   489                                  %else
   490                                  	xor eax,eax
   491                                  %endif
   492 00000F39 56                      KeyRetNInd:push esi
   493 00000F3A 50                      	push eax			;eax is 0 or =indented chars
   494 00000F3B E8B30F0000              	call GoDown
   495 00000F40 58                      	pop eax
   496 00000F41 50                      	push eax
   497                                  %ifdef W32LF
   498                                  	inc eax				;1 extra for RETURN
   499                                  	call CheckEof
   500                                  	jz noEOL2
   501                                  	cmp word [edi-1],RETURN|(NEWLINE<<8)
   502                                  	jnz noEOL2
   503                                  	dec edi				;move back to 0Dh
   504                                  noEOL2:
   505                                  %endif
   506 00000F42 E8D4100000              	call InsertByte0		;1 extra for NEWLINE
   507 00000F47 59                      	pop ecx				;# blanks
   508 00000F48 5E                      	pop esi				;where to copy
   509 00000F49 720E                    	jc SimpleRet
   510 00000F4B FF05[2C2F0100]          	inc dword [linenr]
   511 00000F51 FC                      	cld
   512                                  %ifdef W32LF
   513                                  	mov ax,RETURN|(NEWLINE<<8)	;insert 0d0ah combination
   514                                  	stosw
   515                                  %else
   516 00000F52 B00A                    	mov al,NEWLINE
   517 00000F54 AA                      	stosb
   518                                  %endif
   519 00000F55 E302                    	jecxz SimpleRet
   520 00000F57 F3A4                    	rep movsb			;copy upper line i.e. SPACES,TABS into next
   521 00000F59 C3                      SimpleRet:ret
   522 00000F5A 31C0                    OvrRet:	xor eax,eax
   523 00000F5C A3[442F0100]            	mov [ch2linebeg],eax
   524 00000F61 EB05                    	jmp short DownRet
   525                                  ;-------
   526 00000F63 E8C00E0000              KeyDown:call CountColToLineBeginVis
   527 00000F68 E8860F0000              DownRet:call GoDown
   528 00000F6D E8FA0D0000              	call LookLineDown
   529 00000F72 EB4B                    	jmp short JmpSC
   530                                  ;-------
   531 00000F74 E8760F0000              KeyUp:	call GoUp
   532 00000F79 E8AA0E0000              	call CountColToLineBeginVis
   533 00000F7E E8DE0D0000              	call LookLineUp
   534 00000F83 EB3A                    	jmp short JmpSC
   535                                  ;-------
   536 00000F85 E89E0E0000              KeyHalfPgUp:call CountColToLineBeginVis
   537 00000F8A E80C0E0000              	call LookHalfPgUp
   538 00000F8F EB3A                    	jmp short SetColumn
   539                                  ;-------
   540 00000F91 E8920E0000              KeyHalfPgDn:call CountColToLineBeginVis
   541 00000F96 E80B0E0000              	call LookHalfPgDn
   542 00000F9B EB2E                    	jmp short SetColumn
   543                                  ;-------
   544 00000F9D E8860E0000              KeyScrollUp:call CountColToLineBeginVis
   545 00000FA2 E8EF0D0000              	call LookScrUp
   546 00000FA7 EB22                    	jmp short SetColumn
   547 00000FA9 E87A0E0000              KeyScrollDn:call CountColToLineBeginVis
   548 00000FAE E8DE0D0000              	call LookScrDn
   549 00000FB3 EB16                    	jmp short SetColumn
   550                                  ;-------
   551 00000FB5 E86E0E0000              KeyPgUp:call CountColToLineBeginVis
   552 00000FBA E8B80D0000              	call LookPageUp
   553 00000FBF EB0A                    JmpSC:	jmp short SetColumn
   554                                  ;-------
   555 00000FC1 E8620E0000              KeyPgDn:call CountColToLineBeginVis
   556 00000FC6 E8E60D0000              	call LookPgDown			;1st char last line
   557 00000FCB 8B0D[442F0100]          SetColumn:mov ecx,[ch2linebeg]		;=maximal columns
   558 00000FD1 31D2                    	xor edx,edx			;counts visible columns i.e. expand TABs
   559 00000FD3 4F                      	dec edi
   560 00000FD4 47                      SCloop:	inc edi
   561                                  %ifdef UTF8
   562                                  %ifdef UTF8RTS
   563                                  	cmp byte [isUTF8],0		;if the tty can't handle UTF8..
   564                                  	je noUTF_C			;..each byte is one column
   565                                  %endif
   566 00000FD5 8A1F                    	mov bl,byte [edi]
   567 00000FD7 80E3C0                  	and bl,0C0h
   568 00000FDA 80FB80                  	cmp bl,080h			;do not count byte 2,3,4,.. for columns in UTF8 chars
   569 00000FDD 74F5                    	jz SCloop
   570                                  noUTF_C:
   571                                  %endif
   572 00000FDF 39CA                    	cmp edx,ecx			;from CountColToLineBeginVis
   573 00000FE1 7318                    	jae SCret
   574 00000FE3 803F0A                  	cmp byte [edi],NEWLINE		;don't go beyond line earlier line end
   575 00000FE6 7413                    	jz SCret
   576 00000FE8 803F09                  	cmp byte [edi],TABCHAR
   577 00000FEB 7403                    	jz SCtab
   578 00000FED 42                      	inc edx				;count columns
   579 00000FEE EBE4                    	jmp short SCloop
   580 00000FF0 E835170000              SCtab:	call SpacesForTab
   581 00000FF5 00E2                    	add dl,ah
   582 00000FF7 39CA                    	cmp edx,ecx			;this tab to far away right?
   583 00000FF9 76D9                    	jna SCloop			;no
   584 00000FFB C3                      SCret:	ret
   585                                  ;----------------------------------------------------------------------
   586                                  ;
   587                                  ; a helper for d'a and y'a vi commands
   588                                  ; have to differ whether cursor is below or above the marked line
   589                                  ; (at all this line based concept does not fit very well into e3)
   590                                  ; expects:
   591                                  ;	ecx valid begin of marked line
   592                                  ;	edi cursor
   593 00000FFC 39CF                    VIsetMarker:cmp edi,ecx
   594 00000FFE 771A                    	ja Marker_above_cursor
   595                                  	; X........cursor line.......
   596                                  	; ...........................
   597                                  	; .........marker line.......
   598                                  	; Y
   599 00001000 8B0D[1C2F0100]          	mov ecx,[blockende]
   600 00001006 41                      	inc ecx
   601 00001007 39E9                    	cmp ecx,ebp
   602 00001009 7201                    	jb Mbel
   603 0000100B 49                      	dec ecx
   604 0000100C 890D[74380100]          Mbel:	mov dword [EmaMark],ecx		;i.e. store point Y
   605                                  ;------- cont
   606 00001012 E8480E0000              KeyHome:call CountToLineBegin		;i.e. goto point X
   607 00001017 29C7                    	sub edi,eax
   608 00001019 C3                      	ret
   609                                  ;-------
   610                                  Marker_above_cursor:
   611                                  	; Y.......marker line .......	
   612                                  	; ...........................
   613                                  	; ........cursor line........
   614                                  	; X				;								
   615 0000101A 890D[74380100]          	mov dword [EmaMark],ecx		;i.e. store point Y
   616 00001020 E8F6060000              	call KeyEnd
   617 00001025 47                      	inc edi				;i.e. goto point X
   618 00001026 39EF                    	cmp edi,ebp
   619 00001028 7201                    	jb Mret
   620 0000102A 4F                      	dec edi
   621 0000102B C3                      Mret:	ret
   622                                  ;----------------------------------------------------------------------
   623 0000102C F615[582F0100]          KeyIns:	not byte [insstat]
   624 00001032 31C0                    	xor eax,eax
   625 00001034 E82E070000              	call IsViMode
   626 00001039 7513                    	jnz KeyIns2
   627 0000103B 40                      	inc eax
   628 0000103C 3805[80380100]          	cmp byte [VICmdMode],al
   629 00001042 750A                    	jne KeyIns2
   630 00001044 A2[582F0100]            	mov byte [insstat],al
   631 00001049 E880060000              	call KeyVImode0
   632 0000104E E81C070000              KeyIns2:call IsEmMode
   633 00001053 7505                    	jnz KeyIns3
   634 00001055 A2[302F0100]            	mov byte [showblock],al
   635                                  KeyIns3:
   636                                  %ifdef NEW_CURSOR_MGNT
   637 0000105A 803D[582F0100]01        	cmp byte [insstat],1
   638 00001061 0F8503180000            	jne near SetCursorNormal
   639 00001067 E908180000              	jmp SetCursorBlock
   640                                  %endif
   641 0000106C C3                      	ret
   642                                  ;-------
   643 0000106D E8A9060000              KeyVICmdJ:call KeyEnd
   644 00001072 EB07                    	jmp short KeyDel
   645                                  ;-------
   646 00001074 E877060000              KeyDell:call KeyLeft
   647 00001079 7430                    	jz KeyDell2
   648 0000107B 39EF                    KeyDel:	cmp edi,ebp
   649 0000107D 73DB                    	jnb KeyIns3
   650 0000107F 31C0                    	xor eax,eax			;delete one @ cursor
   651 00001081 40                      KDloopUTF8:inc eax
   652                                  %ifdef UTF8
   653                                  %ifdef UTF8RTSx_wont			;won't produce incomplete UTF8 characters: ....
   654                                  	cmp byte [isUTF8],0		;...so pressing DEL single will delete a complete..
   655                                  	je noUTF_D			...UTF8 byte sequence at once.
   656                                  %endif
   657 00001082 8A1C07                  	mov bl,byte [edi+eax]
   658 00001085 80E3C0                  	and bl,0C0h
   659 00001088 80FB80                  	cmp bl,080h
   660 0000108B 74F4                    	je KDloopUTF8			;delete one more at UTF-8 byte 2,3,4,....
   661                                  noUTF_D:
   662                                  %endif
   663                                  %ifdef W32LF
   664                                  	cmp byte [edi-1],RETURN
   665                                  	jnz KD2
   666                                  	dec edi				;delete one more
   667                                  	inc eax
   668                                  KD2:
   669                                  %endif
   670                                  ;-------
   671 0000108D E8D5060000              	call IsViMode
   672 00001092 0F85570F0000            	jne near DeleteByte
   673 00001098 89FE                    	mov esi,edi			;make vi's x and X pasteable
   674 0000109A C605[88380100]01        	mov byte [VInolinebased],1
   675 000010A1 E8B9100000              	call KeyEmaAltW2
   676 000010A6 E9440F0000              	jmp DeleteByte
   677                                  ;-------	
   678 000010AB 81FF[ED3C0100]          KeyDell2:cmp edi,sot			;delete newline char
   679 000010B1 76A7                    	jbe KeyIns3
   680 000010B3 FF0D[2C2F0100]          	dec dword [linenr]
   681 000010B9 4F                      	dec edi
   682 000010BA E9A4020000              	jmp KeyCtrlT1
   683                                  ;-------
   684                                  KeyEmaCtrlT:
   685                                  %ifdef UTF8
   686 000010BF C3                      	ret				;FIXME!!
   687                                  %else
   688                                  	cmp edi,sot			;xchg 2 chars
   689                                  	jbe KeyRightEnd
   690                                  	cmp byte [edi],NEWLINE
   691                                  	jnz KECT
   692                                  	dec edi
   693                                  KECT:	
   694                                  %ifdef USE_UNDO
   695                                  	call DataForUndoXchange
   696                                  %endif	
   697                                  	mov al,byte [edi]
   698                                  	xchg al,byte [edi-1]
   699                                  	call KeyVICmdr2			;mov byte [edi],al / mov byte [changed],CHANGED
   700                                  %endif
   701                                  ;-------
   702                                  KeyRight:
   703                                  %ifdef UTF8
   704                                  %ifdef UTF8RTSx_wont			;try to keep UTF8 bytes together..
   705                                  	cmp byte [isUTF8],0		;...also if the console can not display the UTF8 character
   706                                  	je noUTF_E
   707                                  %endif
   708 000010C0 47                      	inc edi
   709 000010C1 8A07                    	mov al,byte [edi]		;check for UTF byte 2,3,4,..
   710 000010C3 24C0                    	and al,0c0h
   711 000010C5 3C80                    	cmp al,080h
   712 000010C7 74F7                    	je KeyRight
   713 000010C9 4F                      	dec edi				;due inc edi above
   714                                  noUTF_E:
   715                                  %endif
   716 000010CA 803F0A                  	cmp byte [edi],NEWLINE
   717 000010CD 7518                    	jnz KeyRNoMargin
   718 000010CF E85B0C0000              	call CheckEof
   719 000010D4 7312                    	jae KeyRightEnd
   720 000010D6 E88C060000              	call IsViMode
   721 000010DB 740B                    	je KeyRightEnd			;no more line wrap around in vi mode
   722 000010DD E85B0C0000              	call CheckENum			;Sun Feb 20 2005
   723 000010E2 E80C0E0000              	call GoDown
   724 000010E7 47                      KeyRNoMargin:inc edi
   725 000010E8 C3                      KeyRightEnd:ret
   726                                  ;-------
   727 000010E9 81FF[ED3C0100]          KeyCLeft3:cmp edi,sot
   728 000010EF 7618                    	jbe KeyCLEnd
   729 000010F1 E8470C0000              	call CheckENum			;Sun Feb 20 2005
   730 000010F6 4F                      	dec edi
   731 000010F7 807FFF0A                KeyCtrlQW:cmp byte [edi-1],NEWLINE
   732 000010FB 74EC                    	jz KeyCLeft3
   733 000010FD 4F                      	dec edi
   734 000010FE 803F2F                  	cmp byte [edi],2fh
   735 00001101 76F4                    	jbe KeyCtrlQW
   736 00001103 807FFF2F                	cmp byte [edi-1],2fh
   737 00001107 77EE                    	ja KeyCtrlQW
   738 00001109 C3                      KeyCLEnd:ret
   739                                  ;-------
   740 0000110A E8200C0000              KeyCRight3:call CheckEof
   741 0000110F 7328                    	jae KeyCREnd
   742 00001111 E8270C0000              	call CheckENum			;Sun Feb 20 2005
   743 00001116 EB07                    	jmp short KQZ1
   744 00001118 B02F                    KeyCtrlQZ:mov al,2fh
   745 0000111A 803F0A                  	cmp byte [edi],NEWLINE
   746 0000111D 74EB                    	jz KeyCRight3
   747 0000111F 47                      KQZ1:	inc edi
   748 00001120 E84A060000              	call IsEmMode
   749 00001125 7409                    	jz ISEM2
   750 00001127 3807                    	cmp byte [edi],al		;ws stops at word begin
   751 00001129 76ED                    	jbe KeyCtrlQZ
   752 0000112B 3847FF                  	cmp byte [edi-1],al
   753 0000112E EB07                    	jmp short ISEM22
   754 00001130 3847FF                  ISEM2:	cmp byte [edi-1],al		;em stops after end
   755 00001133 76E3                    	jbe KeyCtrlQZ
   756 00001135 3807                    	cmp byte [edi],al
   757 00001137 77DF                    ISEM22:	ja KeyCtrlQZ
   758 00001139 C3                      KeyCREnd:ret
   759                                  ;-------
   760 0000113A E8F00B0000              KeyVIcmde3:call CheckEof		;end of word (vi only)
   761 0000113F 73F8                    	jae KeyCREnd
   762 00001141 47                      	inc edi
   763 00001142 803F0A                  KeyVIcmde:cmp byte [edi],NEWLINE
   764 00001145 74F3                    	jz KeyVIcmde3
   765 00001147 47                      	inc edi
   766 00001148 803F2F                  	cmp byte [edi],2fh
   767 0000114B 76F5                    	jbe KeyVIcmde
   768 0000114D 807F012F                	cmp byte [edi+1],2fh
   769 00001151 77EF                    	ja KeyVIcmde
   770 00001153 C3                      	ret
   771                                  ;-------
   772 00001154 E8C00E0000              KeyEmaCtrlO:call Insert1Byte
   773 00001159 728D                    	jc KeyRightEnd
   774 0000115B B00A                    	mov al,NEWLINE
   775 0000115D 8807                    	mov byte [edi],al
   776 0000115F C3                      	ret
   777                                  ;----------------------------------------------------------------------
   778                                  ;
   779                                  ; processing special keys from the WS's Ctrl-Q menu
   780                                  ;
   781 00001160 E8E00B0000              KeyCtrlQE:call LookPgBegin		;goto top left on screen
   782 00001165 E8D20D0000              	call KursorFirstLine
   783 0000116A EB20                    	jmp short KCtKV1
   784                                  ;-------
   785 0000116C E8E00B0000              KeyCtrlQX:call LookPgEnd		;1st goto last line on screen
   786 00001171 E8A5050000              	call KeyEnd			;2nd goto line end
   787 00001176 E8C50D0000              	call KursorLastLine
   788 0000117B EB0F                    	jmp short KCtKV1
   789                                  ;-------
   790 0000117D 803D[142F0100]00        KeyCtrlQV:cmp byte [bereitsges],0	;goto last ^QA,^QF pos
   791 00001184 74B3                    	jz KeyCREnd
   792 00001186 8B3D[102F0100]          	mov edi,[oldQFpos]
   793 0000118C E9E1000000              KCtKV1:	jmp CQFNum
   794                                  ;-------
   795 00001191 6AFF                    KeyVIbsearch:push byte -1
   796 00001193 EB02                    	jmp short KVIf
   797 00001195 6A01                    KeyVIfsearch:push byte 1
   798 00001197 C605[402F0100]FF        KVIf:	mov byte[grossklein],0ffh
   799 0000119E EB64                    	jmp short KeyECtS1
   800                                  ;-------
   801 000011A0 893D[8C380100]          PicoCtrlTpico:mov [PicoSearch],edi	;store begin of search (because wrap around EOF)
   802 000011A6 6A01                    KeyEmaAltPer:push byte 1		;s&repl
   803 000011A8 8F05[3C2F0100]          	pop dword[vorwarts]
   804 000011AE C605[402F0100]DF        	mov byte[grossklein],0dfh
   805                                  ;-------
   806 000011B5 C605[142F0100]02        KeyCtrlQA:mov byte [bereitsges],2
   807 000011BC E829140000              	call AskForReplace
   808 000011C1 7209                    	jc SimpleRet9
   809 000011C3 57                      CQACtrlL:push edi
   810 000011C4 E8CF140000              	call FindText
   811 000011C9 7302                    	jnc CQACL2
   812 000011CB 5F                      	pop edi
   813 000011CC C3                      SimpleRet9:ret
   814 000011CD A1[342F0100]            CQACL2:	mov eax,[suchlaenge]
   815 000011D2 E8180E0000              	call DeleteByte
   816 000011D7 A1[382F0100]            	mov eax,[repllaenge]
   817 000011DC E83B0E0000              	call InsertByte
   818 000011E1 BE[C8320100]            	mov esi,replacetext
   819 000011E6 E8EE0E0000              	call MoveBlock
   820 000011EB EB7E                    	jmp short CQFFound
   821                                  ;-------
   822 000011ED 803D[142F0100]02        KeyPiCtrlJT:cmp byte [bereitsges],2
   823 000011F4 74CD                    	jz CQACtrlL
   824 000011F6 C3                      	ret
   825                                  ;-------
   826 000011F7 6AFF                    KeyEmaCtrlR:push byte -1
   827 000011F9 EB02                    	jmp short KECS
   828                                  ;-------
   829 000011FB 6A01                    KeyEmaCtrlS:push byte 1
   830 000011FD C605[402F0100]DF        KECS:	mov byte[grossklein],0dfh
   831 00001204 8F05[3C2F0100]          KeyECtS1:pop dword[vorwarts]
   832 0000120A 893D[74380100]          	mov [EmaMark],edi
   833 00001210 E838020000              	call ShowBl0			;i.e. "mov byte [showblock],0"
   834                                  ;------- cont
   835 00001215 E855050000              KeyCtrlQF:call IsEmMode
   836 0000121A 7509                    	jnz NO_EM04
   837 0000121C 803D[79380100]01        	cmp byte [EmaCtrlS],1
   838 00001223 7454                    	jz KeyCtrlL
   839 00001225 FF35[C8330100]          NO_EM04:push dword [suchtext]		;store begin of old find_text
   840 0000122B C605[142F0100]01        	mov byte [bereitsges],1
   841 00001232 E8D5130000              	call AskForFind
   842 00001237 5B                      	pop ebx
   843 00001238 9C                      	pushf
   844 00001239 F605[A0380100]0C        	test byte [mode], VI | PI
   845 00001240 7417                    	jz NO_VIPI01
   846 00001242 9D                      	popf
   847 00001243 09C0                    	or eax,eax			;jmp if user entered a new find_text
   848 00001245 750A                    	jnz QFpico
   849 00001247 08DB                    	or bl,bl			;jmp if no old find text available
   850 00001249 742D                    	jz CtrlQFEnd
   851 0000124B 881D[C8330100]          	mov byte [suchtext],bl		;restore last find_text
   852 00001251 893D[8C380100]          QFpico:	mov [PicoSearch],edi		;store begin of search (because wrap around EOF)
   853 00001257 EB03                    	jmp short CQFCtrlL
   854                                  ;-------
   855 00001259 9D                      NO_VIPI01:popf
   856 0000125A 721C                    	jc CtrlQFEnd
   857 0000125C 57                      CQFCtrlL:push edi
   858 0000125D E836140000              	call FindText
   859 00001262 C605[79380100]01        	mov byte [EmaCtrlS],1
   860 00001269 720C                    	jc CtrlQFNotFound
   861 0000126B 893D[102F0100]          CQFFound:mov [oldQFpos],edi
   862 00001271 5E                      	pop esi				;dummy
   863 00001272 E9C60A0000              CQFNum:	jmp CheckENum			;i.e. "mov byte [numeriere],1   ret"
   864 00001277 5F                      CtrlQFNotFound:pop edi
   865 00001278 C3                      CtrlQFEnd:ret
   866                                  ;-------
   867 00001279 A1[142F0100]            KeyCtrlL:mov eax,[bereitsges]		;2^QA   1^QF   0else
   868 0000127E 48                      	dec eax
   869 0000127F 74DB                    	jz CQFCtrlL
   870 00001281 F605[A0380100]15        	test byte[mode],WS | NE | PI
   871 00001288 7407                    	jz SimpleRet4
   872 0000128A 48                      	dec eax
   873 0000128B 0F8432FFFFFF            	jz near CQACtrlL
   874 00001291 C3                      SimpleRet4:ret
   875                                  ;-------
   876 00001292 E8320A0000              KeyVIcmd1:call ReadOneChar
   877 00001297 3C47                    	cmp al,'G'
   878 00001299 7410                    	je KeyCtrlQR
   879 0000129B C3                      	ret
   880 0000129C E30D                    ViSpecial:jecxz KeyCtrlQR
   881 0000129E EB42                    	jmp short KCQI
   882 000012A0 892D[74380100]          KeyNedCtrlA:mov [EmaMark],ebp
   883 000012A6 E89A010000              	call ShowBl1			;i.e.  "mov byte [showblock],1"   but shorter
   884 000012AB BF[ED3C0100]            KeyCtrlQR:mov edi,sot
   885 000012B0 EBC0                    	jmp short CQFNum
   886                                  ;-------
   887 000012B2 8B0D[282F0100]          KeyCtrlQP:mov ecx,[veryold]
   888 000012B8 39E9                    	cmp ecx,ebp
   889 000012BA 77D5                    	ja SimpleRet4
   890 000012BC 89CF                    	mov edi,ecx
   891 000012BE EBB2                    JmpCQFN3:jmp short CQFNum
   892                                  ;-------
   893 000012C0 97                      KeyCtrlQB:xchg eax,edi
   894 000012C1 8B3D[182F0100]          	mov edi,[blockbegin]
   895 000012C7 09FF                    CtrlQB2:or edi,edi			;exit if no marker set
   896 000012C9 75A7                    	jnz CQFNum
   897 000012CB 97                      	xchg edi,eax
   898 000012CC C3                      	ret
   899                                  ;-------
   900 000012CD 97                      KeyCtrlQK:xchg eax,edi
   901 000012CE 8B3D[1C2F0100]          	mov edi,[blockende]
   902 000012D4 EBF1                    	jmp short CtrlQB2
   903                                  ;-------
   904 000012D6 BE[BB2F0000]            KeyCtrlQI:mov esi,asklineno
   905 000012DB E810140000              	call GetAsciiToInteger
   906 000012E0 7696                    	jbe CtrlQFEnd			;CY or ZR set
   907 000012E2 BF[ED3C0100]            KCQI:	mov edi,sot
   908 000012E7 E8D30A0000              	call LookPD2
   909 000012EC EBD0                    JmpCQFN:jmp short JmpCQFN3
   910                                  ;-------
   911 000012EE E8FD030000              KeyCtrlQDel:call KeyLeft		;delete all left of cursor
   912 000012F3 E8670B0000              	call CountToLineBegin
   913 000012F8 29C7                    	sub edi,eax
   914 000012FA EB37                    	jmp short KCY
   915                                  ;-------
   916 000012FC C605[88380100]01        KeyVICmdD:mov byte [VInolinebased],1
   917 00001303 E8180B0000              KeyCtrlQY:call CountToLineEnd
   918                                  %ifdef W32LF
   919                                  	or eax,eax
   920                                  	jz KCQY
   921                                  	cmp byte [edi+eax-1],0dh
   922                                  	jnz KCQY
   923                                  	dec eax				;keep RETURN 0dh char if exist
   924                                  KCQY:
   925                                  %endif
   926 00001308 E85A040000              	call IsViMode
   927 0000130D 7557                    	jnz CtrlTEnd1
   928 0000130F E852000000              	call CtrlTEnd1
   929 00001314 E9D7030000              	jmp KeyLeft
   930                                  ;-------
   931 00001319 E84B0B0000              KeyCmddw:call CountToWordBeginVIstyle
   932 0000131E EB3E                    	jmp short NO_EM05
   933                                  ;-------
   934 00001320 E8EDFCFFFF              KeyCtrlY:call KeyHome			;edi at begin
   935 00001325 E8F60A0000              	call CountToLineEnd
   936 0000132A 803D[A0380100]01        	cmp byte[mode],WS
   937 00001331 7507                    	jnz NO_WS01
   938 00001333 E8890C0000              KCY:	call DeleteByteCheckMarker
   939 00001338 EB29                    	jmp short KeyCtrlT1
   940 0000133A F605[A0380100]0C        NO_WS01:test byte [mode], VI | PI
   941 00001341 740A                    	jz KeyCtrlT
   942 00001343 8D0C07                  	lea ecx,[edi+eax]
   943 00001346 39E9                    	cmp ecx,ebp
   944 00001348 741C                    	jz CtrlTEnd1			;do not delete pending LINEFEED (0Ah)
   945 0000134A 40                      	inc eax
   946 0000134B EB19                    	jmp short CtrlTEnd1
   947                                  ;-------
   948 0000134D E81E0B0000              KeyCtrlT:call CountToWordBegin
   949 00001352 E818040000              	call IsEmMode
   950 00001357 7505                    	jnz NO_EM05
   951 00001359 E8C20A0000              KeyEmaCtrlK:call CountToLineEnd
   952 0000135E 803F0A                  NO_EM05:cmp byte [edi],NEWLINE
   953 00001361 7503                    	jnz CtrlTEnd1
   954 00001363 31C0                    KeyCtrlT1:xor eax,eax
   955 00001365 40                      	inc eax				;1 for LINEFEED (0ah)
   956                                  %ifdef W32LF
   957                                  	cmp byte[edi-1],RETURN
   958                                  	jnz KCT2
   959                                  	dec edi				;0dh is expected "left" of 0ah
   960                                  	inc eax				;1 for RETURN   (0dh)
   961                                  KCT2:
   962                                  %endif
   963 00001366 E8C4090000              CtrlTEnd1:call CheckEof
   964 0000136B 7477                    	jz SimpleRet3
   965 0000136D 803D[A0380100]01        	cmp byte[mode],WS
   966 00001374 0F84470C0000            	jz near DeleteByteCheckMarker
   967 0000137A 89FE                    	mov esi,edi
   968 0000137C E8DE0D0000              	call KeyEmaAltW2
   969 00001381 EB35                    	jmp short DelBjmp
   970                                  ;-------
   971 00001383 8B0D[302F0100]          KeyEmaCtrlW:mov ecx,[showblock]
   972 00001389 803D[A0380100]04        	cmp byte[mode],PI
   973 00001390 750C                    	jne NOPI1
   974                                  KECW:	
   975                                  %ifndef YASM
   976 00001392 E38C                    	jecxz KeyCtrlY
   977                                  %else
   978                                  	or ecx,ecx
   979                                  	jz near KeyCtrlY
   980                                  %endif
   981 00001394 8B0D[74380100]          	mov ecx,[EmaMark]
   982 0000139A E3F6                    	jecxz KECW
   983 0000139C EB0A                    	jmp short NOPI2
   984 0000139E E344                    NOPI1:	jecxz SimpleRet3
   985 000013A0 8B0D[74380100]          	mov ecx,[EmaMark]
   986 000013A6 E33C                    	jecxz SimpleRet3
   987 000013A8 E8F20D0000              NOPI2:	call KeyEmaAltW
   988 000013AD 8B3D[70380100]          	mov edi,[EmaKiSrc]
   989 000013B3 A1[6C380100]            	mov eax,[EmaKiSize]
   990 000013B8 E9320C0000              DelBjmp:jmp DeleteByte
   991                                  ;----------------------------------------------------------------------
   992                                  ;
   993                                  ; processing special Keys from WS's Ctrl-K menu
   994                                  ;
   995 000013BD E80B0A0000              KeyCtrlKY:call CheckBlock
   996 000013C2 7220                    	jc SimpleRet3			;no block: no action
   997 000013C4 A1[1C2F0100]            	mov eax,[blockende]
   998 000013C9 89F7                    	mov edi,esi			;esi is blockbegin (side effect in CheckBlock)
   999 000013CB 29F0                    	sub eax,esi			;block length
  1000 000013CD E81D0C0000              	call DeleteByte			;out ecx:=0
  1001 000013D2 91                      	xchg eax,ecx
  1002 000013D3 E8F2110000              	call InitSV2			;block no longer valid
  1003 000013D8 E90FFFFFFF              JmpCQFN2:jmp JmpCQFN
  1004                                  ;-------
  1005 000013DD 8035[302F0100]01        KeyCtrlKH:xor byte [showblock],1 	;flip flop
  1006 000013E4 C3                      SimpleRet3:ret
  1007                                  KeyCtrlKK:				;UTF-8 :no special handling needed, because block end...
  1008 000013E5 893D[1C2F0100]          	mov [blockende],edi		;... points to first byte _after_ block
  1009 000013EB EB58                    	jmp short ShowBl1
  1010                                  ;-------
  1011 000013ED E8C50C0000              KeyCtrlKC:call CopyBlock
  1012 000013F2 7258                    	jc SimpleRet2
  1013 000013F4 893D[182F0100]          CtrlKC2:mov [blockbegin],edi
  1014 000013FA 01F8                    	add eax,edi
  1015 000013FC E9CE110000              	jmp InitSV3			;mov [blockende],eax - ret
  1016                                  ;-------
  1017 00001401 8B0D[74380100]          KeyCtrlXX:mov ecx,[EmaMark]
  1018 00001407 E3DB                    	jecxz SimpleRet3
  1019 00001409 E873000000              	call KeyEmaMark
  1020 0000140E 89CF                    	mov edi,ecx
  1021 00001410 E8160B0000              	call KeyEmaCtrlL
  1022 00001415 EBC1                    KeyCXX:	jmp short JmpCQFN2
  1023                                  ;-------
  1024 00001417 E89B0C0000              KeyCtrlKV:call CopyBlock
  1025 0000141C 722E                    	jc SimpleRet2
  1026 0000141E 57                      	push edi
  1027 0000141F 3B3D[182F0100]          	cmp edi,[blockbegin]
  1028 00001425 9C                      	pushf
  1029 00001426 8B3D[182F0100]          	mov edi,[blockbegin]
  1030 0000142C E8BE0B0000              	call DeleteByte
  1031 00001431 F7D8                    	neg eax				;(for optimizing eax is negated there)
  1032 00001433 9D                      	popf
  1033 00001434 5F                      	pop edi
  1034 00001435 72BD                    	jb CtrlKC2
  1035 00001437 893D[1C2F0100]          	mov [blockende],edi
  1036 0000143D 29C7                    	sub edi,eax
  1037 0000143F 893D[182F0100]          KeyCtrlKB:mov [blockbegin],edi		;UTF-8: no special handling needed, because block begin...
  1038 00001445 C605[302F0100]01        ShowBl1:mov byte [showblock],1		;...points to _first_ byte in block
  1039 0000144C C3                      SimpleRet2:ret
  1040 0000144D C605[302F0100]00        ShowBl0:mov byte [showblock],0
  1041 00001454 C3                      	ret
  1042                                  ;-------
  1043 00001455 E86F080000              KeyVICmdm:call ReadOneChar
  1044 0000145A 3C61                    	cmp al,'a'			;ma (marker a)
  1045 0000145C 75EE                    	jne SimpleRet2
  1046 0000145E 57                      	push edi
  1047 0000145F E8AEFBFFFF              	call KeyHome			;setting WS's "blockbegin" to BOL
  1048 00001464 893D[182F0100]          	mov [blockbegin],edi
  1049 0000146A 5F                      	pop edi
  1050 0000146B C3                      	ret
  1051                                  ;-------
  1052 0000146C E858080000              KeyVICmdJmpM:call ReadOneChar
  1053 00001471 3C61                    	cmp al,'a'
  1054 00001473 75D7                    	jne SimpleRet2
  1055 00001475 8B0D[182F0100]          	mov ecx,[blockbegin]		;like WStar's Ctrl-QB  [also Sun Oct  7 17:01:37 2001]
  1056 0000147B E3CF                    	jecxz SimpleRet2
  1057 0000147D 89CF                    	mov edi,ecx
  1058 0000147F EB94                    	jmp short KeyCXX
  1059                                  ;-------
  1060 00001481 893D[74380100]          KeyEmaMark:mov [EmaMark],edi
  1061 00001487 EBBC                    	jmp short ShowBl1
  1062                                  ;-------
  1063 00001489 E8080F0000              KeyCtrlKR:call ReadBlock
  1064 0000148E 722C                    	jc CtrlKREnd
  1065 00001490 E8AAFFFFFF              	call KeyCtrlKB
  1066 00001495 01F9                    	add ecx,edi
  1067 00001497 890D[1C2F0100]          	mov [blockende],ecx
  1068 0000149D F605[A0380100]12        	test byte [mode],EM | NE
  1069 000014A4 740B                    	jz NO_EM03
  1070 000014A6 890D[74380100]          	mov [EmaMark],ecx
  1071 000014AC E89CFFFFFF              	call ShowBl0			;i.e. "mov byte [showblock],0"
  1072 000014B1 803D[A0380100]04        NO_EM03:cmp byte [mode],PI
  1073 000014B8 7502                    	jnz CtrlKREnd
  1074 000014BA 89CF                    	mov edi,ecx			;in PI: cursor at end of read file
  1075 000014BC E9950A0000              CtrlKREnd:jmp RestKursPos
  1076                                  ;-------
  1077 000014C1 E807090000              KeyCtrlKW:call CheckBlock
  1078 000014C6 7263                    	jc CtrlKSEnd	   		;no action
  1079 000014C8 E8A10E0000              	call SaveBlock
  1080 000014CD EBED                    	jmp short CtrlKREnd
  1081                                  ;-------
  1082 000014CF 803D[0C2F0100]20        KeyEmaCtrlXF:cmp byte [changed],UNCHANGED
  1083 000014D6 741A                    	jz KECF
  1084 000014D8 BE[A02F0000]            	mov esi,asksave2
  1085 000014DD E83A0F0000              	call DE1
  1086 000014E2 E86F0A0000              	call RestKursPos
  1087 000014E7 E880120000              	call CheckUserAbort
  1088 000014EC 743D                    	jz CtrlKSEnd
  1089 000014EE 24DF                    	and al,0dfh
  1090 000014F0 3C4E                    	cmp al,'N'			;N for request NOT SAVE changes
  1091 000014F2 743F                    KECF:	jz KCKD2
  1092 000014F4 EB36                    	jmp short KeyCtrlKD
  1093                                  ;-------
  1094 000014F6 E82D100000              KeyEmaCtrlXW:call GetBlockName
  1095 000014FB 722E                    	jc CtrlKSEnd
  1096 000014FD BE[C8310100]            	mov esi,blockpath
  1097 00001502 FC                      XW1:	cld
  1098                                  	PUSH_ALL
  1098 00001503 60                  <1>  pusha
  1099 00001504 BF[C82F0100]            	mov edi,filepath
  1100 00001509 AC                      XW0:	lodsb
  1101 0000150A AA                      	stosb				;copy to blockpath to filepath
  1102 0000150B 08C0                    	or al,al
  1103 0000150D 75FA                    	jne XW0
  1104 0000150F AA                      	stosb
  1105                                  	POP_ALL
  1105 00001510 61                  <1>  popa
  1106 00001511 E82CF9FFFF              KeyCtrlKS0:call SetChg			;i.e. "mov byte [changed],CHANGED"  to save it really
  1107                                  ;-------
  1108 00001516 E89C0D0000              KeyCtrlKS:call SaveFile
  1109 0000151B 9C                      	pushf				;(called by ^kd)
  1110 0000151C E8350A0000              	call RestKursPos
  1111 00001521 9D                      	popf
  1112 00001522 7207                    	jc CtrlKSEnd
  1113 00001524 C605[0C2F0100]20        Unchg:	mov byte [changed],UNCHANGED
  1114 0000152B C3                      CtrlKSEnd:ret
  1115                                  ;-------
  1116 0000152C E8E5FFFFFF              KeyCtrlKD:call KeyCtrlKS
  1117 00001531 7243                    	jc KeyKXend
  1118 00001533 C605[202F0100]02        KCKD2:	mov byte [endeedit],2
  1119 0000153A C3                      	ret
  1120                                  ;-------
  1121 0000153B 803D[0C2F0100]20        KeyCtrlKQ:cmp byte [changed],UNCHANGED
  1122 00001542 742C                    	jz KCKXend
  1123 00001544 BE[962F0000]            	mov esi,asksave
  1124 00001549 E8CE0E0000              	call DE1
  1125 0000154E E8030A0000              	call RestKursPos
  1126 00001553 E814120000              	call CheckUserAbort
  1127 00001558 74D1                    	jz CtrlKSEnd
  1128 0000155A 24DF                    	and al,0dfh
  1129 0000155C 3C4E                    	cmp al,'N'			;N for request NOT SAVE changes
  1130 0000155E 7410                    	jz KCKXend
  1131 00001560 3C4C                    	cmp al,'L'			;L for SAVE and LOAD a new file
  1132 00001562 7505                    	jnz KeyCtrlKX
  1133 00001564 E807000000              	call KCKXend
  1134 00001569 E8A8FFFFFF              KeyCtrlKX:call KeyCtrlKS
  1135 0000156E 72BB                    	jc CtrlKSEnd
  1136 00001570 FE05[202F0100]          KCKXend:inc byte [endeedit]
  1137 00001576 C3                      KeyKXend:ret
  1138                                  ;----------------------------------------------------------------------
  1139                                  ;
  1140                                  ; some minimal limited vi specials in command mode
  1141                                  ;
  1142 00001577 8D7102                  KeyVICmdW:lea esi,[ecx+2]
  1143 0000157A 803E20                  	cmp byte [esi],SPACECHAR
  1144 0000157D 7783                    	ja XW1
  1145 0000157F C3                      	ret
  1146                                  ;-------
  1147 00001580 8B01                    VINoLineCmd:mov eax,[ecx]
  1148 00001582 663D7721                	cmp ax,'w!'			;save
  1149 00001586 7489                    	je KeyCtrlKS0
  1150 00001588 6683F877                	cmp ax,'w'			;save
  1151 0000158C 7488                    	je KeyCtrlKS
  1152 0000158E 6683F878                	cmp ax,'x'                      ;save and exit
  1153 00001592 74D5                    	je KeyCtrlKX
  1154 00001594 6683F824                	cmp ax,'$'			;No line number, but EOF
  1155 00001598 7507                    	jne KVI_KX0
  1156                                  ;-------
  1157 0000159A 89EF                    KeyCtrlQC:mov edi,ebp
  1158 0000159C E9D1FCFFFF              	jmp CQFNum
  1159                                  ;-------
  1160 000015A1 663D7771                KVI_KX0:cmp ax,'wq'
  1161 000015A5 74C2                    KVI_KX:	je KeyCtrlKX
  1162 000015A7 663D7720                	cmp ax,'w '			;save as ... and continue
  1163 000015AB 74CA                    	je KeyVICmdW
  1164 000015AD 6683F871                	cmp ax,'q'
  1165 000015B1 7488                    	je KeyCtrlKQ
  1166 000015B3 663D7121                	cmp ax,'q!'
  1167 000015B7 74B7                    	je KCKXend
  1168 000015B9 663D6520                	cmp ax,'e '			;edit another ..
  1169 000015BD 0F84540C0000            	je near KeyVICmdE
  1170 000015C3 6683F868                	cmp ax,'h'
  1171 000015C7 0F84CC080000            	je near KeyHelp
  1172                                  %ifdef UTF8RTS
  1173                                  	cmp ax,'u'
  1174                                  	je near KeyUTF8switch
  1175                                  %endif
  1176                                  %ifndef USE_PIPE
  1177                                  	ret
  1178                                  %else
  1179 000015CD E97A130000              	jmp KeyVICmdtemp
  1180                                  %endif
  1181                                  ;-------
  1182 000015D2 E8F2060000              KeyVICmdZ:call ReadOneChar
  1183 000015D7 3C5A                    	cmp al,'Z'
  1184 000015D9 74CA                    	je KVI_KX
  1185 000015DB C3                      	ret
  1186                                  ;-------
  1187 000015DC E831FAFFFF              KeyVI1Char:call KeyHome
  1188 000015E1 803F20                  	cmp byte [edi],SPACECHAR
  1189 000015E4 7711                    	ja KFC2
  1190 000015E6 803F0A                  KFC1:	cmp byte [edi],NEWLINE
  1191 000015E9 740C                    	jz KFC2
  1192 000015EB 47                      	inc edi
  1193 000015EC 803F20                  	cmp byte [edi],SPACECHAR
  1194 000015EF 76F5                    	jbe KFC1
  1195 000015F1 807FFF20                	cmp byte [edi-1],SPACECHAR
  1196 000015F5 77EF                    	ja KFC1
  1197 000015F7 C3                      KFC2:	ret
  1198                                  ;-------
  1199 000015F8 E815FAFFFF              KeyVICmdS:call KeyHome
  1200 000015FD E857FDFFFF              	call KeyEmaCtrlK		;not quite ok in 'P'/'p' commands
  1201 00001602 C605[88380100]01        	mov byte [VInolinebased],1
  1202 00001609 EB4B                    	jmp short KeyVICmdI
  1203 0000160B E8B9060000              KeyVICmdd:call ReadOneChar
  1204 00001610 3C77                    	cmp al,'w'			;word (greetings to ma_ko)
  1205 00001612 C605[88380100]01        	mov byte [VInolinebased],1
  1206 00001619 0F84FAFCFFFF            	je near KeyCmddw
  1207 0000161F 3C64                    	cmp al,'d'			;"delete"
  1208 00001621 C605[88380100]00        	mov byte [VInolinebased],0
  1209 00001628 0F84F2FCFFFF            	je near KeyCtrlY
  1210 0000162E 3C27                    	cmp al,"'"			;only line based mode supported
  1211 00001630 75C5                    	jne KFC2
  1212 00001632 E892060000              	call ReadOneChar
  1213 00001637 3C61                    	cmp al,'a'			;" d'a "    (only marker "a" supported)
  1214 00001639 75BC                    	jne KFC2
  1215 0000163B 8B0D[182F0100]          	mov ecx,[blockbegin]		;don't go further if no mark set
  1216 00001641 E3B4                    	jecxz KFC2
  1217 00001643 E8B4F9FFFF              	call VIsetMarker		;an helper for adjusting begin/end marker line
  1218 00001648 E836FDFFFF              callKECW:call KeyEmaCtrlW
  1219 0000164D 31C0                    	xor eax,eax
  1220 0000164F A3[182F0100]            	mov [blockbegin],eax		;after delete mark is no more set
  1221 00001654 EB3A                    	jmp short JmpCQFn
  1222                                  ;-------
  1223 00001656 E881FFFFFF              KeyVICmdI:call KeyVI1Char
  1224 0000165B EB71                    	jmp short KeyVImode0
  1225                                  ;-------
  1226 0000165D 8B0D[6C380100]          KeyVICmdp:mov ecx,[EmaKiSize]		;check this before call KeyEmaCtrlY
  1227                                  jmpKFC2:
  1228                                  %ifdef YASM
  1229                                  	or ecx,ecx
  1230                                  	jz KFC2
  1231                                  %else
  1232 00001663 E392                    	jecxz KFC2
  1233                                  %endif
  1234 00001665 803D[88380100]01        	cmp byte [VInolinebased],1
  1235 0000166C 7472                    	jz KeyVICmdpnLB
  1236 0000166E E8E7F8FFFF              	call OvrRet			;ugly
  1237 00001673 8B0D[6C380100]          KeyVICmdP:mov ecx,[EmaKiSize]		;check this before call KeyEmaCtrlY
  1238 00001679 E3E8                    	jecxz jmpKFC2
  1239 0000167B 803D[88380100]01        	cmp byte [VInolinebased],1
  1240 00001682 7461                    	jz KeyVICmdPnLB
  1241 00001684 E889F9FFFF              	call KeyHome
  1242 00001689 57                      KeyVICP2:push edi
  1243 0000168A E89C0A0000              	call KeyEmaCtrlY
  1244 0000168F 5F                      	pop edi
  1245 00001690 E9DDFBFFFF              JmpCQFn:jmp CQFNum
  1246                                  ;-------
  1247 00001695 C605[582F0100]FE        KeyVICmdR:mov byte [insstat],254	;i.e "not 1"
  1248 0000169C EB30                    	jmp short KeyVImode0
  1249 0000169E E86FF9FFFF              KeyVICmdO:call KeyHome
  1250 000016A3 E869F8FFFF              	call KeyRet
  1251 000016A8 E8C7F8FFFF              	call KeyUp
  1252 000016AD EB1F                    	jmp short KeyVImode0
  1253 000016AF E867000000              KeyVICmdo:call KeyEnd
  1254 000016B4 E858F8FFFF              	call KeyRet
  1255 000016B9 EB13                    	jmp short KeyVImode0
  1256 000016BB E85B000000              KeyVICmdA:call KeyEnd
  1257 000016C0 EB0C                    	jmp short KeyVImode0
  1258 000016C2 E8F9F9FFFF              KeyVIcmda:call KeyRight
  1259 000016C7 C605[582F0100]01        KeyVIcmdi:mov byte [insstat],1
  1260 000016CE 6A00                    KeyVImode0:push byte 0
  1261 000016D0 EB53                    	jmp short KVim1
  1262 000016D2 E882FCFFFF              KeyVICmdC:call KeyEmaCtrlK
  1263 000016D7 C605[88380100]01        	mov byte [VInolinebased],1
  1264 000016DE EBEE                    	jmp short KeyVImode0
  1265                                  ;-------
  1266 000016E0 E8DBF9FFFF              KeyVICmdpnLB:call KeyRight		;not_Line_Based mode
  1267 000016E5 E89FFFFFFF              KeyVICmdPnLB:call KeyVICP2
  1268 000016EA 033D[6C380100]          	add edi,[EmaKiSize]		;Wed Apr 10 18:11:42 MEST 2002
  1269                                  ;------- cont
  1270                                  KeyLeft:
  1271                                  %ifdef UTF8
  1272                                  %ifdef UTF8RTSx_wont			;see KeyRight comment
  1273                                  	cmp byte [isUTF8],0
  1274                                  	je noUTF_F
  1275                                  %endif
  1276 000016F0 4F                      	dec edi
  1277 000016F1 8A07                    	mov al,byte [edi]		;check for UTF byte 2,3,4,..
  1278 000016F3 24C0                    	and al,0c0h
  1279 000016F5 3C80                    	cmp al,080h
  1280 000016F7 74F7                    	je KeyLeft
  1281 000016F9 47                      	inc edi
  1282                                  noUTF_F:
  1283                                  %endif
  1284 000016FA 807FFF0A                	cmp byte [edi-1],NEWLINE
  1285 000016FE 7519                    	jnz KeyLNoMargin
  1286 00001700 81FF[ED3C0100]          	cmp edi,sot			;i.e. CheckBof
  1287 00001706 7412                    	je KeyLeftEnd
  1288 00001708 E85A000000              	call IsViMode
  1289 0000170D 740B                    	je KeyLeftEnd			;no more line wrap around in vi mode
  1290 0000170F E829060000              	call CheckENum			;Sun Feb 20 2005
  1291 00001714 E8D6070000              	call GoUp
  1292 00001719 4F                      KeyLNoMargin:dec edi
  1293                                  %ifdef W32LF
  1294                                  	cmp byte [edi],RETURN		;do not stay at 0dh
  1295                                  	jnz KeyLeftEnd
  1296                                  	dec edi
  1297                                  %endif
  1298 0000171A C3                      KeyLeftEnd:ret
  1299                                  ;-------
  1300 0000171B E800070000              KeyEnd:	call CountToLineEnd
  1301 00001720 01C7                    	add edi,eax			;points to a LINEFEED (0ah) char
  1302 00001722 C3                      	ret
  1303                                  ;-------
  1304 00001723 6A01                    KeyVImode1:push byte 1
  1305 00001725 58                      KVim1:	pop eax
  1306 00001726 A2[80380100]            	mov byte [VICmdMode],al
  1307 0000172B C3                      	ret
  1308                                  ;-------
  1309 0000172C E8C3020000              KeyVIex:call InputStringWithMessage0
  1310 00001731 9C                      	pushf
  1311 00001732 E81F080000              	call RestKursPos
  1312 00001737 9D                      	popf
  1313 00001738 723C                    	jc Kviex
  1314 0000173A BE[C8350100]            	mov esi,optbuffer
  1315 0000173F 31D2                    	xor edx,edx
  1316 00001741 89C1                    	mov ecx,eax			;do not use xchg here
  1317 00001743 E331                    	jecxz Kviex
  1318                                  ;-------
  1319 00001745 56                      	push esi			;save optbuffer
  1320 00001746 FC                      	cld
  1321 00001747 AC                      CheckDig:lodsb				;check for line number entered
  1322 00001748 3C30                    	cmp al,'0'
  1323 0000174A 7301                    	jnb CD1
  1324 0000174C 42                      	inc edx
  1325 0000174D 3C3A                    CD1:	cmp al,':'
  1326 0000174F 7201                    	jb CD2
  1327 00001751 42                      	inc edx
  1328 00001752 E2F3                    CD2:	loop CheckDig
  1329 00001754 59                      	pop ecx				;rest optbuffer
  1330                                  ;-------
  1331 00001755 09D2                    	or edx,edx
  1332 00001757 0F8523FEFFFF            	jnz near VINoLineCmd
  1333 0000175D E88E0F0000              	call GetAsciiToInteger
  1334 00001762 E935FBFFFF              	jmp ViSpecial			;due short jumps there
  1335                                  ;-------
  1336 00001767 803D[A0380100]08        IsViMode:cmp byte [mode],VI
  1337 0000176E C3                      	ret
  1338 0000176F 803D[A0380100]02        IsEmMode:cmp byte [mode],EM
  1339 00001776 C3                      Kviex:	ret
  1340                                  ;---------------------------------------------------------------------
  1341                                  ;
  1342                                  ; the general PAGE DISPLAY function: called after any pressed key
  1343                                  ;
  1344                                  ; side effect: sets 'columne' for RestoreStatusLine function (displays column)
  1345                                  ; variable kurspos: for placing the cursor at new position
  1346                                  ; register bh counts lines
  1347                                  ; register bl counts columns visible on screen (w/o left scrolled)
  1348                                  ; register edx counts columns in text lines
  1349                                  ; register ecx screen line counter and helper for rep stos
  1350                                  ; register esi text index
  1351                                  ; register edi screen line buffer index
  1352                                  ;
  1353 00001777 F605[A0380100]16        DispNewScreen:test byte [mode], EM | PI | NE
  1354 0000177E 7422                    	jz NoEmBlock
  1355 00001780 8B0D[302F0100]          	mov ecx,[showblock]		;transfering Emacs's mark/point into....
  1356 00001786 E31A                    	jecxz NoEmBlock			;....WS's block display system
  1357 00001788 8B0D[74380100]          	mov ecx,[EmaMark]
  1358 0000178E E312                    	jecxz NoEmBlock
  1359 00001790 89F8                    	mov eax,edi
  1360 00001792 39C1                    	cmp ecx,eax
  1361 00001794 7201                    	jb EmBlock
  1362 00001796 91                      	xchg eax,ecx
  1363 00001797 890D[182F0100]          EmBlock:mov [blockbegin],ecx
  1364 0000179D A3[1C2F0100]            	mov [blockende ],eax
  1365                                  ;-------
  1366 000017A2 E894010000              NoEmBlock:call GetEditScreenSize	;check changed tty size
  1367 000017A7 31C0                    	xor eax,eax
  1368 000017A9 A2[502F0100]            	mov byte[isbold],al
  1369 000017AE A2[542F0100]            	mov byte[inverse],al
  1370 000017B3 A3[F82E0100]            	mov [zloffst],eax
  1371 000017B8 A3[F42E0100]            	mov [columne],eax
  1372 000017BD 893D[FC2E0100]          	mov [fileptr],edi		;for seeking current cursor pos
  1373 000017C3 57                      	push edi			;&&**##
  1374 000017C4 E85F060000              	call CountColToLineBeginVis	;i.e. expanding TABs
  1375 000017C9 8B1D[F02E0100]          	mov ebx,[columns]
  1376 000017CF 8D5BFC                  	lea ebx,[ebx-4]			;03 Jun 2001
  1377 000017D2 39D8                    	cmp eax,ebx
  1378 000017D4 7208                    	jb short DispShortLine
  1379 000017D6 29D8                    	sub eax,ebx
  1380 000017D8 40                      	inc eax
  1381 000017D9 A3[F82E0100]            	mov [zloffst],eax
  1382 000017DE E862050000              DispShortLine:call LookPgBegin 		;go on 1st char upper left on screen
  1383 000017E3 89FE                    	mov esi,edi			;esi for reading chars from text
  1384 000017E5 8B0D[EC2E0100]          	mov ecx,[lines]
  1385                                  %ifndef YASM
  1386 000017EB E389                    	jecxz Kviex
  1387                                  %else
  1388                                  	or ecx,ecx
  1389                                  	jz near Kviex
  1390                                  %endif
  1391 000017ED FC                      	cld
  1392 000017EE B7FF                    	mov bh,-1			;first line
  1393 000017F0 FEC7                    DispNewLine:inc bh			;new line
  1394 000017F2 BF[34370100]            	mov edi,screenline		;line display buffer
  1395 000017F7 31D2                    	xor edx,edx			;reset char counter
  1396 000017F9 B300                    	mov bl,0 			;reset screen column to 0
  1397                                  %ifdef LESSWRITEOPS
  1398 000017FB E80C010000              	call SetColor2			;set initial character color per each line
  1399                                  %endif
  1400                                  DispCharLoop:
  1401 00001800 3B35[FC2E0100]          	cmp esi,[fileptr]		;display char @ cursor postion ?
  1402 00001806 751C                    	jnz DispCharL1
  1403 00001808 803D[082F0100]00        	cmp byte[tabcnt],0
  1404 0000180F 7513                    	jnz DispCharL1
  1405 00001811 891D[002F0100]          	mov [kurspos],ebx
  1406 00001817 A1[F82E0100]            	mov eax,[zloffst]		;chars scrolled left hidden
  1407 0000181C 00D8                    	add al,bl
  1408 0000181E 0105[F42E0100]          	add [columne],eax
  1409                                  %ifdef CURSORMGNT
  1410                                  	stc
  1411                                  	call SetInverseStatus
  1412                                  	jnc DispEndLine
  1413                                  %endif
  1414 00001824 E8B8000000              DispCharL1:call SetColor		;set color if neccessary
  1415                                  ;-------
  1416 00001829 39EE                    DispEndLine:cmp esi,ebp
  1417 0000182B 776D                    	ja FillLine			;we have passed EOF, so now fill rest of screen
  1418 0000182D 803D[082F0100]00        	cmp byte[tabcnt],0
  1419 00001834 7408                    	jz ELZ
  1420 00001836 FE0D[082F0100]          	dec byte[tabcnt]
  1421 0000183C EB19                    	jmp short ELZ2
  1422 0000183E 39EE                    ELZ:	cmp esi,ebp
  1423 00001840 7503                    	jnz ELZ6
  1424 00001842 46                      	inc esi				;set esi>ebp will later trigger  "ja FillLine"
  1425 00001843 EB12                    	jmp short ELZ2
  1426 00001845 AC                      ELZ6:	lodsb
  1427 00001846 3C09                    	cmp al,TABCHAR
  1428 00001848 750F                    	jnz ELZ3
  1429 0000184A E8DB0E0000              	call SpacesForTab		;ah = space_up_to_next_tab location
  1430 0000184F FECC                    	dec ah				;count out the tab char itself
  1431 00001851 8825[082F0100]          	mov byte[tabcnt],ah
  1432 00001857 B020                    ELZ2:	mov al,SPACECHAR
  1433 00001859 3C0A                    ELZ3:	cmp al,NEWLINE
  1434 0000185B 743D                    	jz FillLine
  1435                                  %ifdef W32LF
  1436                                  	cmp al,RETURN
  1437                                  	jz ELZ5				;keep 0dh "invisible"
  1438                                  %endif
  1439 0000185D 3C20                    	cmp al,SPACECHAR
  1440 0000185F 7302                    	jae ELZ9			;simply ignore chars like carriage_return etc.
  1441 00001861 B02E                    ELZ99:	mov al,'.'
  1442                                  ELZ9:	
  1443                                  %ifndef W32
  1444 00001863 3C7F                    	cmp al,7fh
  1445 00001865 7202                    	jb ELZ7
  1446 00001867 74F8                    	je ELZ99
  1447                                  %ifndef UTF8
  1448                                  	mov al,'.'
  1449                                  %else
  1450                                  %ifdef UTF8RTS
  1451                                  	cmp byte [isUTF8],0
  1452                                  	jne YXCVB
  1453                                  	mov al,'.'
  1454                                  YXCVB:
  1455                                  %endif
  1456                                  %endif
  1457                                  ELZ7:	
  1458                                  %endif
  1459 00001869 3A1D[F02E0100]          	cmp bl,byte [columns]		;screen width
  1460 0000186F 73B8                    	jae DispEndLine			;continue reading line until end
  1461                                  ;-------
  1462                                  %ifdef UTF8
  1463 00001871 B400                    	mov ah,0
  1464                                  %ifdef UTF8RTS
  1465                                  	cmp byte [isUTF8],0
  1466                                  	je CountByte
  1467                                  %endif
  1468 00001873 50                      	push eax
  1469 00001874 24C0                    	and al,0c0h
  1470 00001876 3C80                    	cmp al,080h
  1471 00001878 58                      	pop eax
  1472 00001879 740F                    	jz UByte234			;MSB 10...... =do not count 
  1473 0000187B 720A                    	jb CountByte			;MSB 01...... 00...... count valid 7bit ASCII
  1474 0000187D 50                      	push eax
  1475 0000187E 8A06                    	mov al,byte [esi]		;check next byte for vaild UTF8 follower byte
  1476 00001880 24C0                    	and al,0C0h
  1477 00001882 3C80                    	cmp al,80h			;is UTF8 byte 2,3,4,..  ?
  1478 00001884 58                      	pop eax
  1479 00001885 7503                    	jnz UByte234			;no do not count wrong UTF8 starter byte
  1480 00001887 42                      CountByte:inc edx
  1481 00001888 FEC4                    	inc ah				;1
  1482 0000188A 3B15[F82E0100]          UByte234:cmp edx,[zloffst]
  1483 00001890 7603                    	jbe ELZ5			;loaded new char (but won't display)
  1484 00001892 AA                      	stosB
  1485 00001893 00E3                    	add bl,ah			;i.e. add 0 or 1 to curser column position counter
  1486                                  %else
  1487                                  	inc edx
  1488                                  	cmp edx,[zloffst]
  1489                                  	jbe ELZ5			;loaded new char (but won't display)
  1490                                  	stosB
  1491                                  	inc bl
  1492                                  %endif
  1493                                  ;-------
  1494                                  %ifdef CURSORMGNT
  1495                                  	clc
  1496                                  	call SetInverseStatus
  1497                                  %endif
  1498 00001895 E966FFFFFF              ELZ5:	jmp DispCharLoop
  1499                                  ;-------
  1500 0000189A 51                      FillLine:push ecx			;continue rest of line
  1501 0000189B 8B0D[F02E0100]          	mov ecx,[columns]		;width
  1502 000018A1 28D9                    	sub cl,bl
  1503 000018A3 B020                    	mov al,SPACECHAR		;fill with blanks
  1504 000018A5 E30F                    	jecxz FillLine2
  1505 000018A7 803D[542F0100]01        	cmp byte[inverse],1		;special cursor attribute?
  1506 000018AE 7504                    	jnz FillLine1
  1507 000018B0 AA                      	stosB				;only 1st char with special attribute
  1508                                  %ifdef CURSORMGNT
  1509                                  	clc
  1510                                  	call SetInverseStatus
  1511                                  %endif
  1512 000018B1 49                      	dec ecx				;one char less
  1513 000018B2 7402                    	jz FillLine2
  1514                                  FillLine1:
  1515 000018B4 F3AA                    	rep stosB			;store the rest blanks
  1516 000018B6 59                      FillLine2:pop ecx
  1517 000018B7 C60700                  	mov byte[edi],0
  1518 000018BA E8B4000000              	call ScreenLineShow
  1519 000018BF 49                      	dec ecx
  1520 000018C0 0F852AFFFFFF            	jnz near DispNewLine
  1521 000018C6 5F                      	pop edi				;&&**##	;OLD: mov edi,[fileptr]	;=restore text pointer
  1522 000018C7 E98A060000              	jmp RestKursPos
  1523                                  ;----------------------------------------------------------------------
  1524                                  ; three helper subroutines called by DispNewScreen
  1525                                  ; dealing ESC sequences for character attributes
  1526                                  ; 
  1527                                  %ifdef CURSORMGNT
  1528                                  SetInverseStatus:
  1529                                  	push ecx		;returns zero flag
  1530                                  	push esi
  1531                                  	jnc SIS1
  1532                                  	cmp byte [insstat],1
  1533                                  	stc
  1534                                  	jnz SIS4
  1535                                  	mov byte[inverse],1
  1536                                  	mov esi,reversevideoX
  1537                                  	add esi,[revvoff]		;switch between esc seq for linux or Xterm
  1538                                  	jmp short SIS2
  1539                                  SIS1:	cmp byte[inverse],1
  1540                                  	jnz SIS3
  1541                                  	mov byte[inverse],0
  1542                                  ;-------continued...
  1543                                  %endif
  1544                                  ;------
  1545                                  ; next presented in 2 versions: one for Win32, one for Terminals
  1546                                  ;
  1547                                  %ifdef W32 ;------------- this can't be done via ESC seq ----------------
  1548                                  SIS6:	mov byte[isbold],0
  1549                                  SIS5:	mov eax,DARKWHITE
  1550                                  SIS2:	mov ecx,edi
  1551                                  	sub ecx,screenline
  1552                                  	mov edx,ecx			;current pos in columne
  1553                                  	shl ecx,1
  1554                                  	mov edi,attribline
  1555                                  	add edi,ecx
  1556                                  	mov ecx,[columns]
  1557                                  	sub ecx,edx			;only current pos up to line end
  1558                                  	rep stosw
  1559                                  SIS3:	clc
  1560                                  SIS4:	POP_ALL
  1561                                  	ret
  1562                                  SetColor:				;expects cy flag:bold /  nc:normal
  1563                                  	PUSH_ALL
  1564                                  	call IsShowBlock
  1565                                  	jnc SCEsc1
  1566                                  	cmp byte [isbold],1		;never set bold if it is already bold
  1567                                  	jz SIS4
  1568                                  	mov byte [isbold],1
  1569                                  SCEsc2:	mov eax,WHITE
  1570                                  	jmp short SIS2
  1571                                  SCEsc1:	cmp byte [isbold],0		;ditto
  1572                                  	jz SIS4
  1573                                  	jmp short SIS6
  1574                                  ;-------
  1575                                  SetColor2:PUSH_ALL
  1576                                  	call IsShowBlock
  1577                                  	jnc SIS5
  1578                                  	jmp short SCEsc2
  1579                                  %else ;---------------------- TERMINAL part -----------------------------
  1580 000018CC C605[502F0100]00        SIS6:	mov byte[isbold],0
  1581 000018D3 BE[C8320000]            SIS5:	mov esi,bold0
  1582 000018D8 6A04                    SIS2:	push byte boldlen
  1583 000018DA 59                      	pop ecx
  1584 000018DB F3A4                    	rep movsb
  1585 000018DD F8                      SIS3:	clc
  1586 000018DE 5E                      SIS4:	pop esi
  1587 000018DF 59                      	pop ecx
  1588 000018E0 C3                      	ret
  1589                                  ;-------
  1590 000018E1 51                      SetColor:push ecx			;expects cy flag:bold /  nc:normal
  1591 000018E2 56                      	push esi
  1592 000018E3 E82F000000              	call IsShowBlock
  1593 000018E8 7317                    	jnc SCEsc1
  1594 000018EA 803D[502F0100]01        	cmp byte [isbold],1		;never set bold if it is already bold
  1595 000018F1 74EB                    	jz SIS4
  1596 000018F3 C605[502F0100]01        	mov byte [isbold],1
  1597 000018FA BE[D6320000]            SCEsc2:	mov esi,bold1
  1598 000018FF EBD7                    	jmp short SIS2
  1599 00001901 803D[502F0100]00        SCEsc1:	cmp byte [isbold],0		;ditto
  1600 00001908 74D4                    	jz SIS4
  1601 0000190A EBC0                    	jmp short SIS6
  1602                                  ;-------
  1603                                  %ifdef LESSWRITEOPS
  1604                                  SetColor2:
  1605 0000190C 51                      	push ecx
  1606 0000190D 56                      	push esi
  1607 0000190E E804000000              	call IsShowBlock
  1608 00001913 73BE                    	jnc SIS5
  1609 00001915 EBE3                    	jmp short SCEsc2
  1610                                  %endif
  1611                                  %endif ;----------------- end of double part -----------------------------
  1612                                  ;
  1613                                  ;-------
  1614                                  ; a little helper for SetColor* functions
  1615                                  ;
  1616 00001917 803D[302F0100]00        IsShowBlock:cmp byte [showblock],0
  1617 0000191E 7419                    	je SBlock
  1618 00001920 833D[182F0100]00        	cmp dword [blockbegin],0
  1619 00001927 7410                    	je SBlock
  1620 00001929 3935[182F0100]          	cmp [blockbegin],esi
  1621 0000192F 7708                    	ja SBlock
  1622 00001931 3B35[1C2F0100]          	cmp esi,[blockende]
  1623 00001937 7201                    	jb SB_ret
  1624 00001939 F8                      SBlock:	clc
  1625 0000193A C3                      SB_ret:	ret
  1626                                  ;-------
  1627                                  ; this helper for DispNewScreen checks screen size before writing on screen
  1628                                  ; FIXME: adjusting edit screen resize works with xterm, but not with SVGATextMode
  1629                                  ;
  1630                                  GetEditScreenSize:
  1631                                  %ifdef W32
  1632                                  	push dword csbi
  1633                                  	push dword [hout]
  1634                                  	call GetConsoleScreenBufferInfo
  1635                                  	or eax,eax
  1636                                  	mov eax,[csbi]
  1637                                  	jnz noerr
  1638                                  	mov eax,0x00190050		;i.e. (80<<16)+24  (assume 80x25)
  1639                                  noerr:	mov byte [columns],al
  1640                                  	shr eax,16
  1641                                  	dec eax
  1642                                  	mov byte [lines],al		;columns > 255 are ignored...
  1643                                  	ret
  1644                                  %else
  1645 0000193B B913540000              	mov ecx,TERMIOS_WSIZE
  1646 00001940 BA[C82E0000]            	mov edx,winsize
  1647 00001945 E83F0F0000              	call IOctlTerminal
  1648 0000194A 8B02                    	mov eax,[edx]			;each 16 bit lines,columns
  1649 0000194C 3DFFFF0000              	cmp eax,0x0000FFFF		;some give no columns info..?
  1650 00001951 7204                    	jb iserr
  1651 00001953 09C0                     	or eax,eax
  1652 00001955 7505                     	jnz noerr
  1653 00001957 B818005000              iserr: 	mov eax,0x00500018		;i.e. (80<<16)+24  (assume 80x24)
  1654 0000195C 48                      noerr:	dec eax				;without status line ('dec al' are 2 byte!)
  1655 0000195D A2[EC2E0100]            	mov byte [lines],al
  1656 00001962 C1E810                  	shr eax,16
  1657 00001965 A2[F02E0100]            	mov byte [columns],al		;columns > 255 are ignored...
  1658 0000196A C3                      	ret
  1659                                  %endif
  1660                                  ;----------------------------------------------------------------------
  1661                                  ;
  1662                                  ; LOWER LEVEL screen acces function (main +2 helpers)
  1663                                  ; this function does write the line buffer to screen i.e. terminal
  1664                                  ;
  1665                                  ; at first 2 special entry points:
  1666 0000196B 890D[34370100]          WriteTwo:mov [screenline],ecx
  1667                                  StatusLineShow:
  1668                                  %ifdef W32
  1669                                  	push edi
  1670                                  	mov ecx,[columns]
  1671                                  	shr ecx,1
  1672                                  	mov eax,YELLOW_BLUE_TWICE
  1673                                  	mov edi,attribline
  1674                                  	rep stosd
  1675                                  	pop edi
  1676                                  	mov edx,[kurspos2]
  1677                                  	call sys_writeKP		;set cursor pos before reading chars
  1678                                  %endif
  1679 00001971 31C9                    	xor ecx,ecx			;0 for bottom line
  1680                                  ;-------
  1681                                  ScreenLineShow:PUSH_ALL			;expecting in ecx screen line counted from 0
  1681                              <1> ScreenLineShow:
  1681 00001973 60                  <1>  pusha
  1682                                  %ifdef LESSWRITEOPS
  1683                                  %ifdef W32				;screen attrib caching
  1684                                  	mov eax,[columns]
  1685                                  	mul ecx				;setting edx to 0
  1686                                  	mov ebx,edx			;flag
  1687                                  	lea edi,[eax+attribbuffer]
  1688                                  	cld
  1689                                  	mov esi,attribline
  1690                                  Xsl3:	lodsw
  1691                                  	cmp edi,attribbuffer_end	;never read/write beyond buffer
  1692                                  	jnb Xsl5
  1693                                  	cmp ax,[edi]
  1694                                  	jz Xsl4
  1695                                  	mov [edi],ax
  1696                                  Xsl5:	inc ebx				;set flag whether line need redrawing
  1697                                  Xsl4:	inc edi
  1698                                  	inc edi
  1699                                  	or al,al
  1700                                  	jnz Xsl3
  1701                                  %else
  1702 00001974 31DB                    	xor ebx,ebx			;flag
  1703                                  %endif
  1704                                  ;-------
  1705 00001976 A1[F02E0100]            	mov eax,[columns]
  1706 0000197B 8D4020                  	lea eax,[eax+32]		;estimated max ESC sequences extra bytes (i.e. boldlen*X) (BTW add eax,32 islonger)
  1707 0000197E F7E1                    	mul ecx				;setting edx to 0
  1708 00001980 8DB8[00000000]          	lea edi,[eax+screenbuffer]
  1709                                  %else
  1710                                  	xor edx,edx			;counter
  1711                                  %endif
  1712 00001986 FC                      	cld
  1713 00001987 BE[34370100]            	mov esi,screenline
  1714 0000198C AC                      sl3:	lodsb
  1715 0000198D 42                      	inc edx				;count message length to write
  1716                                  %ifdef LESSWRITEOPS
  1717 0000198E 81FF[802E0000]          	cmp edi,screenbuffer_end	;never read/write beyond buffer
  1718 00001994 7306                    	jnb sl5
  1719 00001996 3A07                    	cmp al,[edi]
  1720 00001998 7403                    	jz sl4
  1721 0000199A 8807                    	mov [edi],al
  1722 0000199C 43                      sl5:	inc ebx				;set flag whether line need redrawing
  1723 0000199D 47                      sl4:	inc edi
  1724                                  %endif
  1725 0000199E 08C0                    	or al,al
  1726 000019A0 75EA                    	jnz sl3
  1727 000019A2 4A                      	dec edx				;one too much
  1728                                  %ifdef LESSWRITEOPS
  1729 000019A3 09DB                    	or ebx,ebx			;redraw ?
  1730 000019A5 743C                    	jz NoWrite
  1731                                  %endif
  1732 000019A7 52                      	push edx
  1733 000019A8 31D2                    	xor edx,edx
  1734 000019AA 8A35[EC2E0100]          	mov dh,byte [lines]
  1735 000019B0 28CE                    	sub dh,cl
  1736                                  %ifdef W32_EXTENDED_IO
  1737                                  	pop ebx				;len
  1738                                  	shl edx,8
  1739                                  	and edx,00ff0000h		;only line# (column is always 0)
  1740                                  	push edx			;cursor data
  1741                                  ;-------
  1742                                  	push dword w32result
  1743                                  	push edx			;cursor
  1744                                  	push ebx			;length
  1745                                  	push dword screenline
  1746                                  	push dword [hout]
  1747                                  	call WriteConsoleOutputCharacterA
  1748                                  ;-------
  1749                                  	pop edx
  1750                                  	push dword w32result
  1751                                  	push edx			;cursor
  1752                                  	push ebx			;length
  1753                                  	push dword attribline
  1754                                  	push dword [hout]
  1755                                  	call WriteConsoleOutputAttribute
  1756                                  %else
  1757                                  	;this works on both Terminal and W32, ...
  1758                                  	;...but is suboptimal and slow on W32
  1759 000019B2 E8AB050000              	call sys_writeKP		;set cursor pos before writing the line
  1760 000019B7 5A                      	pop edx
  1761 000019B8 51                      	push ecx
  1762 000019B9 B8[CC320000]            	mov eax,screencolors1		;set bold yellow on blue
  1763 000019BE E822000000              	call sys_writeSLColors		;special for status line (ecx==0)
  1764 000019C3 B9[34370100]            	mov ecx,screenline		;second argument: pointer to message to write
  1765 000019C8 E8CE0E0000              	call WriteFile0
  1766                                  ;-------
  1767 000019CD 59                      	pop ecx
  1768 000019CE B8[BE320000]            	mov eax,screencolors0		;reset to b/w
  1769 000019D3 E80D000000              	call sys_writeSLColors		;special for status line (ecx==0)
  1770 000019D8 8B15[042F0100]          	mov edx,[kurspos2]
  1771 000019DE E87F050000              	call sys_writeKP		;restore old cursor pos
  1772                                  %endif
  1773                                  NoWrite:POP_ALL
  1773                              <1> NoWrite:
  1773 000019E3 61                  <1>  popa
  1774 000019E4 C3                      	ret
  1775                                  ;-------
  1776                                  ; a helper for ScreenLineShow
  1777                                  ;
  1778                                  sys_writeSLColors:
  1779                                  %ifndef W32
  1780 000019E5 E301                    	jecxz syswSL			;do nothing if not in status line
  1781 000019E7 C3                      	ret
  1782                                  syswSL:	PUSH_ALL
  1782                              <1> syswSL: 
  1782 000019E8 60                  <1>  pusha
  1783 000019E9 91                      	xchg eax,ecx			;parameter points to ESC-xxx color string
  1784 000019EA 6A0E                    	push byte scolorslen
  1785 000019EC 5A                      	pop edx
  1786 000019ED E8A90E0000              	call WriteFile0
  1787                                  	POP_ALL
  1787 000019F2 61                  <1>  popa
  1788                                  %endif
  1789 000019F3 C3                      	ret
  1790                                  ;----------------------------------------------------------------------
  1791                                  ;
  1792                                  ; getting line INPUT from terminal / UNDER CONSTRUCTION
  1793                                  ;
  1794                                  ; expecting pointer to message text in esi
  1795                                  ;
  1796 000019F4 BE[D72F0000]            InputStringWithMessage0:mov esi,extext
  1797 000019F9 E8F50A0000              InputStringWithMessage:call WriteMess9MakeLine
  1798 000019FE B9[C8350100]            	mov ecx,optbuffer
  1799 00001A03 6A7C                    	push byte optslen
  1800 00001A05 5A                      	pop edx
  1801 00001A06 EB0F                    	jmp short InputString
  1802                                  ;-------
  1803 00001A08 B9[C8330100]            InputString00:mov ecx,suchtext
  1804 00001A0D E8E10A0000              InputString0:call WriteMess9MakeLine
  1805 00001A12 BAFF000000              	mov edx,maxfilenamelen
  1806                                  ; expecting input line buffer in ecx
  1807                                  ; expecting max count byte in edx
  1808                                  ; return length in eax, CY for empty string (or user abort)
  1809                                  ;
  1810 00001A17 51                      InputString:push ecx
  1811 00001A18 57                      	push edi
  1812 00001A19 6A02                    	push byte 2
  1813 00001A1B 58                      	pop eax
  1814 00001A1C 8705[80380100]          	xchg eax, [VICmdMode]
  1815 00001A22 50                      	push eax			;LONGER: push dword [VICmdMode], mov byte [VICmdMode],2
  1816 00001A23 FF35[042F0100]          	push dword [kurspos2]
  1817 00001A29 8B1D[F02E0100]          	mov ebx,[columns]
  1818                                  %ifndef LINUX
  1819                                  	dec ebx				;*BSD do not use lower right screen place...
  1820                                  %endif					;...due some unwanted vertical scrolling
  1821 00001A2F 8D5BF6                  	lea ebx,[ebx-stdtxtlen]
  1822 00001A32 39DA                    	cmp edx,ebx			;TODO should enable some scrolling:
  1823 00001A34 7202                    	jb IS8				;not yet ready, so truncate at end of line
  1824 00001A36 89DA                    	mov edx,ebx			;edx == max chars
  1825 00001A38 31DB                    IS8:	xor ebx,ebx			;ebx == chars in buffer
  1826 00001A3A 89CF                    	mov edi,ecx			;edi == pointer on current char
  1827                                  ;-------				;ecx == pointer to begin of readline text
  1828                                  ;
  1829 00001A3C 53                      IS0:	push ebx			;local loop starts here
  1830 00001A3D 52                      	push edx
  1831 00001A3E 51                      	push ecx
  1832                                  	PUSH_ALL
  1832 00001A3F 60                  <1>  pusha
  1833 00001A40 89CE                    	mov esi,ecx
  1834 00001A42 8D3D[3E370100]          	lea edi,[screenline+stdtxtlen]
  1835 00001A48 89D9                    	mov ecx,ebx
  1836 00001A4A FC                      	cld
  1837 00001A4B F3A4                    	rep movsb			;copy line buffer into screen display buffer
  1838 00001A4D 89D1                    	mov ecx,edx
  1839 00001A4F 29D9                    	sub ecx,ebx
  1840 00001A51 B020                    	mov al,32			;fill up with blanks
  1841 00001A53 F3AA                    	rep stosb
  1842                                  	POP_ALL
  1842 00001A55 61                  <1>  popa
  1843                                  ;-------
  1844 00001A56 89FB                    	mov ebx,edi			;next lines for setting cursor position
  1845 00001A58 29CB                    	sub ebx,ecx
  1846 00001A5A 80C30A                  	add bl,stdtxtlen		;offset+column
  1847                                  %ifdef UTF8
  1848                                  %ifdef UTF8RTS
  1849                                  	cmp byte [isUTF8],0
  1850                                  	je noUTF_I
  1851                                  %endif
  1852 00001A5D 89CE                    	mov esi,ecx
  1853 00001A5F AC                      ISloopUTF8:lodsb
  1854 00001A60 24C0                    	and al,0C0h
  1855 00001A62 3C80                    	cmp al,080h
  1856 00001A64 7502                    	jne ISdncUTF8
  1857 00001A66 FECB                    	dec bl				;do not count byte 2,3,4,....
  1858 00001A68 39FE                    ISdncUTF8:cmp esi,edi
  1859 00001A6A 72F3                    	jb ISloopUTF8
  1860                                  noUTF_I:
  1861                                  %endif
  1862 00001A6C 8A3D[EC2E0100]          	mov bh,byte[lines]		;line#
  1863 00001A72 891D[042F0100]          	mov [kurspos2],ebx
  1864                                  ;-------
  1865                                  %ifdef LESSWRITEOPS
  1866 00001A78 C605[00000000]00        	mov byte [screenbuffer],0	;switching off usage of buffer v0.7
  1867                                  %endif
  1868 00001A7F E8EDFEFFFF              	call StatusLineShow		;show input
  1869 00001A84 E840010000              	call GetChar			;read next
  1870 00001A89 59                      	pop ecx
  1871 00001A8A 5A                      	pop edx
  1872 00001A8B 5B                      	pop ebx
  1873 00001A8C FC                      	cld
  1874                                  ;-------
  1875 00001A8D E8D5FCFFFF              	call IsViMode
  1876 00001A92 7504                    	jnz NO_VI01
  1877 00001A94 3C00                    	cmp al,0
  1878 00001A96 7407                    	je ISA
  1879 00001A98 E8CF0C0000              NO_VI01:call CheckUserAbort
  1880 00001A9D 7507                    	jne IS9
  1881 00001A9F 31DB                    ISA:	xor ebx,ebx			;length 0 triggers CY flag
  1882 00001AA1 E9FF000000              IS1j:	jmp IS1
  1883 00001AA6 3C0D                    IS9:	cmp al,RETURN
  1884 00001AA8 74F7                    	je IS1j
  1885 00001AAA 3C08                    	cmp al,8			;^H (translated DEL)
  1886 00001AAC 750F                    	jne IS2
  1887                                  DNHloopUTF8:
  1888 00001AAE 39CF                    	cmp edi,ecx			;@left border?
  1889 00001AB0 748A                    	je IS0
  1890                                  ;-------
  1891 00001AB2 4F                      	dec edi				;go 1 left
  1892                                  %ifdef UTF8
  1893                                  %ifdef UTF8RTSx_wont			;Keep UTF8 bytes together even in deleting
  1894                                  	cmp byte [isUTF8],0
  1895                                  	je noUTF_J
  1896                                  %endif
  1897 00001AB3 8A07                    	mov al,byte [edi]		;check for UTF byte 2,3,4,..
  1898 00001AB5 24C0                    	and al,0c0h
  1899 00001AB7 3C80                    	cmp al,080h
  1900 00001AB9 74F3                    	je DNHloopUTF8
  1901                                  noUTF_J:
  1902 00001ABB EB70                    	jmp Delete1
  1903                                  %else
  1904                                  	jmp short Delete1		;and continue at delete key
  1905                                  %endif
  1906                                  ;-------
  1907 00001ABD 3C00                    IS2:	cmp al,0			;marker of cursor keys etc.
  1908 00001ABF 0F858C000000            	jne NoSpecialKey
  1909 00001AC5 80FC05                  	cmp ah,5			;end
  1910 00001AC8 7508                    	jne NotEnd
  1911 00001ACA 8D3C19                  	lea edi,[ecx+ebx]
  1912                                  IS0j:	
  1913                                  %ifdef UTF8
  1914 00001ACD E96AFFFFFF              	jmp IS0
  1915                                  %else
  1916                                  	jmp short IS0
  1917                                  %endif
  1918 00001AD2 80FC00                  NotEnd:	cmp ah,0			;home
  1919 00001AD5 7504                    	jne NotHome
  1920 00001AD7 89CF                    	mov edi,ecx
  1921 00001AD9 EBF2                    	jmp short IS0j
  1922 00001ADB 80FC03                  NotHome	cmp ah,3			;left <-
  1923 00001ADE 750F                    	jne NotLeft
  1924                                  NHloopUTF8:
  1925 00001AE0 39CF                    	cmp edi,ecx
  1926 00001AE2 74E9                    	je IS0j
  1927 00001AE4 4F                      	dec edi
  1928                                  %ifdef UTF8
  1929                                  %ifdef UTF8RTSx_wont			;see KeyLeft comment
  1930                                  	cmp byte [isUTF8],0
  1931                                  	je noUTF_K
  1932                                  %endif
  1933 00001AE5 8A07                    	mov al,byte [edi]
  1934 00001AE7 24C0                    	and al,0c0h
  1935 00001AE9 3C80                    	cmp al,080h
  1936 00001AEB 74F3                    	je NHloopUTF8
  1937                                  noUTF_K:
  1938                                  %endif
  1939 00001AED EBDE                    	jmp short IS0j
  1940 00001AEF 80FC04                  NotLeft:cmp ah,4			;right ->
  1941 00001AF2 7512                    	jne NotRight
  1942 00001AF4 8D3419                  	lea esi,[ecx+ebx]
  1943                                  NLloopUTF8:
  1944 00001AF7 39F7                    	cmp edi,esi
  1945 00001AF9 74D2                    	je IS0j
  1946 00001AFB 47                      	inc edi
  1947                                  %ifdef UTF8
  1948                                  %ifdef UTF8RTSx_wont			;see KeyRight comment
  1949                                  	cmp byte [isUTF8],0
  1950                                  	je near IS0
  1951                                  %endif
  1952 00001AFC 8A07                    	mov al,byte [edi]
  1953 00001AFE 24C0                    	and al,0c0h
  1954 00001B00 3C80                    	cmp al,080h
  1955 00001B02 74F3                    	je NLloopUTF8
  1956                                  noUTF_L:
  1957                                  %endif
  1958 00001B04 EBC7                    IS0jj:	jmp short IS0j
  1959 00001B06 80FC08                  NotRight:cmp ah,8			;Insert
  1960 00001B09 751D                    	jne NotIns
  1961 00001B0B F615[582F0100]          	not byte [insstat]
  1962                                  %ifdef NEW_CURSOR_MGNT
  1963 00001B11 803D[582F0100]01        	cmp byte [insstat],1
  1964 00001B18 7507                    	jne short NCM
  1965 00001B1A E8550D0000              	call SetCursorBlock
  1966 00001B1F EBAC                    	jmp short IS0j
  1967 00001B21 E8440D0000              NCM:	call SetCursorNormal
  1968                                  %endif
  1969 00001B26 EBA5                    	jmp short IS0j
  1970 00001B28 80FC09                  NotIns:	cmp ah,9			;Del
  1971 00001B2B 7524                    	jne NoSpecialKey
  1972 00001B2D 8D3419                  Delete1:lea esi,[ecx+ebx]		;do not delete at last character position
  1973 00001B30 39F7                    	cmp edi,esi			;...or in empty buffer...
  1974 00001B32 74D0                    	je IS0jj
  1975                                  %ifdef UTF8
  1976 00001B34 51                      	push ecx
  1977 00001B35 57                      	push edi
  1978 00001B36 56                      	push esi
  1979 00001B37 89D9                    	mov ecx,ebx			;TODO: check this
  1980 00001B39 8D7701                  	lea esi,[edi+1]
  1981 00001B3C 4B                      	dec ebx				;decrease char count in buffer	
  1982                                  DeloopUTF8:
  1983                                  %ifdef UTF8RTSx_wont			;Keep UTF8 bytes together even in deleting
  1984                                  	cmp byte [isUTF8],0
  1985                                  	je noUTF_M
  1986                                  %endif
  1987 00001B3D 8A06                    	mov al,byte [esi]
  1988 00001B3F 24C0                    	and al,0C0h
  1989 00001B41 3C80                    	cmp al,080h
  1990 00001B43 7504                    	jne DeUTF8
  1991 00001B45 46                      	inc esi				;delete one more at UTF-8 byte 2,3,4,....
  1992 00001B46 4B                      	dec ebx				;decrease char count in buffer
  1993 00001B47 EBF4                    	jmp short DeloopUTF8
  1994                                  noUTF_M:
  1995 00001B49 FC                      DeUTF8:	cld
  1996 00001B4A F3A4                    	rep movsb			;move all in buffer 1 char to left
  1997 00001B4C 5E                      	pop esi
  1998 00001B4D 5F                      	pop edi
  1999 00001B4E 59                      	pop ecx
  2000                                  %else
  2001                                  	PUSH_ALL
  2002                                  	mov ecx,ebx			;TODO: check this
  2003                                  	lea esi,[edi+1]
  2004                                  	cld
  2005                                  	rep movsb			;move all in buffer 1 char to left
  2006                                  	POP_ALL
  2007                                  	dec ebx				;decrease char count in buffer
  2008                                  %endif
  2009 00001B4F EBB3                    	jmp short IS0jj
  2010                                  ;-------
  2011                                  NoSpecialKey:
  2012 00001B51 3C20                    	cmp al,SPACECHAR
  2013 00001B53 72AF                    	jb short IS0jj
  2014                                  
  2015                                  %ifdef UTF8
  2016                                  %ifdef UTF8RTSx_wont			;Keep UTF8 bytes together
  2017                                  	cmp byte [isUTF8],0
  2018                                  	je noUTF_N
  2019                                  %endif
  2020 00001B55 53                      	push ebx
  2021 00001B56 88C3                    	mov bl,al
  2022 00001B58 80E3C0                  	and bl,0C0h
  2023 00001B5B 80FB80                  	cmp bl,080h			;byte 2,3,4.. always insert
  2024 00001B5E 5B                      	pop ebx
  2025 00001B5F 7410                    	je INSrt
  2026                                  noUTF_N:
  2027                                  %endif
  2028 00001B61 803D[582F0100]01        	cmp byte [insstat],1
  2029 00001B68 7407                    	jz INSrt
  2030 00001B6A 8D3419                  	lea esi,[ecx+ebx]
  2031 00001B6D 39F7                    	cmp edi,esi
  2032 00001B6F 7513                    	jnz NO_INSERT
  2033                                  INSrt:	PUSH_ALL
  2033                              <1> INSrt: 
  2033 00001B71 60                  <1>  pusha
  2034 00001B72 89F8                    	mov eax,edi
  2035 00001B74 8D7C1101                	lea edi,[ecx+edx+1]		;end of buffer space
  2036 00001B78 8D77FF                  	lea esi,[edi-1]
  2037 00001B7B 89F9                    	mov ecx,edi
  2038 00001B7D 29C1                    	sub ecx,eax
  2039 00001B7F FD                      	std
  2040 00001B80 F3A4                    	rep movsb			;move all in buffer 1 char to right
  2041                                  	POP_ALL
  2041 00001B82 61                  <1>  popa
  2042 00001B83 43                      	inc ebx
  2043 00001B84 FC                      NO_INSERT:cld
  2044 00001B85 AA                      	stosb
  2045                                  %ifdef UTF8
  2046                                  %ifdef UTF8RTSx_wont			;Keep UTF8 bytes together
  2047                                  	cmp byte [isUTF8],0
  2048                                  	je noUTF_O
  2049                                  %endif
  2050 00001B86 89FE                    	mov esi,edi
  2051 00001B88 4E                      	dec esi
  2052 00001B89 46                      NI_loopUTF8:inc esi
  2053 00001B8A 8A06                    	mov al,byte [esi]
  2054 00001B8C 24C0                    	and al,0C0h
  2055 00001B8E 3C80                    	cmp al,080h			;delete byte 2,3,4,....
  2056 00001B90 74F7                    	je NI_loopUTF8
  2057                                  ;-------
  2058 00001B92 39FE                    	cmp esi,edi
  2059 00001B94 7407                    	je NI_UTF8rdy
  2060                                  	PUSH_ALL
  2060 00001B96 60                  <1>  pusha
  2061 00001B97 89D9                    	mov ecx,ebx			;TODO: check this
  2062 00001B99 FC                      	cld
  2063 00001B9A F3A4                    	rep movsb			;move all in buffer 1 char to left
  2064                                  	POP_ALL
  2064 00001B9C 61                  <1>  popa
  2065                                  noUTF_O:
  2066                                  NI_UTF8rdy:
  2067                                  %endif
  2068 00001B9D 39D3                    	cmp ebx,edx
  2069 00001B9F 0F8228FFFFFF            	jb IS0j
  2070                                  ;-------
  2071 00001BA5 31C0                    IS1:	xor eax,eax
  2072 00001BA7 880419                  	mov byte [ecx+ebx],al		;make asciz string
  2073 00001BAA 8F05[042F0100]          	pop dword [kurspos2]
  2074 00001BB0 8F05[80380100]          	pop dword [VICmdMode]		;restore original vi mode
  2075 00001BB6 5F                      	pop edi
  2076 00001BB7 59                      	pop ecx
  2077 00001BB8 93                      	xchg eax,ebx
  2078 00001BB9 3C01                    	cmp al,1			;set cy flag if empty string (len always <256)
  2079 00001BBB C3                      ISready:ret				;eax length (but is < 255)
  2080                                  ;----------
  2081                                  ;
  2082                                  ; GetChar (main function for kbd input)
  2083                                  ;
  2084 00001BBC 89F8                    ReadChar:mov eax,edi
  2085 00001BBE 8705[242F0100]          	xchg eax,[old] 			;for ^QP
  2086 00001BC4 A3[282F0100]            	mov [veryold],eax
  2087 00001BC9 E8FB000000              GetChar:call ReadOneChar		;ah=0xFF for usual keys
  2088                                  %ifdef W32
  2089                                  	cmp ah,0FEh			;cursor key		
  2090                                  	jnz GC33
  2091                                  	shl eax,8
  2092                                  	ret
  2093                                  GC33:	cmp ah,0FDh			;ALT key
  2094                                  	jnz GC34
  2095                                  	and al,5fh			;toupper
  2096                                  	jmp short NOVI7
  2097                                  GC34:
  2098                                  %endif
  2099 00001BCE 3C7F                    	cmp al,7Fh
  2100 00001BD0 7502                    	jne short RC_No7F		;special case: remap DEL to Ctrl-H
  2101                                  %ifndef FREEBSD
  2102 00001BD2 B008                    	mov al,8
  2103                                  %else
  2104                                  	mov al,7
  2105                                  %endif
  2106                                  RC_No7F:
  2107                                  ;-------
  2108                                  %define DoNo 10
  2109                                  ;-------
  2110                                  ;
  2111                                  ; vi needs special handling of the ESC key
  2112                                  ;
  2113 00001BD4 E88EFBFFFF              	call IsViMode
  2114 00001BD9 740B                    	jz short ISVI7
  2115 00001BDB 3C1B                    	cmp al,27 			;ESC ?
  2116 00001BDD 75DC                    	jnz ISready
  2117 00001BDF E8E5000000              	call ReadOneChar		;dont care whether '[' or 'O' (should be [ for vt220 family  O for vt100 family)
  2118 00001BE4 EB5B                    	jmp short NOVI7
  2119                                  ;-------
  2120 00001BE6 803D[80380100]01        ISVI7:	cmp byte [VICmdMode],1
  2121 00001BED 7525                    	jne NoCMDmode
  2122 00001BEF 3C1B                    	cmp al,27
  2123 00001BF1 7412                    	je ESCpressed
  2124 00001BF3 3C7B                    	cmp al,VIsize
  2125 00001BF5 0F8799000000            	ja near Other
  2126 00001BFB BB[11300000]            	mov ebx,VIcmdTable		;process command mode keys......
  2127 00001C00 E9BA000000              	jmp RCready_0			;....and ready
  2128                                  ;-------
  2129 00001C05 E8BF000000              ESCpressed:call ReadOneChar
  2130 00001C0A 3C5B                    	cmp al,'['			;decide: it's a cursor key?
  2131 00001C0C 0F8482000000            	je near Other			;yes, contine
  2132 00001C12 EB1B                    	jmp short NoCursorKey		;no push back char into buffer and exit
  2133 00001C14 3C1B                    NoCMDmode:cmp al,27 			;ESC ?
  2134 00001C16 75A3                    	jnz ISready
  2135 00001C18 E806FBFFFF              	call KeyVImode1			;ESC pressed in EDIT Mode
  2136                                  %ifdef BEOS
  2137                                  	call RestoreStatusLine
  2138                                  %else
  2139                                  %ifdef SYS_select
  2140                                  	PUSH_ALL
  2140 00001C1D 60                  <1>  pusha
  2141 00001C1E E8BF0C0000              	call Select			;differ between ESC and ESC_cursor_keys
  2142                                  	POP_ALL
  2142 00001C23 61                  <1>  popa
  2143 00001C24 7412                    	jz isSingleEscape
  2144                                  %endif
  2145                                  %endif
  2146 00001C26 E89E000000              	call ReadOneChar
  2147 00001C2B 3C5B                    	cmp al,'['			;starting sequence of cursor key found?
  2148 00001C2D 740D                    	je IsCursorKey			;pressed ESC, but do _NOT_ switch init cmd mode
  2149 00001C2F A2[84380100]            NoCursorKey:mov byte [VIbufch],al	;push char back into read buffer due it's not a cursor key
  2150 00001C34 B00A                    	mov al,DoNo			;do nothing
  2151 00001C36 EB2F                    	jmp short JmpRCready
  2152 00001C38 B003                    isSingleEscape:mov al,3			;3 is keyLeft (i.e. entry #3 jumptab1)
  2153 00001C3A EB2B                    	jmp short JmpRCready		;keyLeft is what a real vi user expects here ;)
  2154                                  ;-------
  2155 00001C3C E88DFAFFFF              IsCursorKey:call KeyVImode0		;reset mode to 'no_command' and continue
  2156                                  ;-------
  2157 00001C41 803D[A0380100]10        NOVI7:	cmp byte [mode],NE		;ALT keys are currently used for nedit mode...
  2158 00001C48 7510                    	jnz NONE7
  2159 00001C4A 3C69                    	cmp al,'i'
  2160 00001C4C 7504                    	jnz NOi
  2161 00001C4E B010                    	mov al,0x10
  2162 00001C50 EB15                    	jmp short JmpRCready
  2163 00001C52 3C49                    NOi:	cmp al,'I'
  2164 00001C54 7504                    	jnz NONE7
  2165 00001C56 B010                    	mov al,0x10
  2166 00001C58 EB0D                    	jmp short JmpRCready
  2167 00001C5A E810FBFFFF              NONE7:	call IsEmMode
  2168 00001C5F 7529                    	jnz NOEM7			;ALT keys are currently used for Emacs mode...
  2169 00001C61 3C25                    	cmp al,'%'			;...except altH for online Help
  2170 00001C63 7504                    	jne NoAltPer
  2171 00001C65 B028                    	mov al,0x28
  2172 00001C67 EB57                    JmpRCready:jmp short RCready_1
  2173 00001C69 3C3C                    NoAltPer:cmp al,'<'
  2174 00001C6B 7504                    	jne NoAltLt
  2175 00001C6D B00E                    	mov al,0x0e
  2176 00001C6F EB4F                    	jmp short RCready_1
  2177 00001C71 3C3E                    NoAltLt:cmp al,'>'
  2178 00001C73 7504                    	jne NoAltGt
  2179 00001C75 B00F                    	mov al,0x0f
  2180 00001C77 EB47                    	jmp short RCready_1
  2181 00001C79 245F                    NoAltGt:and al,0x5F			;to upper case
  2182 00001C7B 2C42                    	sub al,'B'			;1at in table
  2183 00001C7D 7815                    	js Other
  2184 00001C7F 3C17                    	cmp al,ATsize
  2185 00001C81 7711                    	ja Other
  2186 00001C83 BB[FA2F0000]            	mov ebx,EmaAltTable
  2187 00001C88 EB35                    	jmp short RCready_0
  2188 00001C8A 245F                    NOEM7:	and al,0x5F
  2189 00001C8C 3C48                    	cmp al,'H'
  2190 00001C8E 7504                    	jnz Other
  2191 00001C90 B03D                    	mov al,0x3D
  2192 00001C92 EB2C                    	jmp short RCready_1
  2193                                  ;-------
  2194                                  Other:	
  2195                                  %ifdef W32
  2196                                  	ret
  2197                                  %else
  2198 00001C94 E830000000              	call ReadOneChar
  2199 00001C99 3C38                    	cmp al,'8'
  2200 00001C9B 770D                    	ja NoNumber
  2201 00001C9D 50                      	push eax			;0,1,2....8  (i.e. 9 keys)
  2202 00001C9E E826000000              	call ReadOneChar
  2203 00001CA3 93                      	xchg eax,ebx
  2204 00001CA4 58                      	pop eax
  2205 00001CA5 80FB7E                  	cmp bl,'~'			;if it's a number we expect following a '~'
  2206 00001CA8 751A                    	jne GetCharJmp
  2207 00001CAA 2C30                    NoNumber:sub al,'0'
  2208 00001CAC 3C09                    	cmp al,9
  2209 00001CAE 720A                    	jb IsNumber
  2210                                  %ifdef QNX
  2211                                  	sub al,('@'-'0'-9)		;scantable starts with ESC[@
  2212                                  %else
  2213 00001CB0 2C08                    	sub al,('A'-'0'-9)
  2214                                  %endif
  2215 00001CB2 3C09                    	cmp al,9
  2216 00001CB4 720E                    	jb GetCharJmp
  2217 00001CB6 3C11                    	cmp al,STsize
  2218 00001CB8 770A                    	ja GetCharJmp
  2219 00001CBA BB[E92F0000]            IsNumber:mov ebx,ScanTable
  2220                                  %endif
  2221 00001CBF D7                      RCready_0:xlatb
  2222 00001CC0 C1E008                  RCready_1:shl eax,8			;shift into ah (ah always != 0xFF)
  2223 00001CC3 C3                      	ret
  2224 00001CC4 E900FFFFFF              GetCharJmp:jmp near GetChar
  2225                                  ;-------
  2226                                  ; called by ReadChar/GetChar
  2227                                  ;
  2228 00001CC9 E899FAFFFF              ReadOneChar:call IsViMode
  2229 00001CCE 750C                    	jnz NOVI4
  2230 00001CD0 31C0                    	xor eax,eax
  2231 00001CD2 8705[84380100]          	xchg eax,[VIbufch]		;preread char in buf?
  2232 00001CD8 09C0                    	or eax,eax
  2233 00001CDA 750F                    	jne RoneC
  2234 00001CDC B9[4C2F0100]            NOVI4:	mov ecx,read_b			;pointer to buf
  2235 00001CE1 31D2                    	xor edx,edx
  2236 00001CE3 42                      	inc edx				;mov edx,1  (length)
  2237 00001CE4 E8A90B0000              	call ReadFile0
  2238                                  %ifdef SELFTEST				;for NON_INTERACTIVE mode exit on EOF!
  2239                                  	jnz Cont
  2240                                  	jmp KeyCtrlKX
  2241                                  Cont:
  2242                                  %endif
  2243 00001CE9 8B01                    	mov eax,[ecx]			;[read_b]
  2244                                  %ifdef W32_EXTENDED_IO
  2245                                  	ret
  2246                                  %endif
  2247 00001CEB B4FF                    RoneC:	mov ah,0xFF
  2248 00001CED C3                      	ret
  2249                                  ;----------------------------------------------------------------------
  2250                                  ;
  2251                                  ; L O O K functions
  2252                                  ; search special text locations and set register edi to
  2253                                  ;
  2254                                  LookBackward:				;set EDI to 1 before LINEFEED (0Ah) i.e., 2 before start of next line
  2255 00001CEE 51                      	push ecx
  2256 00001CEF 53                      	push ebx
  2257 00001CF0 31DB                    	xor ebx,ebx
  2258 00001CF2 807FFF0A                	cmp byte[edi-1],NEWLINE		;at BOL ?
  2259 00001CF6 741D                    	jz LBa3
  2260 00001CF8 803F0A                  	cmp byte[edi],NEWLINE		;at EOL ?
  2261 00001CFB 7502                    	jnz LBa1
  2262 00001CFD 4F                      	dec edi				;at EOL ? start search 1 char earlier
  2263 00001CFE 43                      	inc ebx				;increase counter
  2264                                  ;-------
  2265 00001CFF B99F860100              LBa1:	mov ecx,99999
  2266 00001D04 B00A                    	mov al,NEWLINE
  2267 00001D06 FD                      	std
  2268 00001D07 F2AE                    	repne scasb
  2269 00001D09 8D839D860100            	lea eax,[ebx+99997]		;mov eax,99997 / add eax,ebx
  2270 00001D0F 29C8                    	sub eax,ecx
  2271 00001D11 5B                      LBa5:	pop ebx
  2272 00001D12 59                      	pop ecx
  2273 00001D13 EB20                    	jmp short CheckBof
  2274                                  ;-------
  2275 00001D15 31C0                    LBa3:	xor eax,eax
  2276 00001D17 4F                      	dec edi
  2277 00001D18 4F                      	dec edi
  2278 00001D19 EBF6                    	jmp short LBa5
  2279                                  ;-------
  2280                                  LookForward:
  2281 00001D1B 51                      	push ecx			;don't touch edx (if called by BZNLoop only)
  2282 00001D1C B99F860100              	mov ecx,99999
  2283 00001D21 B00A                    	mov al,NEWLINE
  2284 00001D23 FC                      	cld
  2285 00001D24 F2AE                    	repne scasb
  2286 00001D26 B89E860100              	mov eax,99998
  2287 00001D2B 29C8                    	sub eax,ecx
  2288 00001D2D 59                      	pop ecx
  2289 00001D2E 4F                      	dec edi
  2290 00001D2F 39EF                    CheckEof:cmp edi,ebp			;ptr is eof-ptr?
  2291 00001D31 7511                    	jnz CheckEnd			;Z flag if eof
  2292 00001D33 EB08                    	jmp short CheckENum
  2293 00001D35 81FF[EC3C0100]          CheckBof:cmp edi, sot-1
  2294 00001D3B 7707                    	ja CheckEnd
  2295 00001D3D C605[482F0100]01        CheckENum:mov byte [numeriere],1	;if bof
  2296 00001D44 C3                      CheckEnd:ret
  2297                                  ;-------
  2298 00001D45 8B15[042F0100]          LookPgBegin:mov edx,[kurspos2]		;called by DispNewScreen to get sync with 1st char on screen
  2299 00001D4B 0FB6CE                  	movzx ecx,dh			;called by KeyCtrlQE  (go upper left)   OLD: xor ecx,ecx mov cl,dh
  2300 00001D4E 41                      	inc ecx				;'inc cl' are 2 Bytes
  2301 00001D4F EB34                    	jmp short LookPU2
  2302                                  ;-------
  2303 00001D51 8B15[042F0100]          LookPgEnd:mov edx,[kurspos2]		;goes 1st char last line on screen
  2304 00001D57 8B0D[EC2E0100]          	mov ecx,[lines]
  2305 00001D5D 28F1                    	sub cl,dh
  2306 00001D5F EB5E                            jmp short LookPD2
  2307                                  ;-------
  2308 00001D61 6A02                    LookLineUp:push byte 2			;2 lines: THIS line and line BEFORE
  2309 00001D63 59                      	pop ecx
  2310 00001D64 FF0D[2C2F0100]          	dec dword [linenr]
  2311 00001D6A EB19                    	jmp short LookPU2
  2312                                  ;-------
  2313 00001D6C 6A02                    LookLineDown:push byte 2		;2 lines: THIS and NEXT line
  2314 00001D6E 59                      	pop ecx
  2315 00001D6F FF05[2C2F0100]          	inc dword [linenr]
  2316 00001D75 EB48                    	jmp short LookPD2
  2317                                  ;-------
  2318 00001D77 8B0D[EC2E0100]          LookPageUp:mov ecx,[lines]
  2319 00001D7D 49                      	dec ecx				;PgUp,PgDown one line less
  2320 00001D7E 290D[2C2F0100]          LookPU1:sub [linenr],ecx
  2321 00001D84 41                      	inc ecx
  2322 00001D85 E864FFFFFF              LookPU2:call LookBackward
  2323 00001D8A 47                      	inc edi				;inc keeps CY flag!
  2324 00001D8B 7202                    	jb LookPUEnd			;if BOF
  2325 00001D8D E2F6                    	loop LookPU2			;after loop edi points to char left of LINEFEED (0ah)
  2326 00001D8F 47                      LookPUEnd:inc edi			;now points to 1st char on screen or line
  2327 00001D90 C3                      	ret
  2328                                  ;-------
  2329 00001D91 31C9                    LookScrDn:xor ecx,ecx
  2330 00001D93 41                      	inc ecx
  2331 00001D94 EB22                    	jmp short LookPD1
  2332 00001D96 31C9                    LookScrUp:xor ecx,ecx
  2333 00001D98 41                      	inc ecx
  2334 00001D99 EBE3                    	jmp short LookPU1
  2335 00001D9B 8B0D[EC2E0100]          LookHalfPgUp:mov ecx,[lines]		;vi special
  2336 00001DA1 49                      	dec ecx
  2337 00001DA2 D1E9                    	shr ecx,1
  2338 00001DA4 EBD8                    	jmp short LookPU1
  2339 00001DA6 8B0D[EC2E0100]          LookHalfPgDn:mov ecx,[lines]
  2340 00001DAC 49                      	dec ecx
  2341 00001DAD D1E9                    	shr ecx,1
  2342 00001DAF EB07                    	jmp short LookPD1
  2343                                  ;-------
  2344 00001DB1 8B0D[EC2E0100]          LookPgDown:mov ecx,[lines]
  2345 00001DB7 49                      	dec ecx				;PgUp,PgDown one line less
  2346 00001DB8 010D[2C2F0100]          LookPD1:add [linenr],ecx
  2347 00001DBE 41                      	inc ecx
  2348 00001DBF E857FFFFFF              LookPD2:call LookForward
  2349 00001DC4 7404                    	jz LookPDEnd			;(jmp if EOF)
  2350 00001DC6 47                      	inc edi				;1st char next line
  2351 00001DC7 E2F6                    	loop LookPD2
  2352 00001DC9 4F                      	dec edi				;last char last line
  2353 00001DCA 29C7                    LookPDEnd:sub edi,eax			;1st char last line
  2354 00001DCC C3                      	ret
  2355                                  ;----------------------------------------------------------------------
  2356                                  ;
  2357                                  ; some more CHECK functions
  2358                                  ;
  2359 00001DCD 803D[302F0100]01        CheckBlock:cmp byte [showblock],1	;returns CY if error else ok: NC
  2360 00001DD4 7222                    	jc CheckBlockEnd
  2361 00001DD6 8B35[1C2F0100]          	mov esi,[blockende]
  2362 00001DDC 81FE[ED3C0100]          	cmp esi, sot
  2363 00001DE2 7214                    	jb CheckBlockEnd
  2364 00001DE4 8B35[182F0100]          	mov esi,[blockbegin]		;side effect esi points to block begin
  2365 00001DEA 81FE[ED3C0100]          	cmp esi, sot
  2366 00001DF0 7206                    	jb CheckBlockEnd
  2367 00001DF2 3935[1C2F0100]          	cmp [blockende],esi     	;^KK > ^KB ..OK if above!
  2368 00001DF8 C3                      CheckBlockEnd:ret
  2369                                  ;-------
  2370 00001DF9 393D[182F0100]          CheckImBlock:cmp [blockbegin],edi	;^KB mark > edi ?
  2371 00001DFF 7706                    	ja CImBlockEnd			;OK
  2372 00001E01 3B3D[1C2F0100]          	cmp edi,[blockende]		;edi > ^KK
  2373 00001E07 C3                      CImBlockEnd:ret	          		;output:cy error / nc ok inside block
  2374                                  ;-------
  2375 00001E08 803F0A                  CheckMode:cmp byte [edi],NEWLINE	;checks for INSERT status
  2376 00001E0B 7407                    	jz ChModeEnd
  2377 00001E0D 803D[582F0100]01        	cmp byte [insstat],1
  2378 00001E14 C3                      ChModeEnd:ret				;Z flag for ins-mode
  2379                                  ;-------
  2380                                  ; a special case called by DeleteByteCheckMarker
  2381                                  ;
  2382                                  CheckMarker:				;edx is blockbegin (^KB)
  2383                                  					;ebx is deleate area end --- edi delete area start
  2384 00001E15 39D7                    	cmp edi,edx			;delete area start < ^KB marker ?
  2385 00001E17 7706                    	ja CMEnd			;no
  2386 00001E19 39D3                    	cmp ebx,edx			;yes, but delete area end > ^KB ?
  2387 00001E1B 7202                    	jb CMEnd			;no
  2388 00001E1D 89FA                    	mov edx,edi			;yes so block start (^KB) to delete area start
  2389 00001E1F C3                      CMEnd:	ret
  2390                                  ;----------------------------------------------------------------------
  2391                                  ;
  2392                                  ; C O U N T  functions
  2393                                  ; to return number of chars up to some place
  2394                                  ; (all of them are wrappers of Look....functions anyway)
  2395                                  ;
  2396 00001E20 57                      CountToLineEnd:push edi
  2397 00001E21 E8F5FEFFFF              	call LookForward
  2398 00001E26 5F                      	pop edi
  2399 00001E27 C3                      	ret				;eax=chars up to line end
  2400                                  ;-------
  2401                                  CountColToLineBeginVis:			;counts columns represented by chars in EAX
  2402 00001E28 E832000000              	call CountToLineBegin		;i.e. EXPAND any TAB chars found
  2403 00001E2D 56                      	push esi
  2404 00001E2E 31D2                    	xor edx,edx
  2405 00001E30 89FE                    	mov esi,edi			;startpoint
  2406 00001E32 29C6                    	sub esi,eax			;to bol
  2407 00001E34 4E                      	dec esi
  2408 00001E35 46                      CCV1:	inc esi
  2409 00001E36 39FE                    	cmp esi,edi
  2410 00001E38 731B                    	jae CCVend
  2411                                  %ifdef UTF8
  2412                                  %ifdef UTF8RTS
  2413                                  	cmp byte [isUTF8],0
  2414                                  	je noUTF_P
  2415                                  %endif
  2416 00001E3A 8A1E                    	mov bl,byte [esi]
  2417 00001E3C 80E3C0                  	and bl,0C0h
  2418 00001E3F 80FB80                  	cmp bl,080h			;do not count byte 2,3,4,.. in UTF8 chars
  2419 00001E42 74F1                    	jz CCV1
  2420                                  noUTF_P:
  2421                                  %endif
  2422 00001E44 803E09                  	cmp byte [esi],TABCHAR
  2423 00001E47 7403                    	jz CCVTab
  2424 00001E49 42                      	inc edx				;count visible chars
  2425 00001E4A EBE9                    	jmp short CCV1
  2426 00001E4C E8D9080000              CCVTab:	call SpacesForTab		;return space_up_to_next_tab in ah
  2427 00001E51 00E2                    	add dl,ah			;FIXME: now using 8 bits only
  2428 00001E53 EBE0                    	jmp short CCV1
  2429 00001E55 8915[442F0100]          CCVend: mov [ch2linebeg],edx		;ch2linebeg: interface to Key... functions
  2430 00001E5B 89D0                    	mov eax,edx			;eax: interface to DispNewScreen
  2431 00001E5D 5E                      	pop esi
  2432                                  %ifdef W32LF
  2433                                  	cmp byte[edi-1],RETURN
  2434                                  	jnz CCV2
  2435                                  	dec byte [ch2linebeg]		;don't count in RETURN char
  2436                                  CCV2:	
  2437                                  %endif
  2438 00001E5E C3                      	ret
  2439                                  ;-------
  2440 00001E5F 57                      CountToLineBegin:push edi		;output eax=chars up there
  2441 00001E60 E889FEFFFF              	call LookBackward
  2442 00001E65 89FE                    	mov esi,edi			;side effect: set edi to 1st char in line
  2443 00001E67 5F                      	pop edi
  2444 00001E68 C3                      	ret
  2445                                  ;-------
  2446                                  CountToWordBeginVIstyle:		;output eax=chars up there
  2447 00001E69 89FE                    	mov esi,edi
  2448 00001E6B 803E20                  	cmp byte [esi],SPACECHAR
  2449 00001E6E 771C                    	ja CtWviStyle
  2450                                  CountToWordBegin:			;output eax=chars up there
  2451 00001E70 89FE                    	mov esi,edi
  2452 00001E72 39EE                    CountNLoop:cmp esi,ebp
  2453 00001E74 7411                    	jz CTWend
  2454 00001E76 46                      	inc esi
  2455                                  %ifdef W32LF
  2456                                  	cmp byte [esi],RETURN
  2457                                  %else
  2458 00001E77 803E0A                  	cmp byte [esi],NEWLINE
  2459                                  %endif
  2460 00001E7A 740B                    	jz CTWend
  2461 00001E7C 803E20                  	cmp byte [esi],SPACECHAR	;below SPACE includes tab chars
  2462 00001E7F 76F1                    	jbe CountNLoop
  2463 00001E81 807EFF2F                	cmp byte [esi-1],2fh
  2464 00001E85 77EB                    	ja CountNLoop
  2465 00001E87 89F0                    CTWend:	mov eax,esi
  2466 00001E89 29F8                    	sub eax,edi			;maybe =0
  2467 00001E8B C3                      Goret:	ret
  2468                                  ;-------
  2469 00001E8C 46                      CtWviStyle:inc esi
  2470                                  %ifdef W32LF
  2471                                  	cmp byte [esi],RETURN
  2472                                  %else
  2473 00001E8D 803E0A                  	cmp byte [esi],NEWLINE
  2474                                  %endif
  2475 00001E90 74F5                    	jz CTWend
  2476 00001E92 803E2F                  	cmp byte [esi],2fh
  2477 00001E95 77F5                    	ja CtWviStyle
  2478 00001E97 EBD9                    	jmp short CountNLoop
  2479                                  ;----------------------------------------------------------------------
  2480                                  ;
  2481                                  ; Online Help: show the message followed by common text
  2482                                  ;
  2483                                  KeyHelp:
  2484                                  %ifdef USE_BUILTINHELP
  2485 00001E99 FF35[002F0100]          	push dword [kurspos]
  2486                                  	PUSH_ALL
  2486 00001E9F 60                  <1>  pusha
  2487 00001EA0 31C0                    	xor eax,eax
  2488 00001EA2 8705[302F0100]          	xchg eax,[showblock]		;hide an blockmarker
  2489 00001EA8 50                      	push eax
  2490 00001EA9 FC                      	cld
  2491 00001EAA BE[ED3C0100]            	mov esi,sot			;save "buffercopysize" of text
  2492 00001EAF BF[B0380100]            	mov edi,buffercopy
  2493 00001EB4 B900040000              	mov ecx,buffercopysize
  2494 00001EB9 57                      	push edi
  2495 00001EBA 51                      	push ecx
  2496 00001EBB 56                      	push esi
  2497                                  ;-------
  2498 00001EBC F3A4                    	rep movsb
  2499 00001EBE E877080000              	call GetHelpText
  2500 00001EC3 5F                      	pop edi
  2501 00001EC4 57                      	push edi			;i.e. mov edi,sot
  2502                                  ;-------
  2503 00001EC5 57                      	push edi
  2504 00001EC6 F3A4                    	rep movsb			;overwrite saved text with help message
  2505 00001EC8 BE[51330000]            	mov esi,helpfoot
  2506 00001ECD 6A19                    	push byte helpfootsize
  2507 00001ECF 59                      	pop ecx
  2508 00001ED0 F3A4                    	rep movsb
  2509 00001ED2 89FD                    	mov ebp,edi			;set END_OF_HELP_TEXT pointer
  2510 00001ED4 5F                      	pop edi
  2511 00001ED5 E89DF8FFFF              	call DispNewScreen
  2512 00001EDA E8EAFDFFFF              	call ReadOneChar		;wait for a pressed char
  2513                                  ;-------
  2514 00001EDF 5F                      	pop edi
  2515 00001EE0 59                      	pop ecx
  2516 00001EE1 5E                      	pop esi				;former edi
  2517 00001EE2 FC                      	cld
  2518 00001EE3 F3A4                    	rep movsb			;restore textbuffer with saved patr
  2519 00001EE5 8F05[302F0100]          	pop dword [showblock]
  2520                                  	POP_ALL
  2520 00001EEB 61                  <1>  popa
  2521 00001EEC 5A                      	pop edx				;cursor pos
  2522 00001EED EB6D                    	jmp short SetKursPos
  2523                                  %else
  2524                                  	ret
  2525                                  %endif
  2526                                  ;---------------------------------------------------------------------
  2527                                  ;
  2528                                  ; some CURSOR control functions
  2529                                  ;
  2530 00001EEF 31C0                    GoUp:	xor eax,eax
  2531 00001EF1 EB08                    	jmp short UpDown
  2532 00001EF3 A0[EC2E0100]            GoDown:	mov al,byte [lines]
  2533 00001EF8 48                      	dec eax				;'dec al' are 2 byte!
  2534 00001EF9 B4FF                    	mov ah,-1
  2535 00001EFB 8B15[042F0100]          UpDown:	mov edx,[kurspos2]		;former was call getkurspos
  2536 00001F01 38F0                    	cmp al,dh
  2537 00001F03 7486                    	jz Goret
  2538 00001F05 18E6                    	sbb dh,ah			;ONLY here we change curent line of cursor
  2539 00001F07 EB53                    	jmp short SetKursPos
  2540                                  ;-------
  2541                                  ; set cursor to some desired places
  2542                                  ;
  2543 00001F09 E8BBFDFFFF              KeyVICmdz:call ReadOneChar
  2544 00001F0E 3C2E                    	cmp al,'.'
  2545 00001F10 7419                    	je KeyEmaCtrlL
  2546 00001F12 C3                      	ret
  2547                                  ;-------
  2548 00001F13 E82DFEFFFF              KeyVI_M:call LookPgBegin
  2549 00001F18 E889FEFFFF              	call LookHalfPgDn
  2550 00001F1D F605[EC2E0100]01        	test byte[lines],1
  2551 00001F24 7505                    	jnz KeyEmaCtrlL
  2552 00001F26 E841FEFFFF              	call LookLineDown
  2553                                  ;------- cont
  2554 00001F2B E82FFFFFFF              KeyEmaCtrlL:call CountToLineBegin
  2555 00001F30 8A35[EC2E0100]          	mov dh,byte [lines]		;move cursor to center line (and later redisplay)
  2556 00001F36 D0EE                    	shr dh,1
  2557 00001F38 88C2                    	mov dl,al
  2558 00001F3A EB20                    	jmp short SetKursPos
  2559 00001F3C 31D2                    KursorFirstLine:xor edx,edx
  2560 00001F3E EB1C                    	jmp short SetKursPos
  2561 00001F40 8A35[EC2E0100]          KursorLastLine:mov dh,byte [lines]
  2562 00001F46 FECE                    	dec dh
  2563 00001F48 B200                    	mov dl,0
  2564 00001F4A EB10                    	jmp short SetKursPos
  2565 00001F4C 8A35[EC2E0100]          KursorStatusLine:mov dh,byte [lines]
  2566 00001F52 B20A                    	mov dl,stdtxtlen
  2567 00001F54 EB06                    	jmp short SetKursPos
  2568 00001F56 8B15[002F0100]          RestKursPos:mov edx,[kurspos]
  2569 00001F5C 8915[042F0100]          SetKursPos:mov [kurspos2],edx      	;saves reading cursor pos   (0,0)
  2570                                  sys_writeKP:PUSH_ALL
  2570                              <1> sys_writeKP:
  2570 00001F62 60                  <1>  pusha
  2571                                  %ifdef W32
  2572                                  	shl edx,8			;linux cursorpos in dh/dl   -   w32 in edx 2*16bit
  2573                                  	mov dl,dh
  2574                                  	and edx,0x00FF00FF
  2575                                  	push dword edx			;xxxxyyyy x=line y=column
  2576                                  	push dword [hout]
  2577                                  	call SetConsoleCursorPosition
  2578                                  %else
  2579 00001F63 E80F000000              	call make_KPstr
  2580 00001F68 B9[D02E0000]            	mov ecx,setkp 			;second argument: pointer to message to write
  2581 00001F6D 6A0A                    	push byte setkplen		;third argument: message length
  2582 00001F6F 5A                      	pop edx
  2583 00001F70 E826090000              	call WriteFile0
  2584                                  %endif
  2585                                  	POP_ALL
  2585 00001F75 61                  <1>  popa
  2586 00001F76 C3                      	ret
  2587                                  ;-------
  2588                                  ; make ESC sequence appropriate to most important terminals
  2589                                  ;
  2590                                  %ifndef W32
  2591                                  ;	;expecting cursor pos in dh/dl (0,0)
  2592 00001F77 FC                      make_KPstr:cld
  2593 00001F78 BF[D02E0000]            	mov edi,setkp			;build cursor control esc string db 27,'[000;000H'
  2594 00001F7D B01B                    	mov al,1Bh
  2595 00001F7F AA                      	stosb				;init memory
  2596                                  %ifndef ARMCPU
  2597 00001F80 B85B303030              	mov eax,'[000'
  2598 00001F85 AB                      	stosd
  2599 00001F86 B03B                    	mov al,';'			;i.e. load eax with ';000'
  2600 00001F88 AB                      	stosd
  2601                                  %else
  2602                                  	mov al,'['
  2603                                  	stosb
  2604                                  	mov al,'0'
  2605                                  	stosb
  2606                                  	stosb
  2607                                  	stosb
  2608                                  	mov al,';'
  2609                                  	stosb
  2610                                  	mov al,'0'
  2611                                  	stosb
  2612                                  	stosb
  2613                                  	stosb
  2614                                  %endif
  2615 00001F89 B048                    	mov al,'H'
  2616 00001F8B AA                      	stosb				;now we have written 10 chars
  2617 00001F8C 8D7FFA                  	lea edi,[edi-6]			;old was "mov edi,setkp+1+3" now using 1+3 == 10-6
  2618 00001F8F 0FB6C6                  	movzx eax,dh			;DH=line
  2619 00001F92 40                      	inc eax				;now counted from 1
  2620 00001F93 52                      	push edx
  2621 00001F94 E80A000000              	call IntegerToAscii		;make number string
  2622 00001F99 5A                      	pop edx
  2623 00001F9A BF[D82E0000]            	mov edi,setkp+1+3+4		;column end
  2624 00001F9F 0FB6C2                  	movzx eax,dl			;DL=col
  2625 00001FA2 40                      	inc eax				;now counted from 1
  2626                                  %endif
  2627                                  ;-------continued...
  2628                                  ; a general helper
  2629                                  ;   expects integer# in eax
  2630                                  IntegerToAscii:
  2631 00001FA3 09C0                    	or eax,eax
  2632 00001FA5 7903                    	jns ItoA1
  2633                                  	;int 3				;Assertation
  2634 00001FA7 31C0                    	xor eax,eax			;this should never be
  2635 00001FA9 40                      	inc eax
  2636 00001FAA 6A0A                    ItoA1:	push byte 10
  2637 00001FAC 59                      	pop ecx
  2638 00001FAD FD                      	std
  2639 00001FAE 93                      	xchg eax,ebx			;ebx helper (xchg eax,.. is only 1 byte!)
  2640 00001FAF 93                      Connum1:xchg eax,ebx
  2641 00001FB0 99                      	cdq
  2642 00001FB1 F7F1                    	div ecx
  2643 00001FB3 93                      	xchg eax,ebx			;save quotient (new low word)
  2644 00001FB4 88D0                    	mov al,dl
  2645 00001FB6 240F                    	and al,0fh
  2646 00001FB8 0430                    	add al,'0'
  2647 00001FBA AA                      	stosb
  2648 00001FBB 09DB                    	or ebx,ebx
  2649 00001FBD 75F0                    	jne Connum1
  2650 00001FBF FC                      	cld
  2651 00001FC0 C3                      ITAret:	ret
  2652                                  ;----------------------------------------------------------------------
  2653                                  ;
  2654                                  ; functions for INSERTING, COPYING and DELETING chars in text
  2655                                  ;
  2656                                  DeleteByteCheckMarker:			;edi points to begin
  2657 00001FC1 F605[A0380100]09        	test byte [mode], WS | VI	;see above note at "jz NOWS8"
  2658 00001FC8 7425                    	jz DeleteByte
  2659 00001FCA 8D1C07                  	lea ebx,[edi+eax]		;ebx points to end
  2660 00001FCD 8B15[182F0100]          	mov edx,[blockbegin]
  2661 00001FD3 E83DFEFFFF              	call CheckMarker
  2662 00001FD8 8915[182F0100]          	mov [blockbegin],edx
  2663 00001FDE 8B15[1C2F0100]          	mov edx,[blockende]
  2664 00001FE4 E82CFEFFFF              	call CheckMarker
  2665 00001FE9 8915[1C2F0100]          	mov [blockende],edx
  2666 00001FEF 09C0                    DeleteByte:or eax,eax			;input in eax
  2667 00001FF1 74CD                    	jz ITAret
  2668                                  %ifdef USE_UNDO
  2669 00001FF3 E8A40D0000              	call DataForUndoDelete
  2670                                  %endif
  2671 00001FF8 57                      	push edi
  2672 00001FF9 89E9                    	mov ecx,ebp			;end
  2673 00001FFB 29F9                    	sub ecx,edi
  2674 00001FFD 8D3407                  	lea esi,[edi+eax]		;current + x chars
  2675 00002000 29C1                    	sub ecx,eax
  2676 00002002 803D[A0380100]01        	cmp byte [mode],WS
  2677 00002009 7406                    	jz No_WS8
  2678 0000200B 030D[6C380100]          	add ecx,[EmaKiSize]
  2679 00002011 41                      No_WS8:	inc ecx
  2680 00002012 FC                      	cld
  2681 00002013 F3A4                    	rep movsb
  2682 00002015 F7D8                    	neg eax				;"neg eax" is for continuing @InsertByte
  2683 00002017 EB58                    	jmp short Ins0			;pending "pop edi"
  2684                                  ;-------
  2685 00002019 31C0                    Insert1Byte:xor eax,eax
  2686 0000201B 40                      InsertByte0:inc eax
  2687                                  ;
  2688                                  ; do NOT destroy eax
  2689                                  ;
  2690 0000201C 09C0                    InsertByte:or eax,eax			;input: eax = # of bytes  edi = ptr where
  2691 0000201E 74A0                    	jz ITAret
  2692 00002020 8B0D[C42F0100]          	mov ecx,[maxlen]		;max_len+offset-eofptr=freespace(ecx)
  2693 00002026 81C1[ED3C0100]          	add ecx,sot
  2694 0000202C 29E9                    	sub ecx,ebp
  2695 0000202E 8B15[6C380100]          	mov edx,[EmaKiSize]
  2696 00002034 29D1                    	sub ecx,edx			;sub size of kill buffer from free space
  2697 00002036 39C1                    	cmp ecx,eax			;cmp freespace - newbytes  ;>= 0 ok/ NC  <0 bad / CY
  2698 00002038 7314                    	jnc SpaceAva
  2699 0000203A 6A0C                    	push byte ERRNOMEM
  2700 0000203C 8F05[5C2F0100]          	pop dword [ErrNr]		;(mov dword[ErrNr],..  has 2 byte extra)
  2701 00002042 E89C030000              	call OSerror
  2702 00002047 E80AFFFFFF              	call RestKursPos
  2703 0000204C F9                      	stc
  2704 0000204D C3                      	ret
  2705 0000204E 57                      SpaceAva:push edi
  2706                                  %ifdef USE_UNDO
  2707 0000204F E8E70D0000              	call DataForUndoInsert
  2708                                  %endif
  2709 00002054 89EE                    	mov esi,ebp			;end of text movsb-source
  2710 00002056 8D4D01                  	lea ecx,[ebp+1]
  2711 00002059 29F9                    	sub ecx,edi			;space count: distance between eof and current position
  2712 0000205B 8D7C0500                	lea edi,[ebp+eax]		;movsb-destination
  2713 0000205F 803D[A0380100]01        	cmp byte [mode],WS
  2714 00002066 7406                    	jz ISWS8
  2715 00002068 01D1                    	add ecx,edx			;add size of kill buffer to distance
  2716 0000206A 01D7                    	add edi,edx
  2717 0000206C 01D6                    	add esi,edx
  2718 0000206E FD                      ISWS8:	std
  2719 0000206F F3A4                    	rep movsB
  2720 00002071 5F                      Ins0:	pop edi				;here is the jmp destination from DeleteByte
  2721                                  ;-------
  2722 00002072 E8CBEDFFFF              	call SetChg			;i.e. mov byte [changed],CHANGED
  2723 00002077 01C5                    	add ebp,eax
  2724 00002079 F605[A0380100]09        	test byte [mode], WS | VI	;for vi mode it would be enough to handle blockbegin
  2725 00002080 741C                    	jz NOWS8			;..because blockende is set at end of marker line..
  2726 00002082 3B3D[1C2F0100]          	cmp edi,[blockende]		;..at HandleVImarker procedure
  2727 00002088 7306                    	jae Ins1
  2728 0000208A 0105[1C2F0100]          	add [blockende],eax
  2729 00002090 3B3D[182F0100]          Ins1:	cmp edi,[blockbegin]
  2730 00002096 731D                    	jae Ins2
  2731 00002098 0105[182F0100]          	add [blockbegin],eax
  2732                                  NOWS8:
  2733 0000209E F605[A0380100]06        	test byte [mode], EM | PI
  2734 000020A5 740E                    	jz NO_EM02
  2735 000020A7 3B3D[74380100]          	cmp edi,[EmaMark]
  2736 000020AD 7306                    	jae Ins2
  2737 000020AF 0105[74380100]          	add [EmaMark],eax
  2738                                  NO_EM02:
  2739 000020B5 F8                      Ins2:	clc
  2740 000020B6 C3                      	ret				;output:nc=ok/cy=bad /ecx=0/ eax inserted / -eax deleted
  2741                                  ;-------
  2742 000020B7 E811FDFFFF              CopyBlock:call CheckBlock		;copy block, called by ^KC, ^KV
  2743 000020BC 7223                    	jc MoveBlEnd
  2744 000020BE E836FDFFFF              	call CheckImBlock
  2745 000020C3 721C                    	jc MoveBlEnd
  2746 000020C5 A1[1C2F0100]            	mov eax,[blockende]
  2747 000020CA 29F0                    	sub eax,esi			;block len
  2748 000020CC E84BFFFFFF              	call InsertByte
  2749 000020D1 720E                    	jc MoveBlEnd
  2750 000020D3 8B35[182F0100]          	mov esi,[blockbegin]
  2751                                  ;-------
  2752 000020D9 57                      MoveBlock:push edi			;input : esi=^KB edi=current
  2753 000020DA 89C1                    	mov ecx,eax			;don't use xchg here
  2754 000020DC FC                      	cld
  2755 000020DD F3A4                    	rep movsb
  2756 000020DF 5F                      	pop edi
  2757 000020E0 F8                      	clc				;nocarry->ok
  2758 000020E1 C3                      MoveBlEnd:ret				;return eax=size
  2759                                  ;----------------------------------------------------------------------
  2760 000020E2 57                      KeyVICmdyy:push edi
  2761 000020E3 E82AEFFFFF              	call KeyHome
  2762 000020E8 893D[74380100]          	mov [EmaMark],edi
  2763 000020EE E828F6FFFF              	call KeyEnd
  2764 000020F3 47                      	inc edi				;add a line delimiter
  2765 000020F4 E8A6000000              	call KeyEmaAltW
  2766 000020F9 5F                      	pop edi
  2767 000020FA C3                      KviRet:	ret
  2768                                  ;-------
  2769 000020FB E8C9FBFFFF              KeyVICmdy:call ReadOneChar
  2770 00002100 3C79                    	cmp al,'y'
  2771 00002102 74DE                    	je KeyVICmdyy
  2772 00002104 3C27                    	cmp al,"'"
  2773 00002106 75D9                    	jne MoveBlEnd
  2774 00002108 E8BCFBFFFF              	call ReadOneChar
  2775 0000210D 3C61                    	cmp al,'a'			;" y'a "    only marker "a" supported
  2776 0000210F 75D0                    	jne MoveBlEnd
  2777 00002111 8B0D[182F0100]          	mov ecx,[blockbegin]		;don't go further if no mark set
  2778 00002117 E3C8                    	jecxz MoveBlEnd
  2779 00002119 E8DEEEFFFF              	call VIsetMarker
  2780 0000211E E87C000000              	call KeyEmaAltW
  2781 00002123 8B3D[182F0100]          	mov edi,[blockbegin]
  2782                                  %ifdef W32
  2783                                  	jmp ISVI9
  2784                                  %else
  2785 00002129 EB2F                    	jmp short ISVI9
  2786                                  %endif
  2787                                  ;
  2788                                  ; some of the EM specials
  2789                                  ;
  2790                                  KeyEmaCtrlY:
  2791                                  %ifdef W32
  2792                                  	cmp byte[mode],NE		;Nedit ^V
  2793                                  	jnz KECY
  2794                                  	PUSH_ALL
  2795                                  	push byte 0
  2796                                  	call OpenClipboard
  2797                                  	or eax,eax
  2798                                  	jz KECY3
  2799                                  	push byte CF_OEMTEXT
  2800                                  	call IsClipboardFormatAvailable
  2801                                  	or eax,eax
  2802                                  	jz KECY0
  2803                                  	push byte CF_OEMTEXT
  2804                                  	call GetClipboardData
  2805                                  	or eax,eax
  2806                                  	jz KECY0
  2807                                  	mov edi,ebp
  2808                                  	inc edi				;one after eof
  2809                                  	mov ecx,[maxlen]
  2810                                  	add ecx,sot			;the last possible byte
  2811                                  	xor ebx,ebx
  2812                                  	dec ebx				;init counter -1
  2813                                  	xchg esi,eax
  2814                                  	cld
  2815                                  Kloop:	lodsb
  2816                                  	inc ebx
  2817                                  	cmp edi,ecx
  2818                                  	jnb KECY2
  2819                                  	stosb
  2820                                  	or al,al
  2821                                  	jnz Kloop
  2822                                  KECY2:  mov [EmaKiSize],ebx	
  2823                                  KECY0:	call CloseClipboard
  2824                                  KECY3:	POP_ALL
  2825                                  KECY:
  2826                                  %endif
  2827 0000212B 8B0D[6C380100]          	mov ecx,[EmaKiSize]
  2828                                  %ifdef YASM
  2829                                  	or ecx,ecx
  2830                                  	jmp KeawRet
  2831                                  %else
  2832 00002131 E36B                    	jecxz KeawRet
  2833                                  %endif
  2834 00002133 91                      	xchg eax,ecx			;OLD mov eax,ecx 1 byte longer
  2835 00002134 50                      	push eax
  2836 00002135 E8E2FEFFFF              	call InsertByte
  2837 0000213A 59                      	pop ecx
  2838 0000213B 7261                    	jc KeawRet			;no_space_error is handled in InsertByte
  2839 0000213D 89EE                    	mov esi,ebp
  2840 0000213F 46                      	inc esi
  2841 00002140 893D[74380100]          	mov [EmaMark],edi
  2842 00002146 FC                      	cld
  2843 00002147 F3A4                    	rep movsb
  2844 00002149 E8FFF2FFFF              	call ShowBl0			;i.e. "mov byte [showblock],0"
  2845 0000214E E814F6FFFF              	call IsViMode
  2846 00002153 7405                    	jz ISVI9
  2847 00002155 E8D1FDFFFF              	call KeyEmaCtrlL
  2848 0000215A E913F1FFFF              ISVI9:	jmp CQFNum
  2849                                  ;-------
  2850                                  KeyEmaAltW2:PUSH_ALL
  2850                              <1> KeyEmaAltW2:
  2850 0000215F 60                  <1>  pusha
  2851 00002160 89EF                    	mov edi,ebp
  2852 00002162 47                      	inc edi
  2853 00002163 E8FFF5FFFF              	call IsViMode
  2854 00002168 7417                    	jz KEW
  2855                                  ;-------
  2856 0000216A 803D[78380100]01        	cmp byte [EmaCtrlK],1
  2857 00002171 750E                    	jnz KEW
  2858 00002173 033D[6C380100]          	add edi,[EmaKiSize]
  2859 00002179 0105[6C380100]          	add [EmaKiSize],eax
  2860 0000217F EB0B                    	jmp short KE2
  2861 00002181 A3[6C380100]            KEW:	mov [EmaKiSize],eax
  2862 00002186 8935[70380100]          	mov [EmaKiSrc],esi
  2863 0000218C 89C1                    KE2:	mov ecx,eax
  2864 0000218E FC                      	cld
  2865 0000218F F3A4                    	rep movsb
  2866 00002191 E8B7F2FFFF              	call ShowBl0			;i.e. "mov byte [showblock],0"
  2867 00002196 C605[78380100]01        Keaw2:	mov byte [EmaCtrlK],1
  2868                                  	POP_ALL
  2868 0000219D 61                  <1>  popa
  2869 0000219E C3                      KeawRet:ret
  2870                                  ;-------
  2871 0000219F C605[88380100]00        KeyEmaAltW:mov byte [VInolinebased],0
  2872                                  	PUSH_ALL
  2872 000021A6 60                  <1>  pusha
  2873 000021A7 8B0D[302F0100]          	mov ecx,[showblock]
  2874 000021AD E3E7                    	jecxz Keaw2
  2875 000021AF 8B0D[74380100]          	mov ecx,[EmaMark]
  2876 000021B5 E3DF                    	jecxz Keaw2
  2877 000021B7 89F8                    	mov eax,edi
  2878 000021B9 39C1                    	cmp ecx,eax
  2879 000021BB 7201                    	jb KEAW
  2880 000021BD 91                      	xchg eax,ecx
  2881 000021BE 29C8                    KEAW:	sub eax,ecx			;eax end / ecx beg
  2882 000021C0 89CE                    	mov esi,ecx
  2883 000021C2 89EF                    	mov edi,ebp
  2884 000021C4 47                      	inc edi
  2885 000021C5 A3[6C380100]            	mov [EmaKiSize],eax
  2886 000021CA 8935[70380100]          	mov [EmaKiSrc],esi
  2887 000021D0 91                      	xchg eax,ecx			;OLD mov ecx,eax 1 byte longer
  2888 000021D1 FC                      	cld
  2889 000021D2 F3A4                    	rep movsb
  2890 000021D4 E88EF5FFFF              	call IsViMode
  2891 000021D9 7405                    	jz KEAW3
  2892 000021DB E86DF2FFFF              	call ShowBl0			;i.e. "mov byte [showblock],0"
  2893                                  KEAW3:	
  2894                                  %ifdef W32
  2895                                  	cmp byte[mode],NE		;Nedit ^C
  2896                                  	jnz KEAW4
  2897                                  	push dword [EmaKiSize]
  2898                                  	push byte 0
  2899                                  	push dword [heap]
  2900                                  	call HeapAlloc
  2901                                  	or eax,eax
  2902                                  	jz KEAW4
  2903                                  	mov esi,[EmaKiSrc]
  2904                                  	mov edi,eax
  2905                                  	mov ecx,[EmaKiSize]
  2906                                  	cld
  2907                                  	rep movsb
  2908                                  	mov byte[edi],0			;ASCIIZ
  2909                                  ;-------
  2910                                  	push dword [heap]
  2911                                  	push byte 0
  2912                                  	push eax			;push for later usage in HeapFree
  2913                                  	push eax			;push clip handle for SetClipboardData
  2914                                  	push byte 0
  2915                                  	call OpenClipboard
  2916                                  	or eax,eax
  2917                                  	jz KEAW8
  2918                                  	call EmptyClipboard
  2919                                  	push byte CF_OEMTEXT
  2920                                  	call SetClipboardData
  2921                                  	call CloseClipboard
  2922                                  KEAW8:	call HeapFree
  2923                                  KEAW4:
  2924                                  %endif
  2925                                  	POP_ALL
  2925 000021E0 61                  <1>  popa
  2926 000021E1 C3                      KeaWRet:ret
  2927                                  ;----------------------------------------------------------------------
  2928                                  ;
  2929                                  ; functions reading/writing  text or blocks  from/into  files
  2930                                  ;
  2931 000021E2 BE[FE320000]            NFnoarg:mov esi,helptext		;initial part of help
  2932 000021E7 BF[ED3C0100]            	mov edi,sot
  2933 000021EC 6A53                    	push byte helptextsize
  2934 000021EE 59                      	pop ecx
  2935 000021EF 57                      	push edi
  2936 000021F0 F3A4                    	rep movsb
  2937                                  ;-------
  2938 000021F2 E843050000              	call GetHelpText		;second part of help
  2939 000021F7 8DA9[403D0100]          	lea ebp,[ecx+sot+helptextsize]	;set END_OF_HELP_TEXT pointer
  2940 000021FD F3A4                    	rep movsb
  2941 000021FF 5F                      	pop edi
  2942 00002200 E872F5FFFF              	call DispNewScreen
  2943                                  ;-------
  2944 00002205 BE[712F0000]            	mov esi, filename
  2945 0000220A B9[C82F0100]            	mov ecx, filepath
  2946 0000220F E8F9F7FFFF              	call InputString0
  2947 00002214 732A                    	jnc GetFile			;empty string not allowed here
  2948 00002216 C3                      	ret
  2949                                  ;-------
  2950 00002217 8D7102                  KeyVICmdE:lea esi,[ecx+2]
  2951 0000221A 803E20                  	cmp byte [esi],SPACECHAR
  2952 0000221D 74C2                    	je KeaWRet
  2953                                  	PUSH_ALL			;save before load new
  2953 0000221F 60                  <1>  pusha
  2954 00002220 E892000000              	call SaveFile
  2955                                  	POP_ALL
  2955 00002225 61                  <1>  popa
  2956                                  ;-------continue
  2957 00002226 FC                      NewFile:cld
  2958 00002227 E815030000              	call InitVars
  2959                                  %ifdef AMD64
  2960                                  	or rsi,rsi
  2961                                  	jz NFnoarg
  2962                                  	cmp byte [rsi],0
  2963                                  %else
  2964 0000222C 09F6                    	or esi,esi
  2965 0000222E 74B2                    	jz NFnoarg
  2966 00002230 803E00                  	cmp byte [esi],0
  2967                                  %endif
  2968 00002233 74AD                    	jz NFnoarg
  2969 00002235 BF[C82F0100]            	mov edi,filepath
  2970                                  NF1:
  2971                                  %ifdef W32
  2972                                  	lodsb
  2973                                  	cmp al,'"'
  2974                                  	jz NF1
  2975                                  	stosb
  2976                                  	cmp al,SPACECHAR		;truncate after blanks
  2977                                  	jnz NF3
  2978                                  NF4:	mov byte [edi-1],0
  2979                                  	jmp short GetFile
  2980                                  NF3:	cmp al,TABCHAR
  2981                                  	jz NF4	
  2982                                  %else
  2983 0000223A AC                      	lodsb
  2984 0000223B AA                      	stosb
  2985                                  %endif
  2986 0000223C 08C0                    NF2:	or al,al
  2987 0000223E 75FA                    	jnz NF1
  2988                                  ;------- cont
  2989                                  GetFile:
  2990                                  %ifdef BEOS
  2991                                  	xor ebx,ebx
  2992                                  	mov edx,ebx
  2993                                  	dec ebx				;edx==0,ebx==-1
  2994                                  	mov ecx,filepath
  2995                                  %else
  2996 00002240 BB[C82F0100]            	mov ebx,filepath
  2997                                  %endif
  2998 00002245 E858060000              	call OpenFile0
  2999 0000224A BF[ED3C0100]            	mov edi,sot
  3000 0000224F 89FD                    	mov ebp,edi
  3001 00002251 785E                    	js NewFileEnd
  3002                                  %ifdef SYS_brk
  3003 00002253 E87D030000              	call Seek
  3004                                  	PUSH_ALL
  3004 00002258 60                  <1>  pusha
  3005 00002259 8D9C0000A00F00          	lea ebx,[eax+eax+max]		;twice filesize plus reserve = space for inserts
  3006 00002260 891D[C42F0100]          	mov [maxlen],ebx
  3007 00002266 81C3[EC3C0100]          	add ebx,text
  3008 0000226C E854060000              	call SysBrk
  3009                                  	POP_ALL
  3009 00002271 61                  <1>  popa
  3010 00002272 7835                    	js OSejmp1			;OSerror
  3011                                  %else
  3012                                  	mov ebx,eax			;for FreeBSD memory is hard coded by maxlen
  3013                                  %endif
  3014                                  ;-------
  3015                                  %ifdef SYS_fstat			;not for W32,BEOS
  3016 00002274 E83B060000              	call Fstat
  3017 00002279 782E                    	js OSejmp1			;OSerror
  3018 0000227B A1[F4360100]            	mov eax,[fstatbuf+stat_struc.st_mode]
  3019                                  %ifdef FREEBSD
  3020                                  	mov ecx,eax
  3021                                  	and ecx,0F000h			;see /usr/include/sys/stat.h
  3022                                  	cmp ecx,8000h			;not for special files
  3023                                  	jz regFile
  3024                                  	push byte ERRNOREGFILE
  3025                                  	pop dword [ErrNr]
  3026                                  	jmp OSerror
  3027                                  regFile:
  3028                                  %endif	
  3029 00002280 25FF010000              	and eax,777q
  3030 00002285 A3[E8360100]            	mov [perms],eax
  3031                                  %ifdef SYS_utime	
  3032 0000228A A1[14370100]            	mov eax,[fstatbuf+stat_struc.st_mtime]
  3033 0000228F A3[30370100]            	mov [accesstime+utimbuf_struc.modtime],eax
  3034                                  %endif
  3035                                  %endif					;end of code not for W32,BEOS
  3036                                  ;-------
  3037 00002294 8B15[C42F0100]          OldFile1:mov edx,[maxlen]		;i.e. either 'max' or filesize twice
  3038 0000229A 89F9                    	mov ecx,edi			;sot
  3039 0000229C E8F3050000              	call Read_File
  3040 000022A1 92                      	xchg edx,eax			;mov edx,eax	bytes read
  3041 000022A2 7877                    	js OSejmp0			;OSerror
  3042 000022A4 E8FF050000              	call CloseFile
  3043 000022A9 7870                    OSejmp1:js OSejmp0			;OSerror
  3044 000022AB 8DAA[ED3C0100]          	lea ebp,[edx+sot]		;eof_ptr=filesize+start_of_text
  3045 000022B1 C645000A                NewFileEnd:mov byte [ebp],NEWLINE	;eof-marker
  3046 000022B5 F8                      	clc
  3047 000022B6 C3                      NFEnd2:	ret
  3048                                  ;-------
  3049                                  ;  save file (called by ^KS,^KX)
  3050                                  ;
  3051 000022B7 803D[0C2F0100]20        SaveFile:cmp byte [changed],UNCHANGED
  3052 000022BE 74F6                    	jz NFEnd2			;no changes: nothing to save
  3053 000022C0 BE[8D2F0000]            	mov esi, filesave
  3054 000022C5 E82E020000              	call WriteMess9
  3055                                  ;-------
  3056 000022CA BE[C82F0100]            	mov esi,filepath
  3057 000022CF 57                      	push edi
  3058 000022D0 BF[C8300100]            	mov edi,bakpath
  3059 000022D5 89F3                    	mov ebx,esi
  3060 000022D7 89F9                    	mov ecx,edi
  3061 000022D9 FC                      	cld
  3062 000022DA AC                      SF0:	lodsb
  3063 000022DB AA                      	stosb				;copy to BAK file path
  3064 000022DC 08C0                    	or al,al
  3065 000022DE 75FA                    	jne SF0
  3066 000022E0 4F                      	dec edi
  3067 000022E1 6A7E                    	push byte '~'			;add BAK file extension
  3068 000022E3 58                      	pop eax
  3069                                  %ifdef ARMCPU
  3070                                  	stosb
  3071                                  	shr eax,8
  3072                                  	stosb	
  3073                                  	shr eax,8
  3074                                  	stosb
  3075                                  	shr eax,8
  3076                                  	stosb
  3077                                  %else
  3078 000022E4 AB                      	stosd				;not stosb because ascii-ZERO
  3079                                  %endif
  3080 000022E5 5F                      	pop edi
  3081                                  %ifdef BEOS
  3082                                  	push edi
  3083                                  	mov ebx,0xFFFFFFFF
  3084                                  	mov edx,ebx
  3085                                  	mov ecx,filepath
  3086                                  	mov edi,bakpath
  3087                                  %endif
  3088                                  %ifdef MAKE_BACKUP
  3089 000022E6 81392F746D70            	cmp dword [ecx],'/tmp'
  3090 000022EC 741D                    	je no_ren
  3091                                  %ifdef SYS_readlink
  3092                                  	PUSH_ALL
  3092 000022EE 60                  <1>  pusha
  3093 000022EF B9[44360100]            	mov ecx,linkbuffer		;we are only interested whether symlink or not
  3094 000022F4 6A04                    	push byte linkbuffersize	;=4 byte dummy buffer
  3095 000022F6 5A                      	pop edx
  3096 000022F7 E8B0050000              	call ReadLink
  3097                                  	POP_ALL
  3097 000022FC 61                  <1>  popa
  3098 000022FD 7907                    	jns CopyBAK			;no error means it's a symlink...
  3099 000022FF E8BD050000              	call RenameFile                 ;...but plain files are easy to rename (ecx is filepath)
  3100 00002304 EB05                    	jmp short no_ren		;...simlilar behave 'xemacs' and 'jed'
  3101 00002306 E8B9070000              CopyBAK:call CopyToBackup		;we can't simply rename the link
  3102                                  %else
  3103                                  	call RenameFile                 ;ecx is filepath
  3104                                  %endif
  3105                                  no_ren:	;...continue here...
  3106                                  %endif
  3107                                  %ifdef BEOS
  3108                                  	pop edi
  3109                                  %endif
  3110                                  ;-------
  3111                                  %ifdef W32
  3112                                  	mov ecx,CREATE_ALWAYS
  3113                                  	mov ebx,filepath
  3114                                  	mov edx,GENERIC_WRITE
  3115                                  %else
  3116                                  %ifdef BEOS
  3117                                  	mov ebx,0xFFFFFFFF
  3118                                  	mov ecx,filepath
  3119                                  	mov edx,0x777
  3120                                  %else
  3121 0000230B B941020000              	mov ecx,O_WRONLY_CREAT_TRUNC
  3122 00002310 8B15[E8360100]          	mov edx,[perms]
  3123                                  %endif
  3124                                  %endif
  3125 00002316 E889050000              	call OpenFile
  3126 0000231B 783B                    OSejmp0:js OSejmp9			;OSerror
  3127 0000231D 93                      	xchg ebx,eax			;file descriptor  (xchg is only 1 byte)
  3128                                  ;-------
  3129                                  %ifdef SYS_fchown
  3130 0000231E 8B0D[E8360100]          	mov ecx,[perms]
  3131 00002324 E887050000              	call Fchmod
  3132                                  %endif
  3133                                  %ifdef SYS_fstat
  3134 00002329 8B0D[F8360100]          	mov ecx,[fstatbuf+stat_struc.st_uid]
  3135                                  %ifdef UIDGID_WORD			;Linux special
  3136 0000232F 89CA                    	mov edx,ecx
  3137 00002331 C1EA10                  	shr edx,16
  3138 00002334 0FB7C9                  	movzx ecx,cx			;OLD and ecx,0xffff
  3139                                  %else
  3140                                  	mov edx,[fstatbuf+stat_struc.st_gid]
  3141                                  %endif
  3142 00002337 E881050000              	call ChownFile
  3143                                  %endif
  3144                                  ;-------
  3145 0000233C B9[ED3C0100]            	mov ecx,sot			;ecx=bof
  3146 00002341 89EA                    	mov edx,ebp			;eof
  3147 00002343 29CA                    SaveFile2:sub edx,ecx			;edx=fileesize= eof-bof
  3148 00002345 E81DF4FFFF              	call IsViMode
  3149 0000234A 7507                    	jnz NoAddNL
  3150 0000234C 807DFF0A                	cmp byte [ebp-1],NEWLINE
  3151 00002350 7401                    	jz NoAddNL
  3152 00002352 42                      	inc edx				;append NewLine char for VI mode
  3153 00002353 E846050000              NoAddNL:call Write_File			;ebx=file descriptor
  3154 00002358 7851                    OSejmp9:js OSejmp			;OSerror
  3155 0000235A 6A05                    	push byte ERRNOIO
  3156 0000235C 8F05[5C2F0100]          	pop dword[ErrNr]		;just in case of....
  3157 00002362 39D0                    	cmp eax,edx			;all written?
  3158                                  %ifdef BEOS
  3159                                  	jnz near OSerror
  3160                                  %else
  3161 00002364 757D                    	jnz OSerror
  3162                                  %endif
  3163 00002366 E83D050000              	call CloseFile
  3164 0000236B 783E                    	js OSejmp			;OSerror
  3165 0000236D C3                      SaveFile3:ret
  3166                                  ;-------
  3167                                  ;  save block (called by ^KW)
  3168                                  ;
  3169 0000236E E8B5010000              SaveBlock:call GetBlockName
  3170 00002373 7226                    	jc jcDE2
  3171                                  SaveBl2:
  3172                                  %ifdef W32
  3173                                  	mov ebx,blockpath
  3174                                  SaveBl3:mov ecx,CREATE_ALWAYS
  3175                                  	mov edx,GENERIC_WRITE
  3176                                  %else
  3177                                  %ifdef BEOS
  3178                                  	mov ebx,blockpath
  3179                                  SaveBl3:mov ecx,0xFFFFFFFF
  3180                                  	xchg ebx,ecx
  3181                                  	mov edx,0x241			;was 0x777 upto Dec 01
  3182                                  %else
  3183 00002375 BB[C8310100]            	mov ebx,blockpath
  3184 0000237A B941020000              SaveBl3:mov ecx,O_WRONLY_CREAT_TRUNC
  3185 0000237F BAA4010000              	mov edx,PERMS
  3186                                  %endif
  3187                                  %endif
  3188 00002384 E81B050000              	call OpenFile
  3189 00002389 7820                    	js OSejmp			;OSerror
  3190 0000238B 89F1                    	mov ecx,esi			;= block begin
  3191 0000238D 8B15[1C2F0100]          	mov edx,[blockende]
  3192 00002393 93                      	xchg ebx,eax			;file descriptor  (xchg is only 1 byte)
  3193 00002394 EBAD                    	jmp short SaveFile2
  3194                                  ;-------
  3195                                  ; read a block into buffer (by ^KR)
  3196                                  ;
  3197 00002396 E88D010000              ReadBlock:call GetBlockName
  3198 0000239B 0F8285000000            jcDE2:	jc near DE2
  3199                                  ReadBlock2:
  3200                                  %ifdef BEOS
  3201                                  	xor ebx,ebx
  3202                                  	mov edx,ebx
  3203                                  	dec ebx				;edx==0,ebx==-1
  3204                                  	mov ecx,blockpath
  3205                                  %else
  3206 000023A1 BB[C8310100]            	mov ebx,blockpath
  3207                                  %endif
  3208 000023A6 E8F7040000              	call OpenFile0
  3209 000023AB 7836                    OSejmp:	js OSerror
  3210 000023AD E823020000              	call Seek
  3211 000023B2 782F                    	js OSerror
  3212 000023B4 50                      	push eax			;eax=fileesize
  3213 000023B5 E862FCFFFF              	call InsertByte
  3214 000023BA 5A                      	pop edx				;file size
  3215 000023BB 72B0                    	jc SaveFile3			;ret if cy InsertByte told an error message itself
  3216 000023BD 89F9                    	mov ecx,edi			;^offset akt ptr
  3217 000023BF E8D0040000              	call Read_File
  3218 000023C4 7816                    	js preOSerror			;to delete inserted bytes (# in EDX)
  3219 000023C6 89C1                    	mov ecx,eax    			;bytes read
  3220 000023C8 E8DB040000              	call CloseFile
  3221 000023CD 7814                    	js OSerror
  3222 000023CF 6A05                    	push byte ERRNOIO
  3223 000023D1 8F05[5C2F0100]          	pop dword[ErrNr]		;just in case of....
  3224 000023D7 39CA                    	cmp edx,ecx			;all read?
  3225 000023D9 7508                    	jnz OSerror
  3226 000023DB C3                      	ret
  3227                                  ;-------
  3228 000023DC 89D0                    preOSerror:mov eax,edx			;count bytes
  3229 000023DE E80CFCFFFF              	call DeleteByte			;delete space reserved for insertation
  3230 000023E3 57                      OSerror:push edi
  3231 000023E4 BF[682F0100]            	mov edi,error+8			;where to store ASCII value of ErrNr
  3232 000023E9 A1[5C2F0100]            	mov eax,[ErrNr]
  3233 000023EE 50                      	push eax
  3234 000023EF E8AFFBFFFF              	call IntegerToAscii
  3235 000023F4 59                      	pop ecx				;for getting error text via LookPD2
  3236 000023F5 83F920                  	cmp ecx,MAXERRNO
  3237 000023F8 771C                    	ja DE0
  3238 000023FA BF[6F3E0000]            	mov edi,errmsgs
  3239 000023FF E8BBF9FFFF              	call LookPD2			;look message # (ecx) in line number #
  3240 00002404 89FE                    	mov esi,edi
  3241 00002406 BF[692F0100]            	mov edi,error+9
  3242 0000240B 66B8203A                	mov ax,' :'
  3243                                  %ifdef ARMCPU
  3244                                  	stosb				;error+9 is not aligned
  3245                                  %else
  3246 0000240F 66AB                    	stosw
  3247                                  %endif
  3248 00002411 6A50                    	push byte 80			;max strlen / compare errlen equ 100
  3249 00002413 59                      	pop ecx
  3250 00002414 F3A4                    	rep movsb
  3251 00002416 BE[602F0100]            DE0:	mov esi,error
  3252 0000241B 5F                      	pop edi
  3253 0000241C E8D7000000              DE1:	call WriteMess9
  3254 00002421 E8A3F8FFFF              	call ReadOneChar		;was GetChar
  3255                                  DE2:	;continued...
  3256                                  ;----------------------------------------------------------------------
  3257                                  ;
  3258                                  ; more STATUS LINE maintaining subroutines
  3259                                  ;
  3260                                  RestoreStatusLine:PUSH_ALL		;important e.g. for asksave
  3260                              <1> RestoreStatusLine:
  3260 00002426 60                  <1>  pusha
  3261 00002427 E8E6000000              	call InitStatusLine
  3262 0000242C BE[A0380100]            	mov esi,mode
  3263 00002431 8B0D[F02E0100]          	mov ecx,[columns]		;width
  3264 00002437 80F920                  	cmp cl,stdtxtlen+15+5+2		;this window is too small
  3265                                  %ifdef ARMCPU
  3266                                  	and ecx,0xFFFFFFFC		;get aligned
  3267                                  %endif
  3268 0000243A 0F82AB000000            	jb near RSno_lineNr
  3269 00002440 A0[0C2F0100]            	mov al,byte[changed]
  3270 00002445 A2[35370100]            	mov byte[screenline+1],al	;changed status
  3271                                  ;-------
  3272                                  %ifndef LINUX
  3273                                  	lea eax,[ecx-13+screenline]	;FreeBSD or Beos ...
  3274                                  %else
  3275 0000244A 8D81[28370100]          	lea eax,[ecx-12+screenline]
  3276                                  %endif
  3277 00002450 66C740087669            	mov word[eax+8],'vi'		;vi does show mode info only.
  3278 00002456 803E08                  	cmp byte [esi],VI		;vi doesn't get altH text because altH won't work...
  3279 00002459 7510                    	jnz RSL0			;...caused by different handling due single ESC keys
  3280 0000245B 803D[80380100]01        	cmp byte [VICmdMode],1
  3281 00002462 7536                    	jnz NOVI0
  3282 00002464 BB434D4420              	mov ebx,'CMD '
  3283 00002469 EB42                    	jmp short RSL1
  3284 0000246B C700616C7448            RSL0:	mov dword [eax],'altH'
  3285 00002471 C740043D68656C          	mov dword [eax+4],'=hel'	;'p' is stored with editor mode name
  3286 00002478 BB[EE320000]            	mov ebx,editmode
  3287 0000247D 8B13                    	mov edx,[ebx]
  3288 0000247F 803E04                  	cmp byte [esi],PI
  3289 00002482 7503                    	jnz No_PI1
  3290 00002484 8B5304                  	mov edx,[ebx+4]
  3291 00002487 803E02                  No_PI1:	cmp byte [esi],EM
  3292 0000248A 7503                    	jnz No_Em1
  3293 0000248C 8B5308                  	mov edx,[ebx+8]
  3294 0000248F 803E10                  No_Em1:	cmp byte [esi],NE
  3295 00002492 7503                    	jnz No_Ne1
  3296 00002494 8B530C                  	mov edx,[ebx+12]
  3297 00002497 895008                  No_Ne1:	mov [eax+8],edx
  3298                                  ;-------
  3299 0000249A B820494E53              NOVI0:	mov eax,' INS'			;Insert
  3300 0000249F 803D[582F0100]01        	cmp byte [insstat],1
  3301 000024A6 7405                    	jz RSL1
  3302 000024A8 B8204F5652              	mov eax,' OVR'			;Overwrite
  3303 000024AD A3[38370100]            RSL1:	mov [screenline+4],eax		;mode status
  3304                                  %ifdef UTF8RTS
  3305                                  	cmp byte [isUTF8],0
  3306                                  	jnz RSL1a
  3307                                  	mov al,'7'			;"7bit_non_utf8" status
  3308                                  RSL1a:  mov byte [screenline],al
  3309                                  %endif
  3310 000024B2 BF[3E370100]            	mov edi,screenline+stdtxtlen
  3311 000024B7 8D49E2                  	lea ecx,[ecx-(stdtxtlen+15+5)]	;space for other than filename
  3312 000024BA BE[C82F0100]            	mov esi,filepath		;lea ... is shorter than sub ecx,stdtxtlen+15+5
  3313 000024BF AC                      RSL2:	lodsb
  3314 000024C0 08C0                    	or al,al
  3315 000024C2 7403                    	jz RSL4
  3316 000024C4 AA                      	stosb
  3317 000024C5 E2F8                    	loop RSL2
  3318 000024C7 BF[25370100]            RSL4:	mov edi,screenline-15
  3319 000024CC 033D[F02E0100]          	add edi,[columns]
  3320 000024D2 A1[F42E0100]            	mov eax,[columne]
  3321 000024D7 40                      	inc eax				;start with 1
  3322 000024D8 E8C6FAFFFF              	call IntegerToAscii
  3323 000024DD C6073A                  	mov byte [edi],':'		;delimiter ROW:COL
  3324 000024E0 4F                      	dec edi
  3325 000024E1 A1[2C2F0100]            	mov eax,[linenr]
  3326 000024E6 E8B8FAFFFF              	call IntegerToAscii
  3327 000024EB E881F4FFFF              RSno_lineNr:call StatusLineShow		;now write all at once
  3328                                  	POP_ALL
  3328 000024F0 61                  <1>  popa
  3329 000024F1 F9                      	stc				;error status only important if called via OSError
  3330 000024F2 C3                      	ret
  3331                                  ;-------
  3332                                  ;
  3333                                  ; write an answer prompt into status line
  3334                                  ; (with and without re-initialisation)
  3335                                  ; expecting esi points to ASCIIZ or 0A terminated string
  3336                                  ;
  3337 000024F3 E81A000000              WriteMess9MakeLine:call InitStatusLine
  3338                                  WriteMess9:PUSH_ALL
  3338                              <1> WriteMess9:
  3338 000024F8 60                  <1>  pusha
  3339 000024F9 BF[34370100]            	mov edi,screenline
  3340 000024FE FC                      	cld
  3341 000024FF AC                      WriteMLoop:lodsb
  3342 00002500 3C0A                    	cmp al,LINEFEED			;for error messages
  3343 00002502 7603                    	jbe WriteMEnd
  3344 00002504 AA                      	stosb
  3345 00002505 EBF8                    	jmp short WriteMLoop
  3346 00002507 E865F4FFFF              WriteMEnd:call StatusLineShow
  3347                                  	POP_ALL
  3347 0000250C 61                  <1>  popa
  3348 0000250D E93AFAFFFF              	jmp KursorStatusLine
  3349                                  ;-------
  3350                                  ; a helper for other status line functions:
  3351                                  ; simply init an empty line
  3352                                  ;
  3353                                  InitStatusLine:PUSH_ALL			;simply init an empty line
  3353                              <1> InitStatusLine:
  3353 00002512 60                  <1>  pusha
  3354 00002513 BF[34370100]            	mov edi,screenline
  3355 00002518 B020                    	mov al,SPACECHAR
  3356 0000251A 8B0D[F02E0100]          	mov ecx,[columns]
  3357                                  %ifndef LINUX
  3358                                  	dec ecx				;? FreeBSD
  3359                                  	js ISL				;should never be = -1
  3360                                  %endif
  3361 00002520 FC                      	cld
  3362 00002521 F3AA                    	rep stosb
  3363 00002523 B000                    	mov al,0			;prepare ASCIIZ string
  3364 00002525 AA                      	stosb
  3365                                  ISL:	POP_ALL
  3365                              <1> ISL: 
  3365 00002526 61                  <1>  popa
  3366 00002527 C3                      	ret
  3367                                  ;-------
  3368                                  ; read a file name for block operations
  3369                                  ;
  3370                                  GetBlockName:PUSH_ALL
  3370                              <1> GetBlockName:
  3370 00002528 60                  <1>  pusha
  3371 00002529 BE[7B2F0000]            	mov esi,block
  3372 0000252E B9[C8310100]            	mov ecx,blockpath
  3373 00002533 E8D5F4FFFF              	call InputString0		;cy if empty string
  3374 00002538 9C                      	pushf
  3375 00002539 E818FAFFFF              	call RestKursPos
  3376 0000253E 9D                      	popf
  3377                                  	POP_ALL
  3377 0000253F 61                  <1>  popa
  3378 00002540 C3                      	ret
  3379                                  ;-------
  3380                                  ; helper for NewFile
  3381                                  ;
  3382 00002541 C605[EC3C0100]0A        InitVars:mov byte [text],NEWLINE	;don't touch esi!
  3383 00002548 E8D7EFFFFF              	call Unchg			;i.e. "mov byte [changed],UNCHANGED"
  3384 0000254D E84E000000              	call InitSomeVars		;set eax=0
  3385 00002552 C705[242F0100]-         	mov dword[old],sot
  3385 00002558 [ED3C0100]         
  3386 0000255C 40                      	inc eax				;set eax=1
  3387 0000255D A2[80380100]            	mov byte [VICmdMode],al
  3388 00002562 A3[2C2F0100]            	mov dword [linenr],eax
  3389 00002567 A2[582F0100]            	mov byte [insstat],al
  3390 0000256C C705[C42F0100]00A0-     	mov dword [maxlen],max
  3390 00002574 0F00               
  3391 00002576 C705[602F0100]4552-     	mov dword [error],'ERRO'
  3391 0000257E 524F               
  3392 00002580 C705[642F0100]5220-     	mov dword [error+4],'R   '
  3392 00002588 2020               
  3393 0000258A C705[E8360100]A401-     	mov dword [perms],PERMS
  3393 00002592 0000               
  3394                                  %ifdef SYS_fstat
  3395 00002594 48                      	dec eax
  3396 00002595 48                      	dec eax				;eax == -1 i.e. no changes in fchown
  3397                                  %ifdef UIDGID_WORD			;Linux special
  3398 00002596 A3[F8360100]            	mov [fstatbuf+stat_struc.st_uid],eax	;both: giduid
  3399                                  %else
  3400                                  	mov [fstatbuf+stat_struc.st_gid],eax
  3401                                  	mov [fstatbuf+stat_struc.st_uid],eax
  3402                                  %endif
  3403                                  %endif
  3404 0000259B E9A5EEFFFF              	jmp ShowBl1			;i.e. mov byte [showblock],1
  3405                                  ;-------
  3406                                  InitSomeVars:
  3407 000025A0 31C0                    	xor eax,eax
  3408                                  %ifdef USE_UNDO
  3409 000025A2 A3[EC2E0000]            	mov [undobuffer],eax		;i.e. invalid pointer
  3410 000025A7 C705[E82E0000]-          	mov dword[undoptr],undobuffer+4 ;init to first frame
  3410 000025AD [F02E0000]         
  3411                                  %endif
  3412 000025B1 A3[74380100]            	mov [EmaMark],eax
  3413 000025B6 A3[102F0100]            	mov dword [oldQFpos],eax
  3414 000025BB A2[142F0100]            	mov byte[bereitsges],al
  3415 000025C0 A2[202F0100]            	mov [endeedit],al
  3416 000025C5 A3[6C380100]            InitSV1:mov [EmaKiSize],eax		;do not allow side effects
  3417 000025CA A3[182F0100]            InitSV2:mov [blockbegin],eax		;i.e. NO block valid now
  3418 000025CF A3[1C2F0100]            InitSV3:mov [blockende],eax
  3419 000025D4 C3                      	ret
  3420                                  ;-------
  3421 000025D5 93                      Seek:	xchg ebx,eax			;mov file_descriptor to ebx (xchg is 1 byte only)
  3422 000025D6 6A02                    	push byte 2			;FILE_END
  3423 000025D8 5A                      	pop edx
  3424 000025D9 E8F1020000              	call SeekFile			;end
  3425 000025DE 7809                    	js SeekRet
  3426 000025E0 31D2                    	xor edx,edx			;FILE_BEGIN
  3427 000025E2 50                      	push eax
  3428 000025E3 E8E7020000              	call SeekFile			;home
  3429 000025E8 58                      	pop eax
  3430 000025E9 C3                      SeekRet:ret
  3431                                  ;----------------------------------------------------------------------
  3432                                  ;
  3433                                  ; FIND/REPLACE related stuff
  3434                                  ;
  3435 000025EA BE[A92F0000]            AskForReplace:mov esi,askreplace1
  3436 000025EF E814F4FFFF              	call InputString00
  3437 000025F4 7240                    	jc AskFor_Ex
  3438 000025F6 A3[342F0100]            	mov [suchlaenge],eax
  3439 000025FB BE[B22F0000]            	mov esi,askreplace2
  3440 00002600 B9[C8320100]            	mov ecx,replacetext
  3441 00002605 E803F4FFFF              	call InputString0
  3442 0000260A EB0C                    	jmp short GetOptions		;cy flag is allowed here 18.6.00
  3443 0000260C BE[C42F0000]            AskForFind:mov esi,askfind
  3444 00002611 E8F2F3FFFF              	call InputString00
  3445 00002616 721E                    	jc AskFor_Ex
  3446 00002618 A3[382F0100]            GetOptions:mov [repllaenge],eax
  3447 0000261D F605[A0380100]11        	test byte [mode],WS|NE
  3448 00002624 740F                    	jz GetOpt2
  3449 00002626 BE[682F0000]            	mov esi,optiontext
  3450 0000262B E8C9F3FFFF              	call InputStringWithMessage	;empty string is allowd for std options...
  3451 00002630 E812000000              	call ParseOptions		;...(set in ParseOptions)
  3452 00002635 F8                      GetOpt2:clc
  3453 00002636 7307                    AskFor_Ex:jnc AFE2
  3454 00002638 C605[142F0100]00        	mov byte [bereitsges],0
  3455 0000263F 9C                      AFE2:	pushf
  3456 00002640 E811F9FFFF              	call RestKursPos
  3457 00002645 9D                      	popf
  3458 00002646 C3                      	ret
  3459                                  ;-------
  3460                                  ; check string for 2 possible options: C,c,B,b  (case sensitive & backward)
  3461                                  ;
  3462 00002647 56                      ParseOptions:push esi
  3463 00002648 FC                      	cld
  3464 00002649 BE[C8350100]            	mov esi,optbuffer
  3465 0000264E 6A01                    	push byte 1
  3466 00002650 8F05[3C2F0100]          	pop dword[vorwarts]		;mov dword[vorwarts],1 is longer
  3467 00002656 C605[402F0100]DF        	mov byte[grossklein],0dfh
  3468 0000265D AC                      Scan1:	lodsb
  3469 0000265E 245F                    	and al,5fh			;upper case
  3470 00002660 3C43                    	cmp al,'C'
  3471 00002662 7507                    	jnz notCopt
  3472 00002664 8035[402F0100]20        	xor byte[grossklein],20h	;result 0dfh,   2*C is like not C option
  3473 0000266B 3C42                    notCopt:cmp al,'B'
  3474 0000266D 7506                    	jnz notBopt
  3475 0000266F F71D[3C2F0100]          	neg dword[vorwarts]		;similar 2*B is backward twice i.e. forward
  3476 00002675 08C0                    notBopt:or al,al
  3477 00002677 75E4                    	jnz Scan1
  3478 00002679 5E                      	pop esi
  3479 0000267A C3                      	ret
  3480                                  ;-------
  3481                                  ; the find subroutine itself
  3482                                  ;
  3483 0000267B 89FB                    find2:	mov ebx,edi
  3484 0000267D AC                      find3:	lodsb
  3485 0000267E 08C0                    	or al,al			;=end?
  3486 00002680 7466                    	jz found
  3487 00002682 3C41                    	cmp al,41h
  3488 00002684 7202                    	jb find7
  3489 00002686 20E8                    	and al,ch
  3490 00002688 47                      find7:	inc edi
  3491 00002689 8A0F                    	mov cl,byte [edi]
  3492 0000268B 80F941                  	cmp cl,41h
  3493 0000268E 7202                    	jb find10
  3494 00002690 20E9                    	and cl,ch
  3495 00002692 38C8                    find10:	cmp al,cl
  3496 00002694 74E7                    	jz find3
  3497 00002696 89DF                    	mov edi,ebx
  3498 00002698 8A2D[402F0100]          FindText:mov ch,[grossklein]		;ff or df
  3499 0000269E BE[C8330100]            	mov esi,suchtext
  3500 000026A3 FC                      	cld
  3501 000026A4 AC                      	lodsb
  3502 000026A5 3C41                    	cmp al,41h
  3503 000026A7 7202                    	jb find1
  3504 000026A9 20E8                    	and al,ch			;FIXME: check UTF-8 stuff !!
  3505                                  ;-------
  3506 000026AB 033D[3C2F0100]          find1:	add edi,[vorwarts]		;+1 or -1 (increase or decrease pointer) 
  3507 000026B1 8A0F                    	mov cl,byte [edi]
  3508 000026B3 80F941                  	cmp cl,41h
  3509 000026B6 7202                    	jb find6
  3510 000026B8 20E9                    	and cl,ch
  3511 000026BA 38C8                    find6:	cmp al,cl
  3512 000026BC 74BD                    	je find2
  3513 000026BE 803D[A0380100]04        	cmp byte[mode],PI		;is it Pico? (always searching forward)
  3514 000026C5 7513                    	jnz find_WS			;no, continue
  3515 000026C7 3B3D[8C380100]          	cmp edi,[PicoSearch]		;yes, but did we search from BOF up to here?
  3516 000026CD 7417                    	je notfound			;yes, so we did not found the text
  3517 000026CF 39EF                    	cmp edi,ebp			;no, but did we touch EOF?
  3518 000026D1 72D8                    	jb find1			;no, continue from here
  3519 000026D3 BF[EC3C0100]            	mov edi,sot-1			;yes, let's continue at BOF
  3520 000026D8 EBD1                    	jmp short find1			;loop
  3521 000026DA 39EF                    find_WS:cmp edi,ebp
  3522 000026DC 7708                    	ja notfound
  3523 000026DE 81FF[ED3C0100]          find9:	cmp edi,sot			;this is needed for WStar backward option searching
  3524 000026E4 73C5                    	jnb find1
  3525 000026E6 F9                      notfound:stc
  3526 000026E7 C3                      	ret
  3527 000026E8 89DF                    found:	mov edi,ebx
  3528 000026EA F8                      	clc				;edi points after location
  3529 000026EB C3                      	ret
  3530                                  ;----------------------------------------------------------------------
  3531                                  ;
  3532                                  ; some GENERAL helper functions
  3533                                  ;
  3534                                  ;
  3535                                  ; Get.....ToInteger reads integer value from keyboard (only > 0)
  3536                                  ;
  3537 000026EC 6A07                    GetOctalToInteger:push byte 7		;octal base-1
  3538 000026EE EB02                    	jmp short GATI2
  3539 000026F0 6A09                    GetAsciiToInteger:push byte 9		;decimal base-1
  3540 000026F2 E870F0FFFF              GATI2:	call IsViMode
  3541 000026F7 740A                    	jz ISVI8
  3542 000026F9 E8FBF2FFFF              	call InputStringWithMessage	;eax = al = length
  3543 000026FE E833FFFFFF              	call AskFor_Ex			;repair status line & set cursor pos / preserve flags
  3544 00002703 6A00                    ISVI8:	push byte 0
  3545 00002705 5E                      	pop esi				;preserve flags
  3546 00002706 5B                      	pop ebx				;bl == base-1
  3547 00002707 87CE                    	xchg ecx,esi
  3548 00002709 721E                    	jc AIexit2
  3549 0000270B FC                      	cld
  3550 0000270C AC                      AIload:	lodsb				;eax bit 8..31 are 0
  3551 0000270D 2C30                    	sub al,'0'
  3552 0000270F 7816                    	js AIexit
  3553 00002711 38D8                    	cmp al,bl
  3554 00002713 7712                    	ja AIexit
  3555 00002715 80FB07                  	cmp bl,7			;if base==8
  3556 00002718 7408                    	je GATI3
  3557 0000271A 8D0C89                  	lea ecx,[ecx+4*ecx]
  3558 0000271D 8D0C48                  	lea ecx,[2*ecx+eax]		;mul 10 plus digit
  3559 00002720 EBEA                    	jmp short AIload
  3560 00002722 8D0CC8                  GATI3:	lea ecx,[8*ecx+eax]		;mul 8 plus digit
  3561 00002725 EBE5                    	jmp short AIload
  3562                                  %ifdef ARMCPU
  3563                                  AIexit:	cmp ecx,0			;ret ecx
  3564                                  %else
  3565 00002727 09C9                    AIexit:	or ecx,ecx			;ret ecx
  3566                                  %endif
  3567 00002729 C3                      AIexit2:ret				;CY or ZR if error
  3568                                  ;-------
  3569                                  ;
  3570                                  ; SpacesForTab expects current column in edx
  3571                                  ; returns # spaces up to next tabulated location in AH
  3572                                  ;
  3573 0000272A 51                      SpacesForTab:push ecx
  3574 0000272B 89D0                    	mov eax,edx
  3575 0000272D B108                    	mov cl,TAB
  3576 0000272F 30E4                    	xor ah,ah
  3577 00002731 F6F1                    	div cl
  3578 00002733 F6DC                    	neg ah				;ah = modulo division
  3579 00002735 80C408                  	add ah,TAB			;TAB - pos % TAB
  3580 00002738 59                      	pop ecx
  3581 00002739 C3                      	ret
  3582                                  ;-------
  3583                                  ;
  3584                                  ; GetHelpText returns ecx==size of help text / esi==help text for current edit mode
  3585                                  ;
  3586                                  GetHelpText:
  3587 0000273A BE[F63C0000]            	mov esi,help_ne			;start with last text block...
  3588 0000273F B963020000              	mov ecx,help_ws_size
  3589                                  %ifdef USE_BUILTINHELP
  3590 00002744 B8[A0380100]            	mov eax,mode
  3591 00002749 803810                  	cmp byte [eax],NE
  3592 0000274C 7506                    	jnz NoNe1
  3593 0000274E B979010000              	mov ecx,help_ne_size
  3594 00002753 C3                      	ret
  3595 00002754 29CE                    NoNe1:	sub esi,ecx			;...and sub block by block until we've found it
  3596 00002756 803808                  	cmp byte [eax],VI
  3597 00002759 7410                    	jz GHT
  3598 0000275B 29CE                    	sub esi,ecx
  3599 0000275D 803802                  	cmp byte [eax],EM
  3600 00002760 7409                    	jz GHT
  3601 00002762 29CE                    	sub esi,ecx
  3602 00002764 803804                  	cmp byte [eax],PI
  3603 00002767 7402                    	jz GHT
  3604 00002769 29CE                    	sub esi,ecx
  3605                                  %endif
  3606 0000276B C3                      GHT:	ret
  3607                                  ;-------
  3608                                  ;
  3609                                  ; Check whether user discarded his input
  3610                                  ;
  3611 0000276C BE[A0380100]            CheckUserAbort:mov esi,mode
  3612 00002771 803E01                  	cmp byte[esi],WS
  3613 00002774 7408                    	jz CUAWS
  3614 00002776 803E02                  	cmp byte[esi],EM
  3615 00002779 7406                    	jz CUAEM
  3616 0000277B 3C03                    	cmp al,3			;^C abort
  3617 0000277D C3                      	ret
  3618 0000277E 3C15                    CUAWS:	cmp al,15h			;^U abort
  3619 00002780 C3                      	ret
  3620 00002781 3C07                    CUAEM:	cmp al,7			;^G abort
  3621 00002783 C3                      	ret
  3622                                  ;-------
  3623                                  KeyEditMode:
  3624 00002784 BE[E02F0000]            	mov esi,modetxt
  3625 00002789 E86BF2FFFF              	call InputStringWithMessage	;empty string is allowd for std options...
  3626 0000278E E8C3F7FFFF              	call RestKursPos
  3627 00002793 BE[C8350100]            	mov esi,optbuffer
  3628 00002798 E803FEFFFF              	call InitSomeVars
  3629                                  ;-------
  3630 0000279D B8[A0380100]            SetEditMode:mov eax,mode		;returns Z flag if the mode was changed / NZ else
  3631                                  %ifndef ARMCPU
  3632                                  %ifdef AMD64
  3633                                  	mov ecx,dword [rsi]
  3634                                  %else
  3635 000027A2 8B0E                    	mov ecx,dword [esi]
  3636                                  %endif
  3637                                  %else					;one never knows how aligned esi will be
  3638                                  	mov cl,byte [esi+3]
  3639                                  	shl ecx,8
  3640                                  	mov cl,byte [esi+2]
  3641                                  	shl ecx,8
  3642                                  	mov cl,byte [esi+1]
  3643                                  	shl ecx,8
  3644                                  	mov cl,byte [esi]
  3645                                  %endif
  3646                                  %ifdef W32
  3647                                  	or ecx,020202020h		;convert to lower case
  3648                                  %endif
  3649 000027A4 81F965336E65            	cmp ecx,'e3ne'
  3650 000027AA 7504                    	jnz NoNe
  3651 000027AC C60010                  	mov byte [eax],NE
  3652 000027AF C3                      	ret
  3653 000027B0 81F96533656D            NoNe:	cmp ecx,'e3em'
  3654 000027B6 7504                    	jnz NoEm
  3655 000027B8 C60002                  	mov byte [eax],EM
  3656 000027BB C3                      	ret
  3657 000027BC 81F965337069            NoEm:	cmp ecx,'e3pi'
  3658 000027C2 7504                    	jnz NoPi
  3659 000027C4 C60004                  	mov byte [eax],PI
  3660 000027C7 C3                      	ret
  3661 000027C8 81F965337669            NoPi:	cmp ecx,'e3vi'
  3662 000027CE 7504                    	jnz NoVi
  3663 000027D0 C60008                  	mov byte [eax],VI
  3664 000027D3 C3                      	ret
  3665 000027D4 81F965337773            NoVi:	cmp ecx,'e3ws'
  3666 000027DA 7504                    	jnz NoWs
  3667 000027DC C60001                  	mov byte [eax],WS
  3668 000027DF C3                      	ret
  3669 000027E0 81F965646974            NoWs:	cmp ecx,'edit'
  3670 000027E6 7504                    	jnz NoNe2
  3671 000027E8 C60010                  	mov byte [eax],NE
  3672 000027EB C3                      	ret
  3673 000027EC 81F96D616373            NoNe2:	cmp ecx,'macs'
  3674 000027F2 7504                    	jnz NoEm2
  3675 000027F4 C60002                  	mov byte [eax],EM
  3676 000027F7 C3                      	ret
  3677 000027F8 81F97069636F            NoEm2:	cmp ecx,'pico'
  3678 000027FE 7504                    	jnz NoPi2
  3679 00002800 C60004                  	mov byte [eax],PI
  3680 00002803 C3                      	ret
  3681 00002804 6651                    NoPi2:  push cx
  3682 00002806 66B95F5F                	mov cx,'__'
  3683 0000280A 81F95F5F7669            	cmp ecx,'__vi'
  3684 00002810 6659                    	pop cx
  3685 00002812 7504                    	jnz NoVi2
  3686 00002814 C60008                  	mov byte [eax],VI
  3687 00002817 C3                      	ret
  3688 00002818 6651                    NoVi2:	push cx
  3689 0000281A 66B95F5F                	mov cx,'__'
  3690 0000281E 81F95F5F7773            	cmp ecx,'__ws'
  3691 00002824 6659                    	pop cx
  3692 00002826 7503                    	jnz modeOK
  3693 00002828 C60001                  	mov byte [eax],WS
  3694 0000282B C3                      modeOK:	ret
  3695                                  ;-----------------------------------------------------------------------
  3696                                  ;
  3697                                  ; Oleg's suggestion / Sat Mar 16 17:58:06
  3698                                  ;
  3699                                  %ifdef USE_EXT_MOVE
  3700                                  KeyHome2:cmp byte[edi-1],NEWLINE	
  3701                                  	jz KCQPjmp
  3702                                  	jmp KeyHome
  3703                                  ;-------
  3704                                  KeyEnd2:cmp byte[edi],NEWLINE	
  3705                                  	jz KCQPjmp
  3706                                  	jmp KeyEnd	
  3707                                  ;-------
  3708                                  KeyCtrlQR2:cmp edi,sot
  3709                                  	jz KCQPjmp
  3710                                  	jmp KeyCtrlQR
  3711                                  ;-------
  3712                                  KeyCtrlQC2:cmp edi,ebp
  3713                                  KCQPjmp:jz near KeyCtrlQP
  3714                                  	jmp KeyCtrlQC 
  3715                                  %endif
  3716                                  ;-----------------------------------------------------------------------
  3717                                  %ifdef SYS_kill
  3718 0000282C E825F7FFFF              SigHandler:call RestKursPos
  3719 00002831 BF[00000000]            	mov edi,screenbuffer		;make buffer invalid with something
  3720 00002836 B9A00B0000              	mov ecx,screenbuffer_dwords	;this will force a complete screen redraw
  3721 0000283B FC                      	cld
  3722 0000283C F3AB                    	rep stosd
  3723                                  %endif
  3724                                  ;------- cont
  3725                                  SetTermStruc:
  3726                                  %ifdef W32
  3727                                  	push dword STD_INPUT_HANDLE
  3728                                  	call GetStdHandle
  3729                                  	mov [hin],eax
  3730                                  	push dword STD_OUTPUT_HANDLE
  3731                                  	call GetStdHandle
  3732                                  	mov [hout],eax
  3733                                  	push byte ENABLE_WINDOW_INPUT	;equ 8
  3734                                  	push dword [hin]
  3735                                  	call SetConsoleMode		;Do not use "jmp SetConsoleMode" here
  3736                                  	ret
  3737                                  %else
  3738 0000283E B901540000              	mov ecx,TERMIOS_GET
  3739 00002843 E83C000000              	call IOctlTerminal0
  3740 00002848 89D6                    	mov esi,edx
  3741 0000284A BF[802E0000]            	mov edi,termios
  3742 0000284F 89FA                    	mov edx,edi
  3743 00002851 6A24                    	push byte termios_struc_size	;prepare a copy of original settings
  3744 00002853 59                      	pop ecx
  3745 00002854 FC                      	cld
  3746 00002855 F3A4                    	rep movsb
  3747                                  ;-------
  3748                                  %ifdef LINUX
  3749 00002857 C6421701                	mov byte [edx+termios_struc.c_cc+VMIN],1				;set min=1 ->needed for gnome-terminal
  3750                                  %endif
  3751                                  %ifdef ARMCPU
  3752                                  	and byte [edx+termios_struc.c_lflag+0],(~ICANON & ~ISIG & ~ECHO)	;icanon off, isig (^C) off, echo off
  3753                                  %else
  3754 0000285B 80620CF4                	and TSize [edx+termios_struc.c_lflag+0],(~ICANON & ~ISIG & ~ECHO)	;icanon off, isig (^C) off, echo off
  3755                                  %endif
  3756 0000285F 806201FA                	and byte [edx+termios_struc.c_iflag+1],(~(IXON>>8) & ~(ICRNL>>8))	;ixon off,   icrnl off
  3757 00002863 B902540000              	mov ecx,TERMIOS_SET
  3758 00002868 EB1F                    	jmp short IOctlTerminal		;edx is termios pointer
  3759                                  %endif
  3760                                  ;----------------------------------------------------------------------
  3761                                  %ifdef NEW_CURSOR_MGNT
  3762                                  SetCursorNormal:PUSH_ALL
  3762                              <1> SetCursorNormal:
  3762 0000286A 60                  <1>  pusha
  3763 0000286B B9[E9320000]            	mov ecx,normcurs
  3764 00002870 6A05                    	push byte normcurslen
  3765 00002872 EB08                    	jmp short SCB
  3766                                  SetCursorBlock:PUSH_ALL
  3766                              <1> SetCursorBlock:
  3766 00002874 60                  <1>  pusha
  3767 00002875 B9[DE320000]            	mov ecx,blockcurs		;second argument: pointer to message to write
  3768 0000287A 6A0B                    	push byte blockcurslen		;third argument: message length
  3769 0000287C 5A                      SCB:	pop edx
  3770 0000287D E819000000              	call WriteFile0
  3771                                  	POP_ALL
  3771 00002882 61                  <1>  popa
  3772 00002883 C3                      	ret
  3773                                  %endif
  3774                                  ;----------------------------------------------------------------------
  3775                                  ;
  3776                                  ; INTERFACE to OS kernel
  3777                                  ; we differ between Linux, and and ...
  3778                                  ;
  3779                                  %ifndef W32
  3780 00002884 BA[A42E0000]            IOctlTerminal0:mov edx,termios_orig
  3781 00002889 BB00000000              IOctlTerminal:mov ebx,stdin		;expects EDX termios or winsize structure ptr
  3782                                  %ifdef LIBC
  3783                                  	push edx
  3784                                  	push ecx
  3785                                  	push ebx
  3786                                  	call ioctl
  3787                                  	mov ebx,[_errno]
  3788                                  	mov [ErrNr],ebx
  3789                                  	pop ebx
  3790                                  	pop ecx
  3791                                  	pop edx
  3792                                  	or eax,eax
  3793                                  	ret
  3794                                  %else
  3795 0000288E B036                    	mov al,SYS_ioctl
  3796 00002890 EB41                    	jmp short IntCall		;ECX TCSETS,TCGETS,TIOCGWINSZ
  3797                                  %endif
  3798                                  %endif
  3799                                  ;------
  3800                                  ReadFile0:
  3801                                  %ifdef W32
  3802                                  	;all API: 
  3803                                  	;- direction flag is cleared before and after call
  3804                                  	;- preserves ebx,esi,edi,ebp
  3805                                  	PUSH_ALL
  3806                                  	push dword 0xFFFFFFFF
  3807                                  	push dword [hin]
  3808                                  	call WaitForSingleObject
  3809                                  	POP_ALL
  3810                                  %ifdef W32_EXTENDED_IO
  3811                                  	push ecx			;destr
  3812                                  	push edx			;destr
  3813                                  	push dword w32result
  3814                                  	push byte 1
  3815                                  	push ecx
  3816                                  	push dword [hin]
  3817                                  	call ReadConsoleInputA
  3818                                  	pop edx
  3819                                  	pop ecx
  3820                                  ;-------
  3821                                  	mov ebx,dword [ecx]
  3822                                  	cmp bl,1			;is it a key_event?
  3823                                  	jnz ReadFile0			;no, read new
  3824                                  	mov ebx,dword [ecx+4]
  3825                                  	cmp ebx,1			;is it a keydown event?
  3826                                  	jnz ReadFile0			;no, read new
  3827                                  	;PUSH_ALL
  3828                                  	;push dword [hin]
  3829                                  	;call FlushConsoleInputBuffer
  3830                                  	;POP_ALL
  3831                                  ;-------
  3832                                  	mov ebx,dword [ecx+8]		;virtual key code
  3833                                  	shr ebx,16
  3834                                  ;-------
  3835                                  	cmp ebx,dword VK_SPACE
  3836                                  	jnz Normal0
  3837                                  	test dword [ecx+16],CTRL_PRESSED
  3838                                  	jz Normal0
  3839                                  	mov dword[ecx],0FF00h		;return ascii 00 for EMACS ^SPACE key
  3840                                  	ret
  3841                                  Normal0:cmp ebx,dword VK_DELETE
  3842                                  	ja Normal1
  3843                                  	cmp ebx,dword VK_PRIOR
  3844                                  	jb Normal1
  3845                                  ;-------
  3846                                  	sub bl,VK_PRIOR			;found a cursor key
  3847                                  	mov al,bl
  3848                                  	mov ebx,ScanTable
  3849                                  	xlatb				;translate to terminal value...
  3850                                  	cmp al,DoNo			;...in results 0..9
  3851                                  ReadF0:	jz ReadFile0
  3852                                  	mov ah,0xFE			;marker for a pre-processed cursor key
  3853                                  	mov [ecx],eax
  3854                                  	ret
  3855                                  ;-------
  3856                                  Normal1:mov ebx,dword [ecx+12]		;get ascii char value
  3857                                  	shr ebx,16
  3858                                  	or bl,bl
  3859                                  	jz ReadF0			;no useful ascii char pressed
  3860                                  	mov bh,0xFF
  3861                                  	and dword [ecx+16],LEFT_ALT_PRESSED	;controlkeystate: left ALT key pressed
  3862                                  	jz Normal2
  3863                                  	mov bh,0xFD			;marker for a pre-processed ALT key
  3864                                  Normal2:mov dword[ecx],ebx
  3865                                  	ret
  3866                                  %else					;this way simple input via ReadFile
  3867                                  	mov ebx,[hin]
  3868                                  %endif
  3869                                  %else
  3870 00002892 31DB                    	xor ebx,ebx			;mov ebx,stdin		;file desc
  3871                                  %endif
  3872                                  Read_File:
  3873                                  %ifdef W32
  3874                                  	push ecx			;destr
  3875                                  	push edx			;destr
  3876                                  	push byte 0
  3877                                  	push dword w32result
  3878                                  	push edx			;length
  3879                                  	push ecx			;buffer
  3880                                  	push ebx			;handle
  3881                                  	call ReadFile
  3882                                  	pop edx
  3883                                  	pop ecx
  3884                                  ;-------
  3885                                  	or eax,eax
  3886                                  	jnz ReadFileOkay
  3887                                  	call GetLastError
  3888                                  	mov [ErrNr],eax
  3889                                  	neg eax
  3890                                  	ret
  3891                                  ReadFileOkay:
  3892                                  	mov eax,[w32result]
  3893                                  	or eax,eax			;clear sign flag
  3894                                  	ret
  3895                                  %else
  3896                                  %ifdef BEOS
  3897                                  	push byte SYS_read		;4+X? stack places
  3898                                  	jmp short WFile
  3899                                  %else
  3900                                  %ifdef LIBC
  3901                                  	push edx
  3902                                  	push ecx
  3903                                  	push ebx
  3904                                  	call read
  3905                                  	mov ebx,[_errno]
  3906                                  	mov [ErrNr],ebx
  3907                                  	pop ebx
  3908                                  	pop ecx
  3909                                  	pop edx
  3910                                  	or eax,eax
  3911                                  	ret
  3912                                  %else
  3913 00002894 B003                    	mov al,SYS_read			;system call number (sys_read) ;return read byte EAX
  3914 00002896 EB3B                    	jmp short IntCall		;ebx file / ecx buffer / edx count byte
  3915                                  %endif
  3916                                  %endif
  3917                                  %endif
  3918                                  ;-------
  3919 00002898 31D2                    WriteFile00:xor edx,edx
  3920 0000289A 42                      	inc edx				;mov edx,1	write 1 byte
  3921                                  WriteFile0:
  3922                                  %ifdef W32
  3923                                  	mov ebx,[hout]
  3924                                  %else
  3925 0000289B 31DB                    	xor ebx,ebx			;mov ebx,stdout		;file desc
  3926 0000289D 43                      	inc ebx				;ditto
  3927                                  %endif
  3928                                  Write_File:
  3929                                  %ifdef W32
  3930                                  	push edx			;destr
  3931                                  	push byte 0
  3932                                  	push dword w32result
  3933                                  	push edx			
  3934                                  	push ecx			;buffer
  3935                                  	push ebx			;handle
  3936                                  	call WriteFile
  3937                                  	pop edx
  3938                                  	or eax,eax
  3939                                  	jnz WriteFileOkay
  3940                                  	call GetLastError
  3941                                  	mov [ErrNr],eax
  3942                                  	neg eax
  3943                                  	ret
  3944                                  WriteFileOkay:
  3945                                  	mov eax,[w32result]
  3946                                  	or eax,eax			;clr sign flag
  3947                                  	ret
  3948                                  %else
  3949                                  %ifdef BEOS
  3950                                  	push byte SYS_write
  3951                                  WFile:	pop eax
  3952                                  	call IntRdWr
  3953                                  	nop
  3954                                  	nop
  3955                                  	nop
  3956                                  	nop
  3957                                  	ret
  3958                                  %else
  3959                                  %ifdef LIBC
  3960                                  	push edx
  3961                                  	push ecx
  3962                                  	push ebx
  3963                                  	call write
  3964                                  	mov ebx,[_errno]
  3965                                  	mov [ErrNr],ebx
  3966                                  	pop ebx
  3967                                  	pop ecx
  3968                                  	pop edx
  3969                                  	or eax,eax
  3970                                  	ret
  3971                                  %else
  3972 0000289E B004                    	mov al,SYS_write
  3973 000028A0 EB31                    	jmp short IntCall
  3974                                  %endif
  3975                                  %endif
  3976                                  %endif
  3977                                  ;-------
  3978                                  OpenFile0:
  3979                                  %ifndef BEOS
  3980                                  %ifdef W32
  3981                                  	mov ecx,OPEN_EXISTING
  3982                                  	mov edx,GENERIC_READ
  3983                                  %else
  3984 000028A2 31C9                    	xor ecx,ecx			;i.e O_RDONLY
  3985                                  %endif
  3986                                  %endif
  3987                                  OpenFile:
  3988                                  %ifdef W32
  3989                                  	push byte 0
  3990                                  	push dword FILE_ATTRIBUTE_NORMAL
  3991                                  	push ecx			;"CREATE_ALWAYS" or "OPEN_EXISTING"
  3992                                  	push byte 0
  3993                                  	push byte 0
  3994                                  	push edx			;"GENERIC_WRITE" or "GENERIC_READ"
  3995                                  	push ebx			;filename
  3996                                  	call CreateFileA
  3997                                  	cmp eax,INVALID_HANDLE_VALUE
  3998                                  	jnz OpenFileOkay
  3999                                  	call GetLastError
  4000                                  	mov [ErrNr],eax
  4001                                  	neg eax
  4002                                  OpenFileOkay:ret
  4003                                  %else
  4004                                  %ifdef BEOS
  4005                                  	mov al,SYS_open			;5 stack places
  4006                                  	push edi
  4007                                  	mov edi,0x1A4
  4008                                  	call IntCall
  4009                                  	pop edi
  4010                                  	ret
  4011                                  %else
  4012                                  %ifdef LIBC
  4013                                  	push edx
  4014                                  	push ecx
  4015                                  	push ebx
  4016                                  	call open
  4017                                  	mov ebx,[_errno]
  4018                                  	mov [ErrNr],ebx
  4019                                  	pop ebx
  4020                                  	pop ecx
  4021                                  	pop edx
  4022                                  	or eax,eax
  4023                                  	ret
  4024                                  %else
  4025 000028A4 B005                    	mov al,SYS_open
  4026 000028A6 EB2B                    	jmp short IntCall		;ecx mode / ebx path / edx permissions (if create)
  4027                                  %endif
  4028                                  %endif
  4029                                  %endif
  4030                                  ;-------
  4031                                  CloseFile:
  4032                                  %ifdef W32
  4033                                  	push edx			;destr
  4034                                  	push ecx			;destr
  4035                                  	push ebx			;handle
  4036                                  	call CloseHandle
  4037                                  	pop ecx
  4038                                  	pop edx
  4039                                  	ret
  4040                                  %else
  4041                                  %ifdef LIBC
  4042                                  	push edx			;destr
  4043                                  	push ecx			;destr
  4044                                  	push ebx
  4045                                  	call close
  4046                                  	mov ebx,[_errno]
  4047                                  	mov [ErrNr],ebx
  4048                                  	pop ebx
  4049                                  	pop ecx
  4050                                  	pop edx
  4051                                  	or eax,eax
  4052                                  	ret
  4053                                  %else
  4054 000028A8 B006                    	mov al,SYS_close
  4055 000028AA EB27                    	jmp short IntCall		;ebx is file desc
  4056                                  %endif
  4057                                  %endif
  4058                                  ;-------
  4059                                  %ifdef SYS_readlink
  4060 000028AC B055                    ReadLink:mov al,SYS_readlink
  4061 000028AE EB23                    	jmp short IntCall
  4062                                  %endif
  4063                                  ;-------
  4064                                  %ifdef SYS_fchmod
  4065                                  Fchmod:	
  4066                                  %ifdef LIBC
  4067                                  	push ecx
  4068                                  	push ebx
  4069                                  	call fchmod
  4070                                  	mov ebx,[_errno]
  4071                                  	mov [ErrNr],ebx
  4072                                  	pop ebx
  4073                                  	pop ecx
  4074                                  	or eax,eax
  4075                                  	ret
  4076                                  %else
  4077 000028B0 B05E                    	mov al,SYS_fchmod
  4078 000028B2 EB1F                    	jmp short IntCall
  4079                                  %endif
  4080                                  %endif
  4081                                  ;-------
  4082                                  %ifdef SYS_fstat
  4083 000028B4 B9[EC360100]            Fstat:	mov ecx,fstatbuf
  4084                                  %ifdef LIBC
  4085                                  	push ecx
  4086                                  	push ebx
  4087                                  	call fstat
  4088                                  	mov ebx,[_errno]
  4089                                  	mov [ErrNr],ebx
  4090                                  	pop ebx
  4091                                  	pop ecx
  4092                                  	or eax,eax
  4093                                  	ret
  4094                                  %else
  4095                                  %ifdef FREEBSD				;includes NET-BSD
  4096                                  	mov ax,SYS_fstat
  4097                                  	jmp short IntCall2
  4098                                  %else
  4099 000028B9 B06C                    	mov al,SYS_fstat
  4100 000028BB EB16                    	jmp short IntCall
  4101                                  %endif
  4102                                  %endif
  4103                                  ;-------
  4104                                  ChownFile:
  4105                                  %ifdef LIBC
  4106                                  	push edx
  4107                                  	push ecx
  4108                                  	push ebx
  4109                                  	call fchown
  4110                                  	mov ebx,[_errno]
  4111                                  	mov [ErrNr],ebx
  4112                                  	pop ebx
  4113                                  	pop ecx
  4114                                  	pop edx
  4115                                  	or eax,eax
  4116                                  	ret
  4117                                  %else
  4118 000028BD B05F                    	mov al,SYS_fchown
  4119 000028BF EB12                    	jmp short IntCall
  4120                                  %endif
  4121                                  %endif					;endifdef SYS_fstat
  4122                                  ;-------
  4123                                  RenameFile:
  4124                                  %ifdef W32
  4125                                  	push ebx			;destr
  4126                                  	push ecx			;destr
  4127                                  	push ecx			;for MoveFile
  4128                                  	push ecx
  4129                                  	call DeleteFileA
  4130                                  	push ebx
  4131                                  	call MoveFileA
  4132                                  	pop ecx
  4133                                  	pop ebx
  4134                                  	or eax,eax
  4135                                  	jnz RenameFileOkay
  4136                                  	call GetLastError
  4137                                  	mov [ErrNr],eax
  4138                                  	neg eax
  4139                                  	ret
  4140                                  RenameFileOkay:	
  4141                                  	xor eax,eax
  4142                                  	ret
  4143                                  %else
  4144                                  %ifdef LIBC
  4145                                  	push ecx
  4146                                  	push ebx
  4147                                  	call rename
  4148                                  	mov ebx,[_errno]
  4149                                  	mov [ErrNr],ebx
  4150                                  	pop ebx
  4151                                  	pop ecx
  4152                                  	or eax,eax
  4153                                  	ret
  4154                                  %else
  4155 000028C1 B026                    	mov al,SYS_rename
  4156 000028C3 EB0E                    	jmp short IntCall
  4157                                  %endif
  4158                                  %endif
  4159                                  ;-------
  4160                                  %ifdef SYS_brk
  4161 000028C5 B02D                    SysBrk:	mov al,SYS_brk
  4162 000028C7 EB0A                    	jmp short IntCall		;ebx addr
  4163                                  %endif
  4164                                  ;-------
  4165                                  %ifndef W32
  4166 000028C9 31DB                    Exit:	xor ebx,ebx
  4167                                  Exit2:
  4168                                  %ifdef LIBC
  4169                                  	push ebx
  4170                                  	call _exit
  4171                                  %else
  4172 000028CB B001                    	mov al,SYS_exit
  4173 000028CD EB04                    	jmp short IntCall
  4174                                  %endif
  4175                                  %endif
  4176                                  ;-------
  4177 000028CF 31C9                    SeekFile:xor ecx,ecx			;ecx offset / ebx file / edx method
  4178                                  %ifdef W32
  4179                                  	push edx
  4180                                  	push byte 0
  4181                                  	push ecx
  4182                                  	push ebx
  4183                                  	call SetFilePointer
  4184                                  	cmp eax,0xFFFFFFFF
  4185                                  	jnz SeekFileOkay
  4186                                  	call GetLastError
  4187                                  	mov [ErrNr],eax
  4188                                  	neg eax
  4189                                  SeekFileOkay:ret
  4190                                  %else
  4191                                  %ifdef FREEBSD				;31 October 2005: 64 bit offset  initial for *BSD
  4192                                  	push edi			;ebx=fh/ecx=dummy/edx,esi=offset/edi=where
  4193                                  	push esi
  4194                                  	xor esi,esi
  4195                                  	xor edi,edi
  4196                                  	xchg edx,edi
  4197                                  	mov al,SYS_lseek
  4198                                  	call IntCall
  4199                                  	neg eax
  4200                                  	mov [ErrNr],eax
  4201                                  	neg eax				;set flags also
  4202                                  	pop esi
  4203                                  	pop edi
  4204                                  	ret
  4205                                  %else
  4206                                  %ifdef BEOS
  4207                                  	mov al,SYS_lseek		;4 stack places (using 64 bit for ptr)
  4208                                  	push edi
  4209                                  	push edx
  4210                                  	mov edi,edx
  4211                                  	xor edx,edx
  4212                                  	call IntCall
  4213                                  	pop edx
  4214                                  	pop edi
  4215                                  	ret
  4216                                  %else
  4217                                  %ifdef LIBC
  4218                                  	push edx
  4219                                  %ifdef OPENBSD
  4220                                  	push byte 0
  4221                                  %endif
  4222                                  	push ecx
  4223                                  	push ebx
  4224                                  	call lseek
  4225                                  	mov ebx,[_errno]
  4226                                  	mov [ErrNr],ebx
  4227                                  	pop ebx
  4228                                  	pop ecx
  4229                                  %ifdef OPENBSD
  4230                                  	pop edx
  4231                                  %endif
  4232                                  	pop edx
  4233                                  	or eax,eax
  4234                                  	ret
  4235                                  %else
  4236 000028D1 B013                    	mov al,SYS_lseek		;oldseek =32bit
  4237                                  %endif
  4238                                  %endif
  4239                                  %endif
  4240                                  %endif
  4241                                  ;-------
  4242                                  %ifndef LIBC
  4243                                  %ifndef W32
  4244 000028D3 B400                    IntCall:mov ah,0
  4245 000028D5 98                      IntCall2:cwde
  4246                                  %ifdef BEOS
  4247                                  	push edi
  4248                                  	push byte 0
  4249                                  	push edi
  4250                                  	push edx
  4251                                  	push ecx
  4252                                  	push ebx
  4253                                  	push dword be_ret
  4254                                  	int 25h
  4255                                  be_ret:	pop ebx
  4256                                  	pop ebx
  4257                                  	pop ecx
  4258                                  	pop edx
  4259                                  	pop edi
  4260                                  	pop edi
  4261                                  	mov [ErrNr],eax
  4262                                  	and dword [ErrNr],7Fh
  4263                                  	or eax,eax			;set flags also
  4264                                  	pop edi
  4265                                  %else
  4266                                  %ifdef ATHEOS
  4267                                  	int 80h
  4268                                  	cmp eax,0xFFFFF001
  4269                                  	jae Fru
  4270                                  	or eax,eax
  4271                                  	ret
  4272                                  Fru:	neg eax
  4273                                  	mov [ErrNr],eax
  4274                                  	and dword [ErrNr],7Fh
  4275                                  	neg eax				;set flags also
  4276                                  	ret
  4277                                  %else
  4278                                  %ifdef LINUX
  4279                                  %ifdef AMD64
  4280                                  	push rbx
  4281                                  	push rcx
  4282                                  	push rsi
  4283                                  	push rdi
  4284                                  	xchg rbx,rdi
  4285                                  	xchg rcx,rsi
  4286                                  	xchg rbx,r8
  4287                                  	mov r10,rcx			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  4288                                  	syscall
  4289                                  	pop rdi
  4290                                  	pop rsi
  4291                                  	pop rcx
  4292                                  	pop rbx
  4293                                  %else
  4294 000028D6 CD80                    	int 80h
  4295                                  %endif
  4296                                  %else
  4297                                  	push edi
  4298                                  	push esi
  4299                                  	push edx
  4300                                  	push ecx
  4301                                  	push ebx
  4302                                  %ifdef NETBSD
  4303                                  	push dword nbsdint
  4304                                  %else
  4305                                  	push eax
  4306                                  %endif	
  4307                                  	int 80h
  4308                                  nbsdint:
  4309                                  	pop ebx
  4310                                  	pop ebx
  4311                                  	pop ecx
  4312                                  	pop edx
  4313                                  	pop esi
  4314                                  	pop edi
  4315                                  	jc err
  4316                                  %endif
  4317 000028D8 F7D8                    AfterInt:neg eax
  4318 000028DA A3[5C2F0100]            err:	mov [ErrNr],eax
  4319 000028DF F7D8                    	neg eax				;set flags also
  4320                                  %endif
  4321                                  %endif
  4322 000028E1 C3                      	ret
  4323                                  %endif
  4324                                  %endif
  4325                                  ;-------
  4326                                  %ifdef BEOS
  4327                                  IntRdWr:push edx			;used for Read & Write
  4328                                  	push ecx
  4329                                  	push ebx
  4330                                  	push dword be_ret2
  4331                                  	int 25h
  4332                                  be_ret2:pop ebx
  4333                                  	pop ebx
  4334                                  	pop ecx
  4335                                  	pop edx
  4336                                  	mov [ErrNr],eax
  4337                                  	pop eax
  4338                                  	lea eax,[eax+4]			;add eax,4
  4339                                  	push eax
  4340                                  	mov eax,[ErrNr]
  4341                                  	and dword [ErrNr],7Fh
  4342                                  	or eax,eax			;set flags
  4343                                  	ret
  4344                                  %endif
  4345                                  ;--------------------------------------------------------------------------
  4346                                  %ifdef SYS_select
  4347                                  %ifdef LIBC
  4348                                  Select:	push dword timevalsec
  4349                                  	xor ebx,ebx
  4350                                  	push ebx
  4351                                  	push ebx
  4352                                  	mov ecx,readfds
  4353                                  	push ecx
  4354                                  	inc ebx
  4355                                  	mov byte [ecx],bl
  4356                                  	push ebx
  4357                                  	call select
  4358                                  	push ebx
  4359                                  	mov ebx,[_errno]
  4360                                  	mov [ErrNr],ebx
  4361                                  	pop ebx
  4362                                  	add esp,20
  4363                                  	or eax,eax
  4364                                  	ret
  4365                                  %else
  4366 000028E2 31DB                    Select:	xor ebx,ebx
  4367 000028E4 43                      	inc ebx
  4368 000028E5 B9[A4380100]            	mov ecx,readfds
  4369 000028EA 8819                    	mov byte [ecx],bl
  4370 000028EC 31D2                    	xor edx,edx
  4371 000028EE 31F6                    	xor esi,esi
  4372 000028F0 BF[A8380100]            	mov edi,timevalsec		;points to [0 sec / 0 usec]
  4373 000028F5 B08E                    	mov al,SYS_select
  4374 000028F7 EBDA                    	jmp short IntCall
  4375                                  %endif
  4376                                  %endif
  4377                                  ;-----------------------------------------------------------------------
  4378                                  %ifdef SYS_readlink
  4379 000028F9 B01E                    Utime:	mov al,SYS_utime
  4380 000028FB EBD6                    	jmp short IntCall
  4381                                  %endif
  4382                                  ;-------
  4383                                  %ifdef USE_PIPE
  4384 000028FD B002                    Fork:	mov al,SYS_fork
  4385 000028FF EBD2                    	jmp short IntCall
  4386                                  ;-------
  4387                                  Pipe:	
  4388                                  %ifdef FREEBSD
  4389                                  	mov eax,SYS_pipe
  4390                                  	push edi
  4391                                  	push esi
  4392                                  	push ecx
  4393                                  	push ebx
  4394                                  	int 80h
  4395                                  	pop ebx
  4396                                  	pop ecx
  4397                                  	pop esi
  4398                                  	pop edi
  4399                                  	mov [ebx],eax
  4400                                  	mov [ebx+4],edx
  4401                                  	jmp short AfterInt
  4402                                  %else
  4403 00002901 B02A                    	mov al,SYS_pipe
  4404 00002903 EBCE                    	jmp short IntCall
  4405                                  %endif
  4406                                  ;-------
  4407 00002905 B03F                    Dup2:	mov al,SYS_dup2
  4408 00002907 EBCA                    	jmp short IntCall
  4409                                  ;-------
  4410 00002909 B00B                    Execve:	mov al,SYS_execve
  4411 0000290B EBC6                    	jmp short IntCall
  4412                                  ;-------
  4413 0000290D B072                    Wait4:	mov al,SYS_wait4		;set ecx to buffer!
  4414                                  %ifdef AMD64
  4415                                  	xor rbx,rbx
  4416                                  	dec rbx	
  4417                                  %else
  4418 0000290F 31DB                    	xor ebx,ebx
  4419 00002911 4B                      	dec ebx
  4420                                  %endif
  4421 00002912 31D2                    	xor edx,edx
  4422 00002914 31F6                    	xor esi,esi
  4423 00002916 EBBB                    	jmp short IntCall
  4424                                  ;-------
  4425                                  %endif
  4426                                  Unlink:
  4427                                  %ifdef W32
  4428                                  	push edx
  4429                                  	push ecx
  4430                                  	push ebx
  4431                                  	call DeleteFileA
  4432                                  	pop ebx
  4433                                  	pop ecx
  4434                                  	pop edx
  4435                                  	ret
  4436                                  %else
  4437                                  %ifdef LIBC
  4438                                  	push edx
  4439                                  	push ecx
  4440                                  	push ebx
  4441                                  	call unlink
  4442                                  	mov ebx,[_errno]
  4443                                  	mov [ErrNr],ebx
  4444                                  	pop ebx
  4445                                  	pop ecx
  4446                                  	pop edx
  4447                                  	or eax,eax
  4448                                  	ret
  4449                                  %else
  4450                                  %ifdef BEOS
  4451                                  	mov ecx,ebx
  4452                                  %endif
  4453 00002918 B00A                    	mov al,SYS_unlink
  4454 0000291A EBB7                    	jmp short IntCall		;ebx is file desc
  4455                                  %endif
  4456                                  %endif
  4457                                  ;----------------------------------------------------------------------
  4458                                  %ifdef SYS_kill
  4459 0000291C E82BF6FFFF              KeySuspend:call KursorStatusLine	;simply looks better so
  4460 00002921 6A13                    	push byte SIGSTOP
  4461 00002923 59                      	pop ecx
  4462 00002924 31DB                    	xor ebx,ebx
  4463 00002926 B025                    Kill:	mov al,SYS_kill
  4464 00002928 EBA9                    ICjmp:	jmp short IntCall
  4465                                  ;-------
  4466                                  SetSigHandler:
  4467 0000292A 6A12                    	push byte SIGCONT
  4468 0000292C 5B                      	pop ebx
  4469 0000292D B9[48360100]            	mov ecx,sigaction
  4470                                  %ifdef AMD64
  4471                                  	mov rdx,qword SigHandler
  4472                                  	mov qword [rcx],rdx
  4473                                  	mov qword [rcx+8],4000000h	;flags @ 8
  4474                                  	mov rdx,qword SigRestorer
  4475                                  	mov qword [rcx+16],rdx		;restorer @ 16
  4476                                  	xor edx,edx
  4477                                  	mov esi,8
  4478                                  	mov al,SYS_rt_sigaction
  4479                                  	jmp short ICjmp
  4480                                  ;-------
  4481                                  SigRestorer:mov eax,SYS_rt_sigreturn
  4482                                  	syscall				;thanks to Andi Kleen for info
  4483                                  %else
  4484 00002932 C701[2C280000]          	mov [ecx],dword SigHandler
  4485 00002938 31D2                    	xor edx,edx
  4486                                  %ifdef SIGREST32			;just like on AMD-64 would be:
  4487                                  	mov dword [ecx+8],4000000h
  4488                                  	mov [ecx+12],dword SigRestorer32
  4489                                  %endif
  4490 0000293A B043                    Sigaction:mov al,SYS_sigaction
  4491 0000293C EBEA                    	jmp short ICjmp
  4492                                  ;-------
  4493                                  %ifdef SIGREST32
  4494                                  SigRestorer32:pop eax
  4495                                  	mov eax,119			;sigreturn
  4496                                  	int 80h				;syscall
  4497                                  %endif
  4498                                  %endif
  4499                                  %endif
  4500                                  ;-----------------------------------------------------------------------
  4501                                  ;
  4502                                  ; pipe buffer through child process
  4503                                  ;
  4504                                  %ifdef USE_PIPE
  4505 0000293E E8B1F0FFFF              KeyCtrlKP:call InputStringWithMessage0	;WS, Emacs's, Pico's access to sed|ex pipe
  4506 00002943 9C                      	pushf
  4507 00002944 E80DF6FFFF              	call RestKursPos
  4508 00002949 9D                      	popf
  4509 0000294A 721E                    	jc ExExEx
  4510 0000294C E8ECF3FFFF              KeyVICmdtemp:call CheckENum		;i.e. mov byte [numeriere],1
  4511                                  	PUSH_ALL
  4511 00002951 60                  <1>  pusha
  4512 00002952 BB[432F0000]            	mov ebx,tempfile
  4513 00002957 BE[ED3C0100]            	mov esi,sot
  4514 0000295C 892D[1C2F0100]          	mov [blockende],ebp
  4515 00002962 E813FAFFFF              	call SaveBl3
  4516                                  	POP_ALL
  4516 00002967 61                  <1>  popa
  4517 00002968 7301                    	jnc SaveOK
  4518 0000296A C3                      ExExEx:	ret				;cannot save buffer to tmp file...
  4519                                  SaveOK:					;...this is handled inside SaveBlock, so just return
  4520                                  %ifdef USE_UNDO
  4521 0000296B 31C0                    	xor eax,eax
  4522 0000296D 48                      	dec eax
  4523 0000296E E829040000              	call DataForUndoDelete
  4524                                  %endif
  4525                                  %ifdef CAPTURE_STDERR
  4526 00002973 BB[98380100]            	mov ebx,sedpipeC0
  4527 00002978 E884FFFFFF              	call Pipe
  4528 0000297D 782F                    	js OSerrJmp0
  4529                                  %endif
  4530 0000297F BB[90380100]            	mov ebx,sedpipeB0
  4531 00002984 E878FFFFFF              	call Pipe
  4532 00002989 7823                    	js OSerrJmp0
  4533 0000298B E86DFFFFFF              	call Fork
  4534 00002990 781C                    	js OSerrJmp0
  4535 00002992 09C0                    	or eax,eax
  4536 00002994 0F84B9000000            	jz near ForkChild
  4537                                  ;-------
  4538                                  %ifdef USE_EX_NO_SED
  4539                                  ;
  4540                                  ; This is the UNDEFAULT way using "ex -s" (silent ex).
  4541                                  ; We save the buffer into a tempfile and
  4542                                  ; WRITE the COMMAND (followed by 'wq' command)
  4543                                  ; into a pipe to ex's STDIN.
  4544                                  ; Then we truncate the current edit buffer
  4545                                  ; and read the tempfile just like a WS block.
  4546                                  ;
  4547                                  ; "Anything you want, you got it"
  4548                                  ; "Anything you need, you got it"
  4549                                  ; "Anything at all, you got it, Baby ...." (Jeff Lynne/Roy Orbison/Tom Petty 1989)
  4550                                  ;
  4551                                  	mov ebx,[ebx]			;i.e. sedpipeB0
  4552                                  	call CloseFile			;unused pipe direction READ
  4553                                  OSerrJmp0:js OSerrJmp1
  4554                                  	mov ebx,[sedpipeB1]
  4555                                  ;-------
  4556                                  	xor edx,edx
  4557                                  	mov ecx,optbuffer
  4558                                  	mov esi,ecx
  4559                                  	cld
  4560                                  	dec edx
  4561                                  Bufloop:inc edx
  4562                                  	lodsb
  4563                                  	or al,al
  4564                                  	jnz Bufloop			;count ex cmd length
  4565                                  	call Write_File			;write to ex program
  4566                                  ;-------
  4567                                  	mov ecx,wq_suffix
  4568                                  	mov edx,wq_suffix_len
  4569                                  	call Write_File			;write "wq" string to ex program
  4570                                  	call CloseFile
  4571                                  OSerrJmp1:js OSerrJmp
  4572                                  	mov ecx,optbuffer		;for return status
  4573                                  	push ecx			;new in e3 2.6.1 (needed in Linux 2.6.8-24.10)
  4574                                  	push edi
  4575                                  	call Wait4
  4576                                  	pop edi
  4577                                  	pop ecx
  4578                                  	js OSerrJmp
  4579                                  	mov ecx,[ecx]			;getting return status
  4580                                  	shr ecx,8
  4581                                  	and ecx,0xFF
  4582                                  	mov [ErrNr],ecx
  4583                                  	jnz OSerrJmp
  4584                                  ;-------
  4585                                  	mov ebx,tempfile
  4586                                  	push ebp
  4587                                  	push edi
  4588                                  	mov edi,sot			;truncate old file
  4589                                  	mov ebp,sot
  4590                                  	mov al,LINEFEED
  4591                                  	xchg byte [ebp],al		;EOF marker
  4592                                  	push eax
  4593                                  	call ReadBlock2
  4594                                  	pop eax
  4595                                  	pop edi
  4596                                  	jc preEx_Ex
  4597                                  	pop ebx				;dummy (not restore ebp)
  4598                                  ;-------
  4599                                  	mov ebx,tempfile
  4600                                  	call Unlink
  4601                                  	jns ChkCursPos			;if no Error
  4602                                  ;-------
  4603                                  OSerrJmp:call ChkCursPos		;Error in Wait,Close,...
  4604                                  	jmp near OSerror		;TODO: unlink helper file if exists
  4605                                  preEx_Ex:pop ebp			;Error in ReadBlock
  4606                                  	mov byte[sot],al		;restore pre op values if Read Error
  4607                                  	;continue ChkCursPos
  4608                                  ;
  4609                                  %else	;------------------ DEFAULT WAY -------------------
  4610                                  ;
  4611                                  ; This is the DEFAULT way using stream editor "sed -e".
  4612                                  ; The default way is quite opposite: we save the buffer
  4613                                  ; into a tempfile, then call sed with the operational command
  4614                                  ; given on sed's command line and at last we READ the DATA
  4615                                  ; from sed's output via a STDIN READ pipe.
  4616                                  ;
  4617 0000299A 53                      	push ebx
  4618 0000299B 8B5B04                  	mov ebx,[ebx+4]			;i.e. sedpipeB1
  4619 0000299E E805FFFFFF              	call CloseFile			;unused pipe direction
  4620                                  %ifdef CAPTURE_STDERR
  4621 000029A3 8B1D[9C380100]          	mov ebx,[sedpipeC1]
  4622 000029A9 E8FAFEFFFF              	call CloseFile			;unused pipe direction
  4623                                  %endif
  4624 000029AE 7849                    OSerrJmp0:js OSerrJmp1
  4625 000029B0 5B                      	pop ebx
  4626 000029B1 8B35[C42F0100]          	mov esi,[maxlen]
  4627 000029B7 8B1B                    	mov ebx,[ebx]			;pipe read channel
  4628 000029B9 B9[ED2C0100]            	mov ecx,sot-SEDBLOCK
  4629 000029BE 01CE                    	add esi,ecx
  4630 000029C0 55                      	push ebp
  4631 000029C1 BD[ED3C0100]            	mov ebp,sot
  4632 000029C6 31C0                    	xor eax,eax
  4633 000029C8 E8F8FBFFFF              	call InitSV1			;forbid any side efects
  4634 000029CD BA00100000              ReadPipe:mov edx,SEDBLOCK
  4635 000029D2 01D1                    	add ecx,edx
  4636 000029D4 E8BBFEFFFF              	call Read_File
  4637 000029D9 01C5                    	add ebp,eax			;compute eof
  4638 000029DB 39F5                    	cmp ebp,esi
  4639 000029DD 7310                    	jae ReadOK			;sorry, truncating. FIXME: add a message
  4640 000029DF 39D0                    	cmp eax,edx
  4641 000029E1 74EA                    	jz ReadPipe
  4642 000029E3 81FD[ED3C0100]          	cmp ebp,sot			;if nothing comes back, keep buffer as is
  4643 000029E9 7504                    	jnz ReadOK
  4644 000029EB 5A                      	pop edx
  4645 000029EC 89D5                    	mov ebp,edx
  4646 000029EE 56                      	push esi			;keep stack balanced
  4647 000029EF C645000A                ReadOK:	mov byte [ebp],NEWLINE		;EOF marker
  4648 000029F3 5E                      	pop esi				;dummy
  4649 000029F4 E8AFFEFFFF              	call CloseFile
  4650 000029F9 784E                    OSerrJmp1:js OSerrJmp
  4651                                  %ifdef CAPTURE_STDERR
  4652 000029FB 8B1D[98380100]          	mov ebx,[sedpipeC0]
  4653                                  %ifdef BEEP_IN_VI
  4654 00002A01 B9[B0380100]            	mov ecx,buffercopy
  4655 00002A06 31D2                    	xor edx,edx
  4656 00002A08 42                      	inc edx
  4657 00002A09 E886FEFFFF              	call Read_File
  4658 00002A0E 09C0                    	or eax,eax
  4659 00002A10 7405                    	je NoStdErrMsg
  4660 00002A12 E8EC020000              	call VIBeepForD
  4661                                  %endif
  4662 00002A17 E88CFEFFFF              NoStdErrMsg:call CloseFile		;stderr pipe
  4663                                  %endif
  4664 00002A1C E821E4FFFF              	call SetChg			;i.e. mov byte [changed],CHANGED  (assumption only)
  4665 00002A21 B9[C8350100]            	mov ecx,optbuffer		;for return status
  4666 00002A26 51                      	push ecx			;new in e3 2.6.1 (needed in Linux 2.6.8-24.10)
  4667 00002A27 57                      	push edi
  4668 00002A28 E8E0FEFFFF              	call Wait4
  4669 00002A2D 5F                      	pop edi
  4670 00002A2E 59                      	pop ecx				;ditto new in e3 2.6.1
  4671 00002A2F 7818                    	js OSerrJmp
  4672 00002A31 BB[432F0000]            	mov ebx,tempfile
  4673 00002A36 E8DDFEFFFF              	call Unlink
  4674 00002A3B 780C                    	js OSerrJmp
  4675 00002A3D 0FB64901                	movzx ecx,byte[ecx+1]		;old shr ecx,8 / and ecx,0xFF
  4676 00002A41 890D[5C2F0100]          	mov [ErrNr],ecx
  4677 00002A47 E35D                    	jecxz ChkCursPos
  4678 00002A49 E858000000              OSerrJmp:call ChkCursPos		;TODO: unlink helper file if exists
  4679 00002A4E E990F9FFFF              	jmp near OSerror
  4680                                  %endif
  4681                                  ;----------------------------------------------------------------------
  4682 00002A53 8B1B                    ForkChild:mov ebx,[ebx]			;i.e. sedpipeB0
  4683 00002A55 31C9                    	xor ecx,ecx
  4684                                  %ifdef USE_EX_NO_SED
  4685                                  	call Dup2			;capturing STDIN
  4686                                  	js FCError
  4687                                  	mov ebx,[sedpipeB1]
  4688                                  	call CloseFile			;unused pipe direction STDOUT
  4689                                  	js FCError
  4690                                  	mov ebx,expath
  4691                                  	mov ecx,exargs
  4692                                  %else
  4693 00002A57 E84CFEFFFF              	call CloseFile			;unused pipe direction STDIN
  4694 00002A5C 7840                    	js FCError
  4695 00002A5E 8B1D[94380100]          	mov ebx,[sedpipeB1]
  4696 00002A64 41                      	inc ecx
  4697 00002A65 E89BFEFFFF              	call Dup2			;capturing STDOUT
  4698 00002A6A 7832                    	js FCError
  4699                                  %ifdef CAPTURE_STDERR
  4700 00002A6C 8B1D[98380100]          	mov ebx,[sedpipeC0]
  4701 00002A72 E831FEFFFF              	call CloseFile			;unused pipe direction
  4702 00002A77 41                      	inc ecx
  4703 00002A78 8B1D[9C380100]          	mov ebx,[sedpipeC1]
  4704 00002A7E E882FEFFFF              	call Dup2			;capturing STDERR
  4705 00002A83 7819                    	js FCError
  4706                                  %endif
  4707 00002A85 BB[5C2F0000]            	mov ebx,sedpath
  4708 00002A8A B9[482F0000]            	mov ecx,sedargs
  4709                                  %endif
  4710 00002A8F 31D2                    	xor edx,edx			;no env
  4711 00002A91 E873FEFFFF              	call Execve
  4712 00002A96 6A1F                    	push byte ERRNOEXEC
  4713 00002A98 5B                      	pop ebx				;set error
  4714 00002A99 E92DFEFFFF              FCex:	jmp near Exit2			;in case of error
  4715 00002A9E 8B1D[5C2F0100]          FCError:mov ebx,[ErrNr]
  4716 00002AA4 EBF3                    	jmp short FCex
  4717                                  %endif ;USE_PIPE
  4718                                  ;----------------------------------------------------------------------
  4719                                  ;
  4720                                  ; care about cursor pos
  4721                                  ;
  4722                                  ChkCursPos:
  4723                                  %ifdef UTF8
  4724 00002AA6 47                      	inc edi
  4725 00002AA7 4F                      CCloopUTF8:dec edi
  4726                                  %ifdef UTF8RTS
  4727                                  	cmp byte [isUTF8],0
  4728                                  	je noUTF_Z
  4729                                  %endif
  4730 00002AA8 8A07                    	mov al,byte [edi]
  4731 00002AAA 24C0                    	and al,0C0h
  4732 00002AAC 3C80                    	cmp al,080h
  4733 00002AAE 74F7                    	je CCloopUTF8
  4734                                  noUTF_Z:
  4735                                  %endif
  4736 00002AB0 39EF                    	cmp edi,ebp			;never let run cursor outside buffer
  4737 00002AB2 7602                    	jbe CCP
  4738 00002AB4 89EF                    	mov edi,ebp
  4739 00002AB6 81FF[ED3C0100]          CCP:	cmp edi,sot
  4740 00002ABC 7305                    	jae CCP2
  4741 00002ABE BF[ED3C0100]            	mov edi,sot
  4742 00002AC3 C3                      CCP2:	ret
  4743                                  ;----------------------------------------------------------------------
  4744                                  ;
  4745                                  ; copy file to a real backup file (for sym linked files only)
  4746                                  ;
  4747                                  ; expecting ebx==filepath
  4748                                  ;	    ecx==bakpath
  4749                                  ;
  4750                                  %ifdef SYS_readlink
  4751                                  CopyToBackup:PUSH_ALL
  4751                              <1> CopyToBackup:
  4751 00002AC4 60                  <1>  pusha
  4752 00002AC5 51                      	push ecx			;backup file path later needed for Utime call
  4753 00002AC6 51                      	push ecx
  4754 00002AC7 E8D6FDFFFF              	call OpenFile0
  4755 00002ACC 96                      	xchg esi,eax			;save handle to copy of original file
  4756 00002ACD B941020000              	mov ecx,O_WRONLY_CREAT_TRUNC
  4757 00002AD2 8B15[E8360100]          	mov edx,[perms]
  4758 00002AD8 5B                      	pop ebx				;handle to backupfile
  4759 00002AD9 E8C6FDFFFF              	call OpenFile
  4760 00002ADE 93                      	xchg ebx,eax
  4761 00002ADF 8B0D[F8360100]          	mov ecx,[fstatbuf+stat_struc.st_uid]
  4762                                  %ifdef UIDGID_WORD                      ;Linux special
  4763 00002AE5 89CA                    	mov edx,ecx
  4764 00002AE7 C1EA10                  	shr edx,16
  4765 00002AEA 0FB7C9                  	movzx ecx,cx			;OLD and ecx,0xffff
  4766                                  %else
  4767                                  	mov edx,[fstatbuf+stat_struc.st_gid]
  4768                                  %endif
  4769 00002AED E8CBFDFFFF              	call ChownFile
  4770                                  ;-------
  4771 00002AF2 31FF                    	xor edi,edi			;init eof indicator
  4772 00002AF4 53                      copylop:push ebx
  4773 00002AF5 89F3                    	mov ebx,esi			;saved orig file handle
  4774 00002AF7 B9[00000000]            	mov ecx,screenbuffer		;used as copy buffer
  4775 00002AFC BA00100000              	mov edx,4096
  4776 00002B01 E88EFDFFFF              	call Read_File
  4777 00002B06 5B                      	pop ebx				;backup file handle
  4778                                  	;js...
  4779 00002B07 39D0                    	cmp eax,edx
  4780 00002B09 7401                    	jz notready
  4781 00002B0B 47                      	inc edi				;eof found
  4782 00002B0C B9[00000000]            notready:mov ecx,screenbuffer
  4783 00002B11 89C2                    	mov edx,eax			;write read count of byte
  4784 00002B13 E886FDFFFF              	call Write_File
  4785                                  	;js...
  4786 00002B18 09FF                    	or edi,edi			;eof ?
  4787 00002B1A 74D8                    	jz copylop
  4788                                  ;-------
  4789 00002B1C E887FDFFFF              	call CloseFile			;ready: close backup file
  4790 00002B21 89F3                    	mov ebx,esi
  4791 00002B23 E880FDFFFF              	call CloseFile			;close original file
  4792 00002B28 5B                      	pop ebx				;original file path
  4793 00002B29 B9[2C370100]            	mov ecx,accesstime		;i.e. a data structure of 2* 32 bit
  4794 00002B2E E8C6FDFFFF              	call Utime			;set change time
  4795                                  	POP_ALL
  4795 00002B33 61                  <1>  popa
  4796 00002B34 C3                      	ret
  4797                                  %endif
  4798                                  ;----------------------------------------------------------------------
  4799                                  ; recursive descent parser for very SIMPLE math calc within the text:
  4800                                  ;              1234+56*78=
  4801                                  ; place cursor ^<--here and press   ^KN  ^QC  ^XN  #   ^K
  4802                                  ;			(for one of WS   PI   EM   VI  NE modes)
  4803                                  ; 		this should insert the result of 5602 into text.
  4804                                  ;
  4805                                  ; Use values +-0, 0.000001 ,... up to 999999999999.999999 
  4806                                  ; and + - * / 
  4807                                  ; and ( )
  4808                                  ; and r  (for using the last result in next calculation)
  4809                                  ; and p  =3.141593
  4810                                  ;
  4811                                  KeyCtrlKN:
  4812                                  %ifdef USE_MATH
  4813 00002B35 FC                      	cld				;preserve ebp,edi!
  4814 00002B36 DBE3                    	fninit
  4815 00002B38 89FE                    	mov esi,edi
  4816 00002B3A 8925[B83C0100]          	mov [stackptr],esp
  4817 00002B40 31C0                    	xor eax,eax
  4818 00002B42 A3[B03C0100]            	mov [level],eax
  4819 00002B47 A3[B43C0100]            	mov [ptlevel],eax
  4820 00002B4C E8C3000000              	call Recurs0
  4821 00002B51 DD3D[BC3C0100]          	fnstsw [x87]
  4822 00002B57 8025[BC3C0100]1F        	and byte[x87],1Fh		;any exception flags?
  4823 00002B5E 0F8599010000            GErr:	jnz near isErr
  4824 00002B64 FF0D[B03C0100]          	dec dword[level]		;stack balanced?
  4825 00002B6A 75F2                    	jnz GErr
  4826 00002B6C 31C0                    	xor eax,eax
  4827 00002B6E 3B05[B43C0100]          	cmp eax,[ptlevel]		;all parenthesis closed?
  4828 00002B74 75E8                    	jnz GErr
  4829 00002B76 4E                      NoAllgFehl:dec esi
  4830 00002B77 89F7                    	mov edi,esi			;up to here we have read
  4831 00002B79 AC                      	lodsb
  4832 00002B7A 3C3D                    	cmp al,'='
  4833 00002B7C 7408                    	jz EquChar
  4834 00002B7E B03D                    	mov al,'='
  4835 00002B80 E80A020000              	call OutChar
  4836 00002B85 4F                      	dec edi
  4837 00002B86 47                      EquChar:inc edi
  4838 00002B87 DD15[C83C0100]          	fst qword[lastresult87]		;carry last result for further calc
  4839 00002B8D DD05[362F0000]          	fld qword[factor]
  4840 00002B93 DEC9                    	fmulp st1
  4841 00002B95 DF35[BC3C0100]          	fbstp [x87]
  4842 00002B9B 6A0C                    	push byte 12			;12 digits
  4843 00002B9D 59                      	pop ecx				
  4844 00002B9E 30F6                    	xor dh,dh			;flag for suppressing leading 0
  4845 00002BA0 8D35[C53C0100]          	lea esi,[x87+9]			;9 BCD data byte and sign
  4846 00002BA6 FD                      	std
  4847 00002BA7 AC                      	lodsb
  4848 00002BA8 08C0                    	or al,al
  4849 00002BAA 790B                    	jns plus
  4850 00002BAC 3C80                    	cmp al,0x80
  4851 00002BAE 75AE                    	jnz GErr
  4852 00002BB0 B02D                    	mov al,'-'
  4853 00002BB2 E8D8010000              	call OutChar
  4854 00002BB7 E83D000000              plus:	call OutHlp
  4855 00002BBC 08F6                    	or dh,dh
  4856 00002BBE 7507                    	jnz dec_dig
  4857 00002BC0 B030                    	mov al,'0'
  4858 00002BC2 E8C8010000              	call OutChar
  4859                                  ;-------
  4860 00002BC7 BE[BC3C0100]            dec_dig:mov esi,x87
  4861 00002BCC 31DB                    	xor ebx,ebx
  4862 00002BCE 6A03                    	push byte 3
  4863 00002BD0 59                      	pop ecx
  4864 00002BD1 FC                      	cld
  4865 00002BD2 AC                      dlop:	lodsb
  4866 00002BD3 88C2                    	mov dl,al
  4867 00002BD5 240F                    	and al,0fh
  4868 00002BD7 750C                    	jnz nonull
  4869 00002BD9 43                      	inc ebx
  4870 00002BDA 88D0                    	mov al,dl
  4871 00002BDC C0E804                  	shr al,4
  4872 00002BDF 7504                    	jnz nonull
  4873 00002BE1 43                      	inc ebx
  4874 00002BE2 E2EE                    isnul2:	loop dlop
  4875 00002BE4 C3                      	ret				;no decimal digits: ready
  4876                                  ;-------
  4877 00002BE5 6A06                    nonull:	push byte 6			;6 decimal digits
  4878 00002BE7 59                      	pop ecx
  4879 00002BE8 29D9                    	sub ecx,ebx
  4880 00002BEA B6FF                    	mov dh,0xff			;now do not suppress 0
  4881 00002BEC B02E                    	mov al,'.'
  4882 00002BEE E89C010000              	call OutChar
  4883 00002BF3 8D35[BE3C0100]          	lea esi,[x87+2]			;decimal digits pos
  4884 00002BF9 FD                      OutHlp:	std
  4885 00002BFA AC                      	lodsb
  4886 00002BFB 88C2                    	mov dl,al
  4887 00002BFD C0E804                  	shr al,4
  4888 00002C00 E882010000              	call OutNumber
  4889 00002C05 49                      	dec ecx
  4890 00002C06 E30B                    	jecxz xret
  4891 00002C08 88D0                    	mov al,dl
  4892 00002C0A 240F                    	and al,0fh
  4893 00002C0C E876010000              	call OutNumber
  4894 00002C11 E2E6                    	loop OutHlp
  4895 00002C13 C3                      xret:	ret
  4896                                  ;-------
  4897 00002C14 B02B                    Recurs0:mov al,'+'
  4898 00002C16 50                      RecursPars:push eax			;op code
  4899 00002C17 C605[E83C0100]00        	mov byte[signctl],0		;last token was an opcode
  4900 00002C1E AC                      RecConti:lodsb
  4901 00002C1F 3C0A                    	cmp al,LINEFEED			;EOL?
  4902 00002C21 7406                    	jz short RRR			;jz RecReturn
  4903 00002C23 3C29                    	cmp al,')'
  4904 00002C25 7474                    	jz short RRet2
  4905 00002C27 3C3D                    	cmp al,'='			;end of task?
  4906 00002C29 7476                    RRR:	jz short RecReturn
  4907 00002C2B 3C21                    	cmp al,'!'			;white space?
  4908 00002C2D 72EF                    	jb short RecConti
  4909 00002C2F 803D[E83C0100]00        	cmp byte[signctl],0		;last was opcode?
  4910 00002C36 7516                    	jnz short CheckNP		;sign is allowed after opcode only
  4911 00002C38 3C2B                    	cmp al,'+'
  4912 00002C3A 740A                    	jz short rPlus
  4913 00002C3C 3C2D                    	cmp al,'-'
  4914 00002C3E 750E                    	jnz short CheckNP
  4915 00002C40 FE05[E83C0100]          	inc byte[signctl]		;2 for minus 
  4916 00002C46 FE05[E83C0100]          rPlus:	inc byte[signctl]		;1 for plus
  4917 00002C4C EBD0                    	jmp short RecConti		;continue
  4918                                  
  4919 00002C4E FF35[E83C0100]          CheckNP:push dword [signctl]		;we need that for numbers and parenthesis
  4920 00002C54 3C28                    	cmp al,'('
  4921 00002C56 750D                    	jnz short CheckNum
  4922 00002C58 FF05[B43C0100]          	inc dword[ptlevel]		;increase nesting level
  4923 00002C5E E8B1FFFFFF              	call Recurs0			;compute term instead of parse number
  4924 00002C63 EB15                    	jmp short fromP
  4925 00002C65 3C30                    CheckNum:cmp al,'0'
  4926 00002C67 724E                    	jb short noNumber
  4927 00002C69 3C72                    	cmp al,'r'			;last Result
  4928 00002C6B 7436                    	jz short isLastRes
  4929 00002C6D 3C70                    	cmp al,'p'			;pi 3.141593
  4930 00002C6F 743A                    	jz short isPi
  4931 00002C71 3C39                    	cmp al,'9'
  4932 00002C73 7740                    	ja short isErr2
  4933 00002C75 E86F000000              	call Number
  4934 00002C7A 58                      fromP:	pop eax				;signctl on stack
  4935 00002C7B 3C02                    	cmp al,2
  4936 00002C7D 7502                    	jnz short isPlus
  4937 00002C7F D9E0                    	FCHS				;parenthesis or number is negative
  4938 00002C81 C605[E83C0100]01        isPlus:	mov byte[signctl],1		;last token was a number (or parenthesis)
  4939 00002C88 8A0424                  	mov al,[esp]			;our opcode
  4940 00002C8B 3C2B                    	cmp al,'+'
  4941 00002C8D 748F                    	jz short RecConti
  4942 00002C8F 3C2D                    	cmp al,'-'
  4943 00002C91 750E                    	jnz short RecReturn
  4944 00002C93 C604242B                	mov byte[esp],'+'		;adding negative value
  4945 00002C97 D9E0                    	FCHS
  4946 00002C99 EB83                    RecCon2:jmp short RecConti
  4947                                  ;-------
  4948 00002C9B FF0D[B43C0100]          RRet2:	dec dword[ptlevel]
  4949 00002CA1 58                      RecReturn:pop eax
  4950 00002CA2 C3                      	ret
  4951                                  ;-------
  4952 00002CA3 DD05[C83C0100]          isLastRes:fld qword[lastresult87]
  4953 00002CA9 EB02                    	jmp short isPi2
  4954 00002CAB D9EB                    isPi:	fldpi
  4955 00002CAD FF05[B03C0100]          isPi2:	inc dword[level]
  4956 00002CB3 EBC5                    	jmp short fromP
  4957 00002CB5 EB46                    isErr2:	jmp short isErr
  4958                                  ;-------
  4959 00002CB7 59                      noNumber:pop ecx			;due above "push dword [signctl]" (we don't need it here)
  4960 00002CB8 8D6424F0                	lea esp,[esp-16]
  4961 00002CBC D91C24                  	fstp dword [esp]
  4962 00002CBF E852FFFFFF              	call RecursPars
  4963 00002CC4 D90424                  	fld dword [esp]
  4964 00002CC7 8D642410                	lea esp,[esp+16]
  4965 00002CCB FF0D[B03C0100]          	dec dword[level]
  4966 00002CD1 3C2A                    	cmp al,'*'
  4967 00002CD3 7504                    	jnz noMul
  4968 00002CD5 DEC9                    	FMULP st1
  4969 00002CD7 EBC0                    	jmp short RecCon2
  4970 00002CD9 3C2F                    noMul:	cmp al,'/'
  4971 00002CDB 7504                    	jnz noDiv
  4972 00002CDD DEF1                    	FDIVRP st1
  4973 00002CDF EBB8                    	jmp short RecCon2
  4974 00002CE1 3C2B                    noDiv:	cmp al,'+'
  4975 00002CE3 7518                    	jnz isErr			;not one of * / +
  4976 00002CE5 DEC1                    	FADDP st1
  4977 00002CE7 EBB8                    	jmp short RecReturn
  4978                                  ;-------
  4979 00002CE9 D9EE                    Number:	FLDZ
  4980 00002CEB DF35[BC3C0100]          	FBSTP [x87]			;init buffer
  4981 00002CF1 6A0C                    	push byte 12			;read 13 chars  (up to 12 digits)
  4982 00002CF3 59                      	pop ecx
  4983 00002CF4 E885000000              num_ctr:call DigitHlp
  4984 00002CF9 7215                    	jc int_end
  4985 00002CFB E2F7                    	loop num_ctr			;error if >12 digits
  4986                                  isErr:	
  4987 00002CFD 8B25[B83C0100]          	mov esp,[stackptr]		;restore stack pos for math calc
  4988                                  %endif ;USE_MATH
  4989                                  %ifdef BEEP_IN_VI
  4990                                  VIBeepForD:PUSH_ALL
  4990                              <1> VIBeepForD:
  4990 00002D03 60                  <1>  pusha
  4991                                  %ifdef W32
  4992                                  	push byte 0
  4993                                  	call MessageBeep
  4994                                  %else
  4995 00002D04 B9[BD320000]            	mov ecx,BeepChar
  4996 00002D09 E88AFBFFFF              	call WriteFile00
  4997                                  %endif
  4998                                  	POP_ALL
  4998 00002D0E 61                  <1>  popa
  4999                                  %endif
  5000 00002D0F C3                      	ret
  5001                                  ;-------
  5002                                  %ifdef USE_MATH
  5003 00002D10 57                      int_end:push edi			;****
  5004 00002D11 F7D9                    	neg ecx
  5005 00002D13 8D490D                  	lea ecx,[ecx+13]
  5006 00002D16 51                      	push ecx			;stor # of integer digits
  5007 00002D17 FF05[B03C0100]          	inc dword[level]
  5008 00002D1D 4E                      	dec esi				;num_ctr loop has read 1 too much
  5009 00002D1E 89F2                    	mov edx,esi			;position we have read so far
  5010 00002D20 3CFE                    	cmp al,('.'-'0')
  5011 00002D22 7529                    	jnz integers
  5012 00002D24 46                      	inc esi
  5013 00002D25 8D3D[BE3C0100]          	lea edi,[x87+2]			;start of decimal places
  5014 00002D2B B103                    	mov cl,3			;6/2 decimal places
  5015 00002D2D FC                      dec_ctr:cld
  5016 00002D2E E84B000000              	call DigitHlp
  5017 00002D33 7215                    	jc decend
  5018 00002D35 C0E004                  	shl al,4
  5019 00002D38 88C3                    	mov bl,al
  5020 00002D3A 8807                    	mov [edi],al			;important if abort at digit 1,3,5
  5021 00002D3C E83D000000              	call DigitHlp
  5022 00002D41 7207                    	jc decend	
  5023 00002D43 00D8                    	add al,bl
  5024 00002D45 FD                      	std
  5025 00002D46 AA                      	stosb
  5026 00002D47 E2E4                    	loop dec_ctr			;if >6 decimal places it will run into error later
  5027 00002D49 46                      	inc esi
  5028 00002D4A 4E                      decend:	dec esi
  5029 00002D4B 87D6                    	xchg edx,esi			;edx where later to continue scanning
  5030                                  ;-------
  5031 00002D4D 59                      integers:pop ecx			;ecx # of integer digits
  5032 00002D4E 4E                      	dec esi				;esi where integer places are
  5033 00002D4F 8D3D[BF3C0100]          	lea edi,[x87+3]			;start of integer part
  5034 00002D55 FD                      intloop:std
  5035 00002D56 AC                      	lodsb
  5036 00002D57 2C30                    	sub al,'0'
  5037 00002D59 88C3                    	mov bl,al
  5038 00002D5B 49                      	dec ecx
  5039 00002D5C E308                    	jecxz h2
  5040 00002D5E AC                      	lodsb
  5041 00002D5F 2C30                    	sub al,'0'
  5042 00002D61 C0E004                  	shl al,4
  5043 00002D64 00D8                    	add al,bl
  5044 00002D66 FC                      h2:	cld
  5045 00002D67 AA                      	stosb
  5046 00002D68 E302                    	jecxz h3
  5047 00002D6A E2E9                    	loop intloop
  5048 00002D6C DF25[BC3C0100]          h3:	FBLD [x87]
  5049 00002D72 DD05[362F0000]          	FLD qword [factor]
  5050 00002D78 DEF9                    	fdivp st1
  5051 00002D7A 89D6                    	mov esi,edx			;pointer for continued reading
  5052 00002D7C 5F                      	pop edi				;****
  5053 00002D7D C3                      	ret
  5054                                  ;-------
  5055 00002D7E AC                      DigitHlp:lodsb
  5056 00002D7F 2C30                    	sub al,'0'
  5057 00002D81 7203                    	jb dret
  5058 00002D83 3C0A                    	cmp al,10
  5059 00002D85 F5                      	cmc
  5060 00002D86 C3                      dret:	ret				;return: al=value / cy if error
  5061                                  ;-------
  5062 00002D87 38F0                    OutNumber:cmp al,dh			;flag set?
  5063 00002D89 7410                    	jz OCret
  5064 00002D8B 0430                    	add al,'0'
  5065 00002D8D B6FF                    	mov dh,0xff			;set flag
  5066 00002D8F 56                      OutChar:push esi
  5067 00002D90 52                      	push edx
  5068 00002D91 51                      	push ecx
  5069 00002D92 E866E0FFFF              	call NormChar
  5070 00002D97 59                      	pop ecx
  5071 00002D98 5A                      	pop edx
  5072 00002D99 5E                      	pop esi
  5073 00002D9A 43                      	inc ebx
  5074                                  %endif
  5075 00002D9B C3                      OCret:	ret
  5076                                  ;----------------------------------------------------------------------
  5077                                  %ifdef USE_UNDO
  5078                                  %define ROLLBACK
  5079                                  %undef ROLLBACK
  5080                                  ; Undo is organized in frames on a ringbuffer stack
  5081                                  ;
  5082                                  ; FRAME_AAAAprevFRAME_BBBBprevCURRENT_EMPTY_FRAME
  5083                                  ; ^         v   ^          v  v
  5084                                  ; |         |   |          |  |
  5085                                  ;  \-------/     \--------/|  |
  5086                                  ;                          |  v
  5087                                  ;                          v  [undoptr] == next free frame
  5088                                  ;                          [undoptr]-4  == begin of previous frame
  5089                                  ;
  5090                                  ; there are 3 types of frames: DELETE,INSERT,OVERWRITE, see details below:
  5091                                  ;
  5092                                  DataForUndoDelete:
  5093                                  ;
  5094                                  ; Data collector for "delete" by PUSHING undo data into a frame on the undo stack,
  5095                                  ; growing to higher addresses, using a variable size (16+X byte) data structure:
  5096                                  ; 
  5097                                  ; |12345679|--WHERE-|--SIZE--|<data>....X       |PREV-PTR|--NEXT--| ......
  5098                                  ; |  =sign |  =edi  |  =eax  |                  |        |        |
  5099                                  ; |        |        |        |                  |        |        |
  5100                                  ; | edx+0  | edx+4  | edx+8  | edx+12           |edx+16+X|edx+20+X| <----- ADDRESSES
  5101                                  ;                                                         ^^^^^^^^
  5102                                  ;                                                         NEXT_undo_frame_address stored in [undoptr]
  5103                                  ; If the data size is > undobuffer size we have to 
  5104                                  ; save the data otherwise, i.e. in a file:
  5105                                  ; |1234567B|--WHERE-|--SIZE--|<PREV-PTR|--NEXT--| ......
  5106                                  ; |  =sign |  =edi  |  =eax  |         |        |
  5107                                  ; |        |        |        |         |        |
  5108                                  ; | edx+0  | edx+4  | edx+8  | edx+12  |edx+16  | <----- ADDRESSES
  5109                                  ;
  5110 00002D9C 803D[E02E0000]01        	cmp byte [enter_undo],1		;do not collect undo data if within undo operation
  5111 00002DA3 74F6                    	jz OCret
  5112 00002DA5 3DE8FF0000              	cmp eax,undobuffer_size-24
  5113                                  	PUSH_ALL
  5113 00002DAA 60                  <1>  pusha
  5114 00002DAB 7249                    	jb DFok
  5115                                  ;-------
  5116                                  	PUSH_ALL
  5116 00002DAD 60                  <1>  pusha
  5117 00002DAE 8B1D[E42E0000]          	mov ebx,[last_undo_file]
  5118 00002DB4 09DB                    	or ebx,ebx
  5119 00002DB6 740E                    	jz noundo_info
  5120 00002DB8 813B7B563412            	cmp dword [ebx],0x01234567B
  5121 00002DBE 7506                    	jnz noundo_info
  5122 00002DC0 C70300000000            	mov dword [ebx],0		;only ONE external undo info allowed, thus destroy older
  5123 00002DC6 BE[ED3C0100]            noundo_info:mov esi,sot			;i.e. huge undo data
  5124 00002DCB 892D[1C2F0100]          	mov [blockende],ebp
  5125 00002DD1 BB[3E2F0000]            	mov ebx,tempfile2
  5126 00002DD6 E89FF5FFFF              	call SaveBl3
  5127                                  	POP_ALL
  5127 00002DDB 61                  <1>  popa
  5128                                  ;-------
  5129 00002DDC E82E010000              	call InitUndoFrame0
  5130 00002DE1 C7027B563412            	mov dword [edx],0x01234567B	;2nd signature for "delete"
  5131 00002DE7 8915[E42E0000]          	mov [last_undo_file],edx
  5132 00002DED 89E8                    	mov eax,ebp
  5133 00002DEF 2D[ED3C0100]            	sub eax,sot			;ebp -sot == size of buffer
  5134 00002DF4 EB5A                    	jmp short OVWdata
  5135                                  ;-------	
  5136                                  DFok:					;i.e. small undo data
  5137 00002DF6 89C1                    	mov ecx,eax			;extra data size / size of copy
  5138 00002DF8 E814010000              	call InitUndoFrame
  5139 00002DFD C70279563412            	mov dword [edx],0x012345679	;signature for "delete", later undo will insert data again
  5140 00002E03 897A04                  	mov [edx+4],edi			;where
  5141 00002E06 894208                  	mov [edx+8],eax			;how much
  5142 00002E09 89FE                    	mov esi,edi			;source is inside editor text buffer
  5143 00002E0B 8D7A0C                  	lea edi,[edx+12]		;destination of copy
  5144 00002E0E FC                      	cld
  5145 00002E0F F3A4                    	rep movsb
  5146 00002E11 A1[E82E0000]            	mov eax,[undoptr]		;this frame...
  5147 00002E16 8907                    	mov [edi],eax			;... is the prev frame for the next one
  5148 00002E18 8D4704                  	lea eax,[edi+4]			;eax: now the new frame address
  5149 00002E1B EB3F                    	jmp short DFex
  5150                                  ;-------
  5151                                  DataForUndoOverwrite:
  5152                                  ;
  5153                                  ; Data collector for "overwrite" by PUSHING data on a stack, 
  5154                                  ; growing to higher addresses, using a data structure like in DataForUndoInsert
  5155                                  ;
  5156                                  	PUSH_ALL
  5156 00002E1D 60                  <1>  pusha
  5157 00002E1E E8EC000000              	call InitUndoFrame0
  5158 00002E23 C7027A563412            	mov dword [edx],0x01234567A	;signature for "overwrite", later undo will restore
  5159 00002E29 8B07                    	mov eax,[edi]			;fetch overwritten char
  5160 00002E2B EB23                    	jmp short OVWdata
  5161                                  DataForUndoXchange:
  5162                                  ;
  5163                                  ; Data collector for "Emacs ^T" by PUSHING data on a stack, 
  5164                                  ; growing to higher addresses, using a data structure like in DataForUndoOverWrite
  5165                                  ;
  5166                                  	PUSH_ALL
  5166 00002E2D 60                  <1>  pusha
  5167 00002E2E E8DC000000              	call InitUndoFrame0
  5168 00002E33 C70277563412            	mov dword [edx],0x012345677	;signature for "xchg", later undo will restore
  5169 00002E39 EB15                    	jmp short OVWdata
  5170                                  ;------
  5171                                  DataForUndoInsert:
  5172                                  ;
  5173                                  ; Data collector for "insert" by PUSHING data on a stack,
  5174                                  ; growing to higher addresses, using a fixed size (16 byte) data structure:
  5175                                  ; 
  5176                                  ; |12345678|--WHERE-|--SIZE--|PREV-PTR|--NEXT--| .........
  5177                                  ; |  =sign |  =edi  |  =eax  |        |        |     
  5178                                  ; |        |        |        |        |        |
  5179                                  ; | edx+0  | edx+4  | edx+8  | edx+12 |edx+16  |edx+20  <----- ADDRESSES
  5180                                  ;                                      ^^^^^^^^
  5181                                  ;                                      NEXT_undo_frame_address stored in [undoptr]
  5182                                  ;
  5183                                  ; An analogue data structure is used for DataForUndoOverwrite:
  5184                                  ; |1234567A|--WHERE-|--CHAR--|PREV-PTR|--NEXT--| .........
  5185                                  ;
  5186                                  ;
  5187 00002E3B 803D[E02E0000]01        	cmp byte [enter_undo],1		;do not collect undo data if within undo operation
  5188 00002E42 741E                    	jz DFUI
  5189                                  	PUSH_ALL
  5189 00002E44 60                  <1>  pusha
  5190 00002E45 E8C5000000              	call InitUndoFrame0
  5191 00002E4A C70278563412            	mov dword [edx],0x012345678	;signature for "insert", later undo will delete that data
  5192 00002E50 897A04                  OVWdata:mov [edx+4],edi			;where
  5193 00002E53 894208                  	mov [edx+8],eax			;how much chars (or the character itself)
  5194 00002E56 89520C                  	mov [edx+12],edx		;this frame is the prev frame for the next one
  5195 00002E59 8D4210                  	lea eax,[edx+16]		;address of next frame
  5196 00002E5C A3[E82E0000]            DFex:	mov [undoptr],eax		;let undoptr point to next frame 
  5197                                  	POP_ALL
  5197 00002E61 61                  <1>  popa
  5198 00002E62 C3                      DFUI:	ret
  5199                                  ;----------------------------------------------------------------------
  5200                                  ;
  5201                                  ; this subroutine is bound to one of the keys like ^KU and
  5202                                  ; will POP any UNDO data from the undo stack using 3 types of undo frames
  5203                                  ;
  5204 00002E63 C605[E02E0000]01        KeyUndo:mov byte [enter_undo],1		;do not log dele/insert when in undo mode
  5205 00002E6A 89FB                    	mov ebx,edi			;for case of error
  5206 00002E6C 8B15[E82E0000]          	mov edx,[undoptr]
  5207 00002E72 8B52FC                  	mov edx,[edx-4]			;get begin of previos frame
  5208 00002E75 09D2                    	or edx,edx
  5209 00002E77 741E                    	jz NotAv			;no date available
  5210 00002E79 31C9                    	xor ecx,ecx			;read signature into ecx and destroy sign
  5211 00002E7B 870A                    	xchg ecx,[edx]			;(destroying is neccessary because it's a ring buffer)
  5212 00002E7D 8B4208                  	mov eax,[edx+8]			;data size or character itself
  5213 00002E80 8B7A04                  	mov edi,[edx+4]			;position
  5214 00002E83 81E977563412            	sub ecx,0x12345677
  5215 00002E89 7410                    	jz UndoOfXchange
  5216 00002E8B 49                      	dec ecx
  5217 00002E8C 742B                    	jz UndoOfInsert
  5218 00002E8E 49                      	dec ecx
  5219 00002E8F 7413                    	jz UndoOfDelete
  5220 00002E91 49                      	dec ecx
  5221 00002E92 7421                    	jz UndoOfOverwrite
  5222 00002E94 49                      	dec ecx
  5223 00002E95 7429                    	jz ReReadBuffer
  5224 00002E97 89DF                    NotAv:	mov edi,ebx			;abort UNDO: no valid signature found
  5225                                  %ifdef ROLLBACK
  5226                                  	xor edx,edx
  5227                                  %endif
  5228 00002E99 EB68                    	jmp short KUret
  5229                                  ;-------
  5230 00002E9B 8A07                    UndoOfXchange:mov al,byte [edi]
  5231 00002E9D 8647FF                  	xchg byte [edi-1],al
  5232 00002EA0 8807                    	mov byte [edi],al
  5233 00002EA2 EB50                    	jmp short KUexit
  5234                                  ;-------
  5235 00002EA4 8D720C                  UndoOfDelete:lea esi,[edx+12]		;source ptr for deleted <data>
  5236 00002EA7 56                      	push esi
  5237 00002EA8 E86FF1FFFF              	call InsertByte			;get some space.....
  5238 00002EAD 5E                      	pop esi				;source ptr (somewhere inside UNDO frame)
  5239 00002EAE E826F2FFFF              	call MoveBlock			;....and move <data> back into text
  5240 00002EB3 EB3F                    	jmp short KUexit
  5241                                  ;-------
  5242 00002EB5 8807                    UndoOfOverwrite:mov byte [edi],al
  5243 00002EB7 EB3B                    	jmp short KUexit
  5244                                  ;-------
  5245 00002EB9 E831F1FFFF              UndoOfInsert:call DeleteByte
  5246 00002EBE EB34                    	jmp short KUexit
  5247                                  ;-------
  5248 00002EC0 8DA8[ED3C0100]          ReReadBuffer:lea ebp,[eax+sot]		;compute eof pointer
  5249 00002EC6 C645000A                	mov byte [ebp],NEWLINE		;eof-marker
  5250 00002ECA 50                      	push eax			;size
  5251 00002ECB BB[3E2F0000]            	mov ebx,tempfile2
  5252 00002ED0 E8CDF9FFFF              	call OpenFile0
  5253 00002ED5 5A                      	pop edx				;size
  5254 00002ED6 781C                    	js KUexit
  5255 00002ED8 93                      	xchg ebx,eax			;file handle
  5256 00002ED9 B9[ED3C0100]            	mov ecx,sot
  5257 00002EDE E8B1F9FFFF              	call Read_File
  5258 00002EE3 780F                    	js KUexit
  5259 00002EE5 E8BEF9FFFF              	call CloseFile
  5260 00002EEA BB[3E2F0000]            	mov ebx,tempfile2
  5261 00002EEF E824FAFFFF              	call Unlink
  5262                                  ;-------
  5263 00002EF4 8B15[E82E0000]          KUexit:	mov edx,[undoptr]		;switch to undo frame before (i.e. POP)
  5264 00002EFA 8B52FC                  	mov edx,[edx-4]			;the prev frame....
  5265 00002EFD 8915[E82E0000]          	mov [undoptr],edx		;...is now current frame
  5266 00002F03 C605[E02E0000]00        KUret:	mov byte [enter_undo],0		;leave UNDO status
  5267 00002F0A E92EEEFFFF              KUjmp:	jmp CheckENum			;renumbering because we have changed the cursor position
  5268                                  ;-------
  5269                                  %ifdef ROLLBACK
  5270                                  RollBack:call KeyUndo
  5271                                  	or edx,edx
  5272                                  	jnz RollBack
  5273                                  	jmp short KUjmp	
  5274                                  %endif
  5275                                  ;----------------------------------------------------------------------
  5276                                  ;
  5277                                  ; This inits the frame data pointer into edx.
  5278                                  ; If there is not enough space we will wrap around to buffer begin and adjust [undoptr]:
  5279                                  ;
  5280                                  ;BEFORE WRAP:
  5281                                  ;|******any_frame**********any_frame********any_frame*******PREV-PTR---------------| buffer_end
  5282                                  ;                                                                   <---too less--->
  5283                                  ;                                                                   ^^^^^^^^^
  5284                                  ;                                                                   [undoptr]
  5285                                  ;NOW AFTER WRAP:
  5286                                  ;|PREV-PTR<-space_for_new_frame->ame********any_frame*******PREV-PTR---------------| buffer_end
  5287                                  ;         ^^^^^^^^               ^^^^^^^^^^ ^^^^^^^^^         
  5288                                  ;        [undoptr]               invalid     last ok frame
  5289                                  ;                               frame part
  5290                                  ;
  5291 00002F0F 31C9                    InitUndoFrame0:xor ecx,ecx		;no extra data
  5292 00002F11 8B15[E82E0000]          InitUndoFrame:mov edx,[undoptr]		;get current frame
  5293 00002F17 BE[D42E0100]            	mov esi,undobuffer_end-24
  5294 00002F1C 29CE                    	sub esi,ecx			;extra data if exist
  5295 00002F1E 39F2                    	cmp edx,esi			;low memory?
  5296 00002F20 7213                    	jb IUFret			;leave if far away from buffer end 
  5297                                  ;-------
  5298 00002F22 8B5AFC                  	mov ebx,[edx-4]			;fetch PREV-PTR frame address @[undoptr-4]
  5299 00002F25 BA[EC2E0000]            	mov edx,undobuffer		;wrap around: now BACK AT BUFFER BEGIN...
  5300 00002F2A 891A                    	mov [edx],ebx			;store prev data frame pointer just before new frame
  5301 00002F2C 8D5204                  	lea edx,[edx+4]			;=new frame begins here at undobuffer+4
  5302 00002F2F 8915[E82E0000]          	mov [undoptr],edx
  5303 00002F35 C3                      IUFret:	ret
  5304                                  %endif
  5305                                  %ifdef UTF8RTS
  5306                                  KeyUTF8switch:not byte [isUTF8]
  5307                                  	ret
  5308                                  %endif
  5309                                  ;----------------------------------------------------------------------
  5310                                  %ifdef LINUX
  5311                                  %ifndef CRIPLED_ELF
  5312                                  section .data
  5313                                  bits 32
  5314                                  %endif
  5315                                  %endif
  5316                                  ;
  5317                                  ; CONSTANT DATA AREA
  5318                                  ;
  5319                                  %ifdef USE_MATH
  5320 00002F36 0000000080842E41        factor		dq 1000000.0
  5321                                  %endif
  5322 00002F3E 6533232300              tempfile2 	db 'e3##',0		;tempfile (FIXME: use PID for name)
  5323                                  %ifdef USE_PIPE
  5324 00002F43 6533242400              tempfile 	db 'e3$$',0		;tempfile (FIXME: use PID for name)
  5325                                  %ifdef USE_EX_NO_SED
  5326                                  %ifndef AMD64
  5327                                  exargs		dd expath
  5328                                  		dd minus_s
  5329                                  		dd tempfile
  5330                                  		dd 0
  5331                                  %else
  5332                                  exargs		dq expath
  5333                                  		dq minus_s
  5334                                  		dq tempfile
  5335                                  		dq 0
  5336                                  %endif
  5337                                  expath		db EX_PATH,0
  5338                                  minus_s		db '-s',0
  5339                                  wq_suffix	db LINEFEED,'wq',LINEFEED
  5340                                  wq_suffix_len	equ $-wq_suffix
  5341                                  %else
  5342                                  %ifndef AMD64
  5343 00002F48 [5C2F0000]              sedargs		dd sedpath		;this way default
  5344 00002F4C [652F0000]              		dd minus_e
  5345 00002F50 [C8350100]              		dd optbuffer
  5346 00002F54 [432F0000]              		dd tempfile
  5347 00002F58 00000000                		dd 0
  5348                                  %else
  5349                                  sedargs		dq sedpath		;this way default
  5350                                  		dq minus_e
  5351                                  		dq optbuffer
  5352                                  		dq tempfile
  5353                                  		dq 0
  5354                                  %endif
  5355 00002F5C 2F62696E2F73656400      sedpath		db SEDPATH,0
  5356                                  %ifndef PERLPIPE
  5357 00002F65 2D6500                  minus_e		db '-e',0
  5358                                  %else
  5359                                  minus_e		db '-pe',0
  5360                                  %endif
  5361                                  ;
  5362                                  %endif
  5363                                  %endif
  5364                                  ;
  5365 00002F68 4F50543F20432F4200      optiontext	db 'OPT? C/B',0
  5366 00002F71 46494C454E414D453A-     filename	db 'FILENAME:',0
  5366 00002F7A 00                 
  5367 00002F7B 2020204E414D453A00      block		db '   NAME:',0
  5368 00002F84 534156452041533A00      saveas		db 'SAVE AS:',0
  5369 00002F8D 202020534156453A00      filesave	db '   SAVE:',0
  5370 00002F96 534156453F20596E6C-     asksave		db 'SAVE? Ynl',0
  5370 00002F9F 00                 
  5371 00002FA0 534156453F20596E00      asksave2	db 'SAVE? Yn',0
  5372 00002FA9 5245504C4143453A00      askreplace1	db 'REPLACE:',0
  5373 00002FB2 524520574954483A00      askreplace2	db 'RE WITH:',0
  5374 00002FBB 474F204C494E453A00      asklineno	db 'GO LINE:',0
  5375 00002FC4 205345415243483A00      askfind		db ' SEARCH:',0
  5376 00002FCD 5E51204F4354414C3A-     asknumber	db '^Q OCTAL:',0
  5376 00002FD6 00                 
  5377 00002FD7 6D6F64652045583A00      extext		db 'mode EX:',0
  5378 00002FE0 534554204D4F444500      modetxt		db 'SET MODE',0
  5379                                  %define DoNo 10
  5380                                  
  5381                                  ScanTable: 	;another xlat table containing offsets in jumptab1 table
  5382                                  %ifdef W32
  5383                                  	db 2	;VK_PRIOR  = Scan 21h (pgup)
  5384                                  	db 7	;VK_NEXT   = Scan 22h (pgdn)
  5385                                  	db 5	;(end)
  5386                                  	db 0	;(home)
  5387                                  	db 3	;(left)
  5388                                  	db 1	;(up)
  5389                                  	db 4	;(right)
  5390                                  	db 6	;(dn)
  5391                                  	db DoNo	;29h ignored 
  5392                                  	db DoNo	;2ah ditto
  5393                                  	db DoNo	;2bh ditto
  5394                                  	db DoNo	;2ch ditto
  5395                                  	db 8	;VK_INSERT = Scan 2dh (insert)
  5396                                  	db 9	;VK_DELETE = Scan 2eh (del)
  5397                                  %else
  5398 00002FE9 0A                      	db DoNo	;		esc[0~
  5399 00002FEA 00                      	db 0	;keyHome	esc[1~
  5400 00002FEB 08                      	db 8	;keyIns		esc[2~
  5401 00002FEC 09                      	db 9	;keyDel		esc[3~
  5402 00002FED 05                      	db 5	;keyEnd		esc[4~
  5403 00002FEE 02                      	db 2	;keyPgUp	esc[5~
  5404 00002FEF 07                      	db 7	;KeyPDn		esc[6~
  5405 00002FF0 00                      	db 0	;keyHome	esc[7~
  5406 00002FF1 05                      	db 5	;keyEnd		esc[8~
  5407                                  		;---------------------
  5408                                  %ifdef QNX
  5409                                  	db 8	;keyIns		esc[@
  5410                                  %endif
  5411 00002FF2 01                      	db 1	;keyUp		esc[A
  5412 00002FF3 06                      	db 6	;keyDown	esc[B
  5413 00002FF4 04                      	db 4	;keyRight	esc[C
  5414 00002FF5 03                      	db 3	;keyLeft	esc[D
  5415 00002FF6 0A                      	db DoNo	;		esc[E
  5416 00002FF7 05                      	db 5	;keyEnd		esc[F
  5417 00002FF8 07                      	db 7	;keyPgDn	esc[G
  5418 00002FF9 00                      	db 0	;keyHome	esc[H
  5419                                  %ifndef LINUX
  5420                                  	db 2	;keyPUp		esc[I
  5421                                  	db DoNo	;		esc[J
  5422                                  	db DoNo	;		esc[K
  5423                                  	db 8	;keyIns		esc[L
  5424                                  %endif
  5425                                  %ifdef QNX
  5426                                  	db DoNo	;		esc[M
  5427                                  	db DoNo	;		esc[M
  5428                                  	db DoNo	;		esc[O
  5429                                  	db 9	;		esc[P
  5430                                  	db DoNo	;		esc[Q
  5431                                  	db DoNo	;		esc[R
  5432                                  	db DoNo	;		esc[S
  5433                                  	db DoNo	;		esc[T
  5434                                  	db 7	;		esc[U
  5435                                  	db 2	;		esc[V
  5436                                  	db DoNo	;		esc[W
  5437                                  	db DoNo	;		esc[X
  5438                                  	db 5	;		esc[Y
  5439                                  %endif
  5440                                  STsize equ ($-ScanTable)
  5441                                  %endif
  5442                                  ;----------------------------------------------------------------------
  5443                                  EmaAltTable: 	;another xlat table containing offsets in jumptab1 table
  5444 00002FFA 12                      	db 12h	;'B'
  5445 00002FFB 0A                      	db DoNo	;'C'
  5446 00002FFC 0A                      	db DoNo	;'D'
  5447 00002FFD 0A                      	db DoNo	;'E'
  5448 00002FFE 13                      	db 13h	;'F'
  5449 00002FFF 11                      	db 11h	;'G'
  5450 00003000 3D                      	db 3Dh	;'H'	Help!
  5451 00003001 0A                      	db DoNo	;'I'
  5452 00003002 0A                      	db DoNo	;'J'
  5453 00003003 0A                      	db DoNo	;'K'
  5454 00003004 0A                      	db DoNo	;'L'
  5455 00003005 0A                      	db DoNo	;'M'
  5456 00003006 0A                      	db DoNo	;'N'
  5457 00003007 0A                      	db DoNo	;'O'
  5458 00003008 0A                      	db DoNo	;'P'
  5459 00003009 0A                      	db DoNo	;'Q'
  5460 0000300A 0A                      	db DoNo	;'R'
  5461 0000300B 0A                      	db DoNo	;'S'
  5462 0000300C 0A                      	db DoNo	;'T'
  5463 0000300D 0A                      	db DoNo	;'U'
  5464 0000300E 02                      	db 2 	;'V'
  5465 0000300F 27                      	db 27h	;'W'
  5466 00003010 3E                      	db 3Eh	;'X'
  5467                                  ATsize equ ($-EmaAltTable)
  5468                                  ;----------------------------------------------------------------------
  5469                                  %define Beep 0x4E
  5470 00003011 4E                      VIcmdTable:db Beep;0
  5471 00003012 4E                      	db Beep	;1
  5472 00003013 02                      	db 2	;^B PageUp
  5473 00003014 4E                      	db Beep	;3
  5474 00003015 36                      	db 36h	;^D half PageUp
  5475 00003016 4E                      	db Beep	;5
  5476 00003017 07                      	db 7	;^F PageDn
  5477 00003018 4E                      	db Beep	;7
  5478 00003019 03                      	db 3	;^H KeyLeft
  5479 0000301A 4E                      	db Beep	;9
  5480 0000301B 06                      	db 6	;^J KeyDown
  5481 0000301C 4E                      	db Beep	;11
  5482 0000301D 4E                      	db Beep	;12
  5483 0000301E 06                      	db 6	;^M KeyDown
  5484 0000301F 4E                      	db Beep	;^N
  5485 00003020 4E                      	db Beep	;^O
  5486 00003021 4E                      	db Beep	;^P
  5487 00003022 4E                      	db Beep	;^Q
  5488 00003023 4E                      	db Beep	;^R
  5489 00003024 4E                      	db Beep	;^S
  5490 00003025 4E                      	db Beep	;^T
  5491 00003026 37                      	db 37h 	;^U
  5492 00003027 4E                      	db Beep	;22
  5493 00003028 4E                      	db Beep	;23
  5494 00003029 4E                      	db Beep	;24
  5495 0000302A 4E                      	db Beep	;25
  5496 0000302B 51                      	db 51h	;^Z
  5497 0000302C 4E                      	db Beep	;27
  5498 0000302D 4E                      	db Beep	;28
  5499 0000302E 4E                      	db Beep	;29
  5500 0000302F 4E                      	db Beep	;30
  5501 00003030 4E                      	db Beep	;31
  5502 00003031 04                      	db 4	;' ' KeyRight
  5503 00003032 4E                      	db Beep	;33
  5504 00003033 4E                      	db Beep	;34
  5505 00003034 4F                      	db 4fh 	;35  Numerics
  5506 00003035 05                      	db 5	;'$' KeyEnd
  5507 00003036 4E                      	db Beep	;37
  5508 00003037 4E                      	db Beep	;38
  5509 00003038 50                      	db 50h	; '
  5510 00003039 4E                      	db Beep	;40
  5511 0000303A 4E                      	db Beep	;41
  5512 0000303B 4E                      	db Beep	;42
  5513 0000303C 06                      	db 6	;'+' KeyDown
  5514 0000303D 4E                      	db Beep	;44
  5515 0000303E 01                      	db 1	;'-' KeyUp
  5516 0000303F 4E                      	db Beep	;46
  5517 00003040 39                      	db 39h	;'/' Search
  5518 00003041 00                      	db 0	;'0' KeyHome
  5519 00003042 44                      	db 44h	;'1' 1G BOF
  5520 00003043 4E                      	db Beep	;'2'
  5521 00003044 4E                      	db Beep	;'3'
  5522 00003045 4E                      	db Beep	;'4'
  5523 00003046 4E                      	db Beep	;'5'
  5524 00003047 4E                      	db Beep	;'6'
  5525 00003048 4E                      	db Beep	;'7'
  5526 00003049 4E                      	db Beep	;'8'
  5527 0000304A 4E                      	db Beep	;'9'
  5528 0000304B 2C                      	db 2Ch	;':' ex mode
  5529 0000304C 3E                      	db 3Eh	;';' e3 special command: QUICK leave vi mode :-)  press  e3ws, e3em, e3pi, e3ne
  5530 0000304D 4E                      	db Beep	;'<'
  5531 0000304E 4E                      	db Beep	;'='
  5532 0000304F 4E                      	db Beep	;'>'
  5533 00003050 3A                      	db 3Ah	;'?' search backw
  5534 00003051 4E                      	db Beep	;'@'
  5535 00003052 2E                      	db 2Eh	;'A'
  5536 00003053 12                      	db 12h	;'B' left word
  5537 00003054 4B                      	db 4Bh	;'C' Change rest of line 
  5538 00003055 30                      	db 30h	;'H' First LIne
  5539 00003056 4E                      	db Beep	;'E'
  5540 00003057 4E                      	db Beep	;'F'
  5541 00003058 0F                      	db 0Fh	;'G' EOF
  5542 00003059 4D                      	db 4Dh	;'J' Join lines
  5543 0000305A 33                      	db 33h	;'I' switch to insert mode
  5544 0000305B 4E                      	db Beep	;'N'
  5545 0000305C 4C                      	db 4Ch	;'D' Delete rest of line (not unlike ^QY in WStar)
  5546 0000305D 4E                      	db Beep	;'T'
  5547 0000305E 52                      	db 52h	;'M'
  5548 0000305F 31                      	db 31h	;'L' Last Line
  5549 00003060 32                      	db 32h	;'O' Open Line
  5550 00003061 3C                      	db 3Ch	;'P' Paste
  5551 00003062 4E                      	db Beep	;'Q'
  5552 00003063 34                      	db 34h	;'R' overwrite
  5553 00003064 40                      	db 40h	;'S' kill +insmode
  5554 00003065 4E                      	db Beep	;'K'
  5555 00003066 4E                      	db Beep	;'U'
  5556 00003067 4E                      	db Beep	;'V'
  5557 00003068 13                      	db 13h	;'W' next word
  5558 00003069 3F                      	db 3fh	;'X' del left
  5559 0000306A 4E                      	db Beep	;'Y'
  5560 0000306B 41                      	db 41h	;'Z'
  5561 0000306C 4E                      	db Beep	;'['
  5562 0000306D 4E                      	db Beep	;'\'
  5563 0000306E 4E                      	db Beep	;']'
  5564 0000306F 38                      	db 38h	;'^' KeyFirstChar
  5565 00003070 4E                      	db Beep	;'_'
  5566 00003071 4E                      	db Beep	;'`'
  5567 00003072 2D                      	db 2Dh	;'a' append (KeyLeft plus insert mode)
  5568 00003073 12                      	db 12h	;'b' left word
  5569 00003074 4E                      	db Beep	;'c'
  5570 00003075 03                      	db 3	;'h' KeyLeft
  5571 00003076 43                      	db 43h	;'e'
  5572 00003077 4E                      	db Beep	;'f'
  5573 00003078 4E                      	db Beep	;'g'
  5574 00003079 06                      	db 6	;'j' KeyDown
  5575 0000307A 2B                      	db 2Bh	;'i' switch to insert mode
  5576 0000307B 4E                      	db Beep	;'n'
  5577 0000307C 35                      	db 35h	;'d' delete
  5578 0000307D 4E                      	db Beep	;'t'
  5579 0000307E 45                      	db 45h	;'m' set the one and only marker 'a'
  5580 0000307F 04                      	db 4	;'l' KeyRight
  5581 00003080 2F                      	db 2Fh	;'o' Open Line
  5582 00003081 3B                      	db 3Bh	;'p' Paste
  5583 00003082 4E                      	db Beep	;'q'
  5584 00003083 4A                      	db 4Ah	;'r' repl one char
  5585 00003084 4E                      	db Beep	;'s'
  5586 00003085 01                      	db 1	;'k' KeyUp
  5587                                  %ifdef USE_UNDO
  5588 00003086 53                      	db 53h	;'u'	UNDO
  5589                                  %else
  5590                                  	db Beep	;'u'
  5591                                  %endif
  5592 00003087 4E                      	db Beep	;'v'
  5593 00003088 13                      	db 13h	;'w' next word
  5594 00003089 09                      	db 9	;'x' KeyDel
  5595 0000308A 46                      	db 46h	;'y'
  5596 0000308B 42                      	db 42h	;'z' center line z.
  5597                                  VIsize equ ($-VIcmdTable)
  5598                                  ;----------------------------------------------------------------------
  5599 0000308C 0A                      Ktable	db DoNo	;^K@	xlatb table for making pseudo-scancode
  5600 0000308D 0A                      	db DoNo	;^ka
  5601 0000308E 24                      	db 24h	;^kb	24h for example points to KeyCtrlKB function offset
  5602 0000308F 15                      	db 15h	;^kc
  5603 00003090 0D                      	db 0dh	;^kd
  5604 00003091 0A                      	db DoNo	;^ke	DoNo means SimpleRet i.e. 'do nothing'
  5605 00003092 0A                      	db DoNo	;^kf
  5606 00003093 0A                      	db DoNo	;^kg
  5607 00003094 1D                      	db 1dh	;^kh
  5608 00003095 0A                      	db DoNo	;^ki
  5609 00003096 0A                      	db DoNo	;^kj
  5610 00003097 14                      	db 14h	;^kk
  5611 00003098 0A                      	db DoNo	;^kl
  5612 00003099 3E                      	db 3eh	;^km	Set Mode
  5613 0000309A 4F                      	db 4Fh	;^kn
  5614 0000309B 0A                      	db DoNo	;^ko
  5615 0000309C 48                      	db 48h 	;^kp    Pipe thru sed
  5616 0000309D 0B                      	db 0bh	;^kq
  5617 0000309E 10                      	db 10h	;^kr
  5618 0000309F 0C                      	db 0ch	;^ks
  5619 000030A0 0A                      	db DoNo	;^kt
  5620                                  %ifdef UTF8RTS
  5621                                  	db 54h	;^ku	^KU UTF8 view switcher
  5622                                  %else
  5623 000030A1 0A                      	db DoNo	;^ku
  5624                                  %endif
  5625 000030A2 23                      	db 23h	;^kv
  5626 000030A3 25                      	db 25h	;^kw
  5627 000030A4 16                      	db 16h	;^kx
  5628 000030A5 19                      	db 19h	;^ky
  5629 000030A6 51                      	db 51h	;^kz	^KZ suspend (like in joe editor)
  5630                                  Ktable_size equ $-Ktable
  5631 000030A7 0A                      Qtable	db DoNo	;^q@	ditto for ^Q menu
  5632 000030A8 1A                      	db 1ah	;^qa
  5633 000030A9 20                      	db 20h	;^qb
  5634 000030AA 0F                      	db 0fh	;^qc
  5635 000030AB 05                      	db 05h	;^qd
  5636 000030AC 1E                      	db 1eh	;^qe
  5637 000030AD 1B                      	db 1bh	;^qf
  5638 000030AE 0A                      	db DoNo	;^qg
  5639 000030AF 17                      	db 17h	;^qh, ^qDEL
  5640 000030B0 11                      	db 11h	;^qi
  5641 000030B1 0A                      	db DoNo	;^qj
  5642 000030B2 21                      	db 21h	;^qk
  5643 000030B3 0A                      	db DoNo	;^ql
  5644 000030B4 0A                      	db DoNo	;^qm
  5645 000030B5 0A                      	db DoNo	;^qn
  5646 000030B6 0A                      	db DoNo	;^qo
  5647 000030B7 18                      	db 18h	;^qp
  5648 000030B8 0A                      	db DoNo	;^qq
  5649 000030B9 0E                      	db 0eh	;^qr
  5650 000030BA 00                      	db 00h	;^qs
  5651 000030BB 0A                      	db DoNo	;^qt
  5652 000030BC 0A                      	db DoNo	;^qu
  5653 000030BD 1C                      	db 1ch	;^qv
  5654 000030BE 12                      	db 12h	;^qw
  5655 000030BF 1F                      	db 1fh	;^qx
  5656 000030C0 22                      	db 22h	;^qy
  5657 000030C1 13                      	db 13h	;^qz
  5658                                  ;----------------------------------------------------------------------
  5659 000030C2 0A                      Xtable	db DoNo	;^x^@
  5660 000030C3 0A                      	db DoNo	;^x^a
  5661 000030C4 0A                      	db DoNo	;^x^b
  5662 000030C5 0B                      	db 0bh	;^x^c	WS: ^KQ
  5663 000030C6 0A                      	db DoNo	;^x^d
  5664 000030C7 0A                      	db DoNo	;^x^e
  5665 000030C8 47                      	db 47h	;^x^f
  5666 000030C9 0A                      	db DoNo	;^x^g
  5667 000030CA 3D                      	db 3Dh	;^x^h   		i.e.  "HELP!" (The Beatles, 1965)  ;-)
  5668 000030CB 10                      	db 10h	;^x i	WS: ^KR
  5669 000030CC 0A                      	db DoNo	;^x^j
  5670 000030CD 0A                      	db DoNo	;^x^k
  5671 000030CE 0A                      	db DoNo	;^x^l
  5672 000030CF 0A                      	db DoNo	;^x^m
  5673 000030D0 4F                      	db 4fh	;^x^n   numerics
  5674 000030D1 0A                      	db DoNo	;^x^o
  5675 000030D2 48                      	db 48h	;^x^p   special sed pipe
  5676 000030D3 0A                      	db DoNo	;^x^q
  5677 000030D4 0A                      	db DoNo	;^x^r
  5678 000030D5 0C                      	db 0ch	;^x^s	WS: ^KS
  5679 000030D6 0A                       	db DoNo	;^x^t
  5680 000030D7 0A                      	db DoNo	;^x^u
  5681 000030D8 0A                      	db DoNo	;^x^v
  5682 000030D9 29                      	db 29h	;^x^w	write to
  5683 000030DA 26                      	db 26h	;^x^x	xchg mark/point
  5684 000030DB 0A                      	db DoNo	;^x^y
  5685 000030DC 0A                      	db DoNo	;^x^z
  5686                                  ;----------------------------------------------------------------------
  5687 000030DD 0A                      PicoJtable db DoNo ;^j@	Junk ops for PI mode
  5688 000030DE 0A                      	db DoNo	;^ja
  5689 000030DF 0A                      	db DoNo	;^jb
  5690 000030E0 0A                      	db DoNo	;^jc
  5691 000030E1 0A                      	db DoNo	;^jd
  5692 000030E2 0A                      	db DoNo	;^je
  5693 000030E3 0A                      	db DoNo	;^jf
  5694 000030E4 0A                      	db DoNo	;^jg
  5695 000030E5 17                      	db 17h 	;^jh Junk to line Home
  5696 000030E6 0A                      	db DoNo	;^ji
  5697 000030E7 0A                      	db DoNo	;^jj
  5698 000030E8 0A                      	db DoNo	;^jk
  5699 000030E9 22                      	db 22h	;^jl Junk Line rest
  5700 000030EA 0A                      	db DoNo	;^jm
  5701 000030EB 0A                      	db DoNo	;^jn
  5702 000030EC 0A                      	db DoNo	;^jo
  5703 000030ED 48                      	db 48h	;^jp  special sed pipe
  5704 000030EE 0A                      	db DoNo	;^jq
  5705 000030EF 0A                      	db DoNo	;^jr
  5706 000030F0 0A                      	db DoNo	;^js
  5707 000030F1 49                      	db 49h	;^jt repeat last search&replace
  5708 000030F2 0A                      	db DoNo	;^ju
  5709 000030F3 0A                      	db DoNo	;^jv
  5710 000030F4 2A                      	db 2Ah	;^jw Junk Word
  5711 000030F5 0A                      	db DoNo	;^jx
  5712 000030F6 0A                      	db DoNo	;^jy
  5713 000030F7 0A                      	db DoNo	;^jz
  5714 000030F8 0A                      PicoQtable db DoNo ;^q@	Quick motions for PI mode: wordstar counterparts on different keys
  5715 000030F9 0A                      	db DoNo	;^qa
  5716 000030FA 1F                      	db 1Fh	;^qb	Bottom of window
  5717 000030FB 4F                      	db 4Fh	;^qc	Calc numerics
  5718 000030FC 0A                      	db DoNo	;^qd
  5719 000030FD 0F                      	db 0fh	;^qe	End of file
  5720 000030FE 1C                      	db 1Ch	;^qf	last Find
  5721 000030FF 0A                      	db DoNo	;^qg
  5722 00003100 0A                      	db DoNo	;^qh
  5723 00003101 0A                      	db DoNo	;^qi
  5724 00003102 0A                      	db DoNo	;^qj
  5725 00003103 0A                      	db DoNo	;^qk
  5726 00003104 11                      	db 11h	;^ql	Line number #
  5727 00003105 3E                      	db 3eh	;^qm	set mode
  5728 00003106 13                      	db 13h	;^qn	Next word
  5729 00003107 0A                      	db DoNo	;^qo
  5730 00003108 12                      	db 12h	;^qp	Previous word
  5731 00003109 0A                      	db DoNo	;^qq
  5732 0000310A 0A                      	db DoNo	;^qr
  5733 0000310B 0E                      	db 0Eh	;^qs	Start of file
  5734 0000310C 1E                      	db 1Eh	;^qt	Top of window
  5735                                  %ifdef USE_UNDO
  5736 0000310D 53                      	db 53h	;^qu	UNDO
  5737                                  %else
  5738                                  	db DoNo	;^qu
  5739                                  %endif
  5740                                  %ifdef UTF8RTS
  5741                                  	dw 54h	;^qv	UTF8 switcher
  5742                                  %else
  5743 0000310E 0A                      	db DoNo	;^qv
  5744                                  %endif
  5745 0000310F 0A                      	db DoNo	;^qw
  5746 00003110 0A                      	db DoNo	;^qx
  5747 00003111 0A                      	db DoNo	;^qy
  5748 00003112 0A                      	db DoNo	;^qz
  5749                                  ;----------------------------------------------------------------------
  5750                                  esize equ 2	;(byte per entry)
  5751                                  %ifdef ARMCPU
  5752                                  align 2
  5753                                  %endif
  5754                                  
  5755                                  jumptab1:	;Storing 16 bit offsets is valid only for code less size 64 kbyte...
  5756                                  		;  ... but in assembler that should never be a problem   ;)
  5757                                  %ifndef USE_EXT_MOVE
  5758 00003113 2B03                    	dw KeyHome	-_start	;0
  5759                                  %else
  5760                                  	dw KeyHome2	-_start	;0
  5761                                  %endif
  5762 00003115 8D02                    	dw KeyUp	-_start	;1
  5763 00003117 CE02                    	dw KeyPgUp	-_start	;2
  5764 00003119 090A                    	dw KeyLeft	-_start	;3
  5765 0000311B D903                    	dw KeyRight	-_start	;4
  5766                                  %ifndef USE_EXT_MOVE
  5767 0000311D 340A                    	dw KeyEnd	-_start	;5
  5768                                  %else
  5769                                  	dw KeyEnd2	-_start	;5
  5770                                  %endif
  5771 0000311F 7C02                    	dw KeyDown	-_start	;6
  5772 00003121 DA02                    	dw KeyPgDn	-_start	;7
  5773 00003123 4503                    	dw KeyIns	-_start	;8
  5774 00003125 9403                    	dw KeyDel	-_start	;9	0..9 are Cursor pad keys
  5775                                  ;------------------------
  5776 00003127 7202                    	dw SimpleRet	-_start	;10 	DO_NOTHING == DoNo
  5777 00003129 5408                    	dw KeyCtrlKQ	-_start	;0bh EMA ^X^C
  5778 0000312B 2F08                    	dw KeyCtrlKS	-_start	;0ch EMA ^X^S
  5779 0000312D 4508                    	dw KeyCtrlKD	-_start	;0dh EMA ^X^F
  5780                                  %ifndef USE_EXT_MOVE
  5781 0000312F C405                    	dw KeyCtrlQR	-_start	;0eh EMA Alt<
  5782 00003131 B308                    	dw KeyCtrlQC	-_start	;0fh EMA Alt>
  5783                                  %else
  5784                                  	dw KeyCtrlQR2	-_start	;0eh EMA Alt<
  5785                                  	dw KeyCtrlQC2	-_start	;0fh EMA Alt>
  5786                                  %endif
  5787 00003133 A207                    	dw KeyCtrlKR	-_start	;10h EMA ^XI
  5788 00003135 EF05                    	dw KeyCtrlQI	-_start	;11h EMA Alt-G
  5789 00003137 1004                    	dw KeyCtrlQW	-_start	;12h EMA Alt-B
  5790 00003139 3104                    	dw KeyCtrlQZ	-_start	;13h EMA Alt-F
  5791                                  ;--------------------------
  5792                                  ;up to here this functions are considered common for all (exc vi)
  5793                                  ;Of course some use different key names.
  5794                                  ;
  5795                                  ;now follows special stuff for each editor emulation:
  5796                                  ;-------WS and Pico--------
  5797 0000313B FE06                    	dw KeyCtrlKK	-_start	;14h
  5798 0000313D 0607                    	dw KeyCtrlKC	-_start	;15h
  5799 0000313F 8208                    	dw KeyCtrlKX	-_start	;16h
  5800 00003141 0706                    	dw KeyCtrlQDel	-_start	;17h
  5801 00003143 CB05                    	dw KeyCtrlQP	-_start	;18h
  5802 00003145 D606                    	dw KeyCtrlKY	-_start	;19h
  5803 00003147 CE04                    	dw KeyCtrlQA	-_start	;1ah
  5804 00003149 2E05                    	dw KeyCtrlQF	-_start	;1bh
  5805 0000314B 9604                    	dw KeyCtrlQV	-_start	;1ch
  5806 0000314D F606                    	dw KeyCtrlKH	-_start	;1dh
  5807 0000314F 7904                    	dw KeyCtrlQE	-_start	;1eh
  5808 00003151 8504                    	dw KeyCtrlQX	-_start	;1fh
  5809 00003153 D905                    	dw KeyCtrlQB	-_start	;20h
  5810 00003155 E605                    	dw KeyCtrlQK	-_start	;21h
  5811 00003157 1C06                    	dw KeyCtrlQY	-_start	;22h
  5812 00003159 3007                    	dw KeyCtrlKV	-_start	;23h
  5813 0000315B 5807                    	dw KeyCtrlKB	-_start	;24h
  5814 0000315D DA07                    	dw KeyCtrlKW	-_start	;25h
  5815                                  ;-------EM--------
  5816 0000315F 1A07                    	dw KeyCtrlXX	-_start	;26h
  5817 00003161 B814                    	dw KeyEmaAltW	-_start	;27h
  5818 00003163 BF04                    	dw KeyEmaAltPer	-_start ;28h Alt-%
  5819 00003165 0F08                    	dw KeyEmaCtrlXW	-_start	;29h
  5820                                  ;-------PI--------
  5821 00003167 6606                    	dw KeyCtrlT	-_start	;2Ah
  5822                                  ;-------VI--------
  5823 00003169 E009                    	dw KeyVIcmdi	-_start	;2Bh
  5824 0000316B 450A                    	dw KeyVIex	-_start	;2Ch
  5825 0000316D DB09                    	dw KeyVIcmda	-_start ;2Dh
  5826 0000316F D409                    	dw KeyVICmdA	-_start	;2Eh
  5827 00003171 C809                    	dw KeyVICmdo	-_start	;2Fh
  5828 00003173 7904                    	dw KeyCtrlQE	-_start	;30h
  5829 00003175 8504                    	dw KeyCtrlQX	-_start	;31h
  5830 00003177 B709                    	dw KeyVICmdO	-_start	;32h
  5831 00003179 6F09                    	dw KeyVICmdI	-_start	;33h
  5832 0000317B AE09                    	dw KeyVICmdR	-_start ;34h
  5833 0000317D 2409                    	dw KeyVICmdd	-_start ;35h
  5834 0000317F AA02                    	dw KeyHalfPgDn	-_start ;36h
  5835 00003181 9E02                    	dw KeyHalfPgUp	-_start ;37h
  5836 00003183 F508                    	dw KeyVI1Char	-_start ;38h
  5837 00003185 AE04                    	dw KeyVIfsearch	-_start ;39h
  5838 00003187 AA04                    	dw KeyVIbsearch	-_start ;3Ah
  5839 00003189 7609                    	dw KeyVICmdp	-_start ;3Bh
  5840 0000318B 8C09                    	dw KeyVICmdP	-_start ;3Ch
  5841                                  ;------- later added (mostly vi stuff) ------
  5842 0000318D B211                    	dw KeyHelp	-_start ;3Dh	general
  5843 0000318F 9D1A                    	dw KeyEditMode	-_start ;3Eh	general
  5844 00003191 8D03                    	dw KeyDell	-_start ;3Fh	vi
  5845 00003193 1109                    	dw KeyVICmdS	-_start ;40h	vi	
  5846 00003195 EB08                    	dw KeyVICmdZ	-_start ;41h	vi
  5847 00003197 2212                    	dw KeyVICmdz	-_start ;42h	vi
  5848 00003199 5B04                    	dw KeyVIcmde	-_start ;43h	vi
  5849 0000319B AB05                    	dw KeyVIcmd1	-_start ;44h	vi
  5850 0000319D 6E07                    	dw KeyVICmdm	-_start ;45h	vi
  5851 0000319F 1414                    	dw KeyVICmdy	-_start ;46h	vi
  5852 000031A1 E807                    	dw KeyEmaCtrlXF	-_start ;47h	emacs (extended ^KD from WS)
  5853                                  %ifdef USE_PIPE	
  5854 000031A3 571C                    	dw KeyCtrlKP	-_start ;48h    use sed-pipe in WS,Emacs,Pico
  5855                                  %else
  5856                                  	dw SimpleRet	-_start ;48h
  5857                                  %endif
  5858 000031A5 0605                    	dw KeyPiCtrlJT	-_start ;49h	Pico
  5859 000031A7 6301                    	dw KeyVICmdr	-_start ;4Ah	vi
  5860 000031A9 EB09                    	dw KeyVICmdC	-_start ;4Bh	vi
  5861 000031AB 1506                    	dw KeyVICmdD	-_start ;4Ch	vi
  5862 000031AD 8603                    	dw KeyVICmdJ	-_start ;4Dh	vi
  5863                                  %ifdef BEEP_IN_VI
  5864 000031AF 1C20                    	dw VIBeepForD	-_start ;4Eh	vi
  5865                                  %else
  5866                                  	dw SimpleRet	-_start ;4Eh	vi
  5867                                  %endif
  5868 000031B1 4E1E                    	dw KeyCtrlKN	-_start ;4Fh	general
  5869 000031B3 8507                    	dw KeyVICmdJmpM -_start ;50h	vi
  5870                                  %ifdef SYS_kill
  5871 000031B5 351C                    	dw KeySuspend	-_start ;51h	general
  5872                                  %else
  5873                                  	dw SimpleRet	-_start	;51h
  5874                                  %endif
  5875 000031B7 2C12                    	dw KeyVI_M	-_start ;52h	vi
  5876                                  %ifdef USE_UNDO
  5877 000031B9 7C21                    	dw KeyUndo	-_start ;53h	general
  5878                                  %else
  5879                                  	dw SimpleRet	-_start	;53h
  5880                                  %endif
  5881                                  %ifdef UTF8RTS
  5882                                  	dw KeyUTF8switch-_start ;54h	general
  5883                                  %else
  5884 000031BB 7202                    	dw SimpleRet	-_start	;54h
  5885                                  %endif
  5886                                  jumps1 equ ($-jumptab1) / esize
  5887                                  ;--- 32 more for WS--------
  5888 000031BD 7202                    	dw SimpleRet	-_start	;^Space
  5889 000031BF 1004                    	dw KeyCtrlQW	-_start	;^a
  5890 000031C1 7202                    	dw SimpleRet	-_start	;^b  ;; TEST dw KeyUndo-_start
  5891 000031C3 DA02                    	dw KeyPgDn	-_start	;^c
  5892 000031C5 D903                    	dw KeyRight	-_start ;^d
  5893 000031C7 8D02                    	dw KeyUp	-_start	;^e
  5894 000031C9 3104                    	dw KeyCtrlQZ	-_start	;^f
  5895 000031CB 9403                    	dw KeyDel	-_start	;^g 7
  5896 000031CD 8D03                    	dw KeyDell	-_start	;^h 8   DEL (7fh is translated)
  5897 000031CF 1601                    	dw NormChar	-_start	;^i 9	(TAB)
  5898                                  %ifdef SELFTEST
  5899                                  	dw KeyRet	-_start	;^j 0ah
  5900                                  %else
  5901 000031D1 B211                    	dw KeyHelp	-_start	;^j
  5902                                  %endif
  5903 000031D3 9101                    	dw CtrlKMenu	-_start	;^k b
  5904 000031D5 9205                    	dw KeyCtrlL	-_start	;^l c
  5905 000031D7 2A02                    	dw KeyRet	-_start	;^m 0dh
  5906 000031D9 7202                    	dw SimpleRet	-_start	;^n e
  5907 000031DB 7202                    	dw SimpleRet	-_start	;^o f
  5908 000031DD B211                    	dw KeyHelp	-_start	;^p 10	Help!
  5909 000031DF 9A01                    	dw CtrlQMenu	-_start	;^q 11
  5910 000031E1 CE02                    	dw KeyPgUp	-_start	;^r 12
  5911 000031E3 090A                    	dw KeyLeft	-_start	;^s 13
  5912 000031E5 6606                    	dw KeyCtrlT	-_start	;^t 14
  5913                                  %ifdef USE_UNDO
  5914 000031E7 7C21                    	dw KeyUndo	-_start	;^u 15 (abort in Input)
  5915                                  %else
  5916                                  	dw SimpleRet	-_start	;^u
  5917                                  %endif	
  5918 000031E9 4503                    	dw KeyIns	-_start	;^v 16
  5919 000031EB B602                    	dw KeyScrollUp	-_start	;^w 17
  5920 000031ED 7C02                    	dw KeyDown	-_start	;^x 18
  5921 000031EF 3906                    	dw KeyCtrlY	-_start	;^y 19
  5922 000031F1 C202                    	dw KeyScrollDn	-_start ;1a
  5923 000031F3 7202                    	dw SimpleRet	-_start ;1b
  5924 000031F5 7202                    	dw SimpleRet	-_start	;1c
  5925 000031F7 7202                    	dw SimpleRet	-_start	;1d
  5926 000031F9 7202                    	dw SimpleRet	-_start	;1e
  5927                                  %ifdef ROLLBACK	
  5928                                  	dw RollBack	-_start	;1f  for internal testing of UNDO ring buffer only
  5929                                  %else
  5930 000031FB 7202                    	dw SimpleRet	-_start	;1f
  5931                                  %endif
  5932                                  ;--- 32 more for EM--------
  5933 000031FD 9A07                    	dw KeyEmaMark	-_start	;^Space
  5934 000031FF 2B03                    	dw KeyHome	-_start	;^a
  5935 00003201 090A                    	dw KeyLeft	-_start	;^b
  5936 00003203 7202                    	dw SimpleRet	-_start	;^c (not planned)
  5937 00003205 9403                    	dw KeyDel	-_start ;^d
  5938 00003207 340A                    	dw KeyEnd	-_start	;^e
  5939 00003209 D903                    	dw KeyRight	-_start	;^f
  5940 0000320B 7202                    	dw SimpleRet	-_start	;^g (abort in Input)
  5941 0000320D 8D03                    	dw KeyDell	-_start	;^h
  5942 0000320F 1601                    	dw NormChar	-_start	;^i (TAB)
  5943 00003211 2A02                    	dw KeyRet	-_start	;^j
  5944 00003213 7206                    	dw KeyEmaCtrlK	-_start	;^k
  5945 00003215 4412                    	dw KeyEmaCtrlL	-_start	;^l
  5946 00003217 2602                    	dw KeyRetNoInd	-_start	;^m 0dh
  5947 00003219 7C02                    	dw KeyDown	-_start	;^n
  5948 0000321B 6D04                    	dw KeyEmaCtrlO	-_start	;^o
  5949 0000321D 8D02                    	dw KeyUp	-_start	;^p
  5950 0000321F 7C01                    	dw KeyEmaCtrlQ	-_start	;^q
  5951 00003221 1005                    	dw KeyEmaCtrlR	-_start	;^r
  5952 00003223 1405                    	dw KeyEmaCtrlS	-_start	;^s
  5953 00003225 D803                    	dw KeyEmaCtrlT	-_start	;^t
  5954                                  %ifdef UTF8RTS
  5955                                  	dw KeyUTF8switch-_start	;^u UTF8 mode switcher 
  5956                                  	; (ATTENZIONE: that is NOT emacs stuff like: 'C-u runs the command universal-argument')
  5957                                  %else
  5958 00003227 7202                    	dw SimpleRet	-_start	;^u
  5959                                  %endif
  5960 00003229 DA02                    	dw KeyPgDn	-_start	;^v
  5961 0000322B 9C06                    	dw KeyEmaCtrlW	-_start	;^w
  5962 0000322D B301                    	dw CtrlXMenu	-_start	;^x
  5963 0000322F 4414                    	dw KeyEmaCtrlY	-_start	;^y
  5964                                  %ifdef SYS_kill
  5965 00003231 351C                    	dw KeySuspend	-_start ;^z
  5966                                  %else
  5967                                  	dw SimpleRet	-_start	;51h
  5968                                  %endif
  5969 00003233 7202                    	dw SimpleRet	-_start ;1b
  5970 00003235 7202                    	dw SimpleRet	-_start	;1c
  5971 00003237 7202                    	dw SimpleRet	-_start	;1d
  5972 00003239 7202                    	dw SimpleRet	-_start	;1e
  5973                                  %ifdef USE_UNDO
  5974 0000323B 7C21                    	dw KeyUndo	-_start ;1f
  5975                                  %else
  5976                                  	dw SimpleRet	-_start	;1f
  5977                                  %endif
  5978                                  ;--- 32 more for PI------
  5979 0000323D 9A07                    	dw KeyEmaMark	-_start	;^Space	a redundant marker because ^^ is ugly on some kbds
  5980 0000323F 2B03                    	dw KeyHome	-_start	;^a 1
  5981 00003241 090A                    	dw KeyLeft	-_start	;^b 2
  5982 00003243 7202                    	dw SimpleRet	-_start	;^c 3
  5983 00003245 9403                    	dw KeyDel	-_start ;^d 4
  5984 00003247 340A                    	dw KeyEnd	-_start	;^e 5
  5985 00003249 D903                    	dw KeyRight	-_start	;^f 6
  5986 0000324B B211                    	dw KeyHelp	-_start	;^g 7
  5987 0000324D 8D03                    	dw KeyDell	-_start	;^h 8   DEL
  5988 0000324F 1601                    	dw NormChar	-_start	;^i 9	(TAB)
  5989 00003251 A101                    	dw PicoJMenu	-_start	;^j a
  5990 00003253 9C06                    	dw KeyEmaCtrlW	-_start	;^k b
  5991 00003255 9A07                    	dw KeyEmaMark	-_start	;^l c	a redundant marker because ^^ is ugly on some kbds
  5992 00003257 2A02                    	dw KeyRet	-_start	;^m d
  5993 00003259 7C02                    	dw KeyDown	-_start	;^n e
  5994 0000325B 2F08                    	dw KeyCtrlKS	-_start	;^o f	SAVE
  5995 0000325D 8D02                    	dw KeyUp	-_start	;^p 10
  5996 0000325F AA01                    	dw PicoQMenu	-_start	;^q 11
  5997 00003261 A207                    	dw KeyCtrlKR	-_start	;^r 12
  5998 00003263 0F08                    	dw KeyEmaCtrlXW	-_start	;^s 13	SAVE_AS
  5999 00003265 B904                    	dw PicoCtrlTpico-_start	;^t 14
  6000 00003267 4414                    	dw KeyEmaCtrlY	-_start	;^u 15
  6001 00003269 DA02                    	dw KeyPgDn	-_start	;^v 16
  6002 0000326B 1405                    	dw KeyEmaCtrlS	-_start	;^w 17
  6003 0000326D 5408                    	dw KeyCtrlKQ	-_start	;^x 18
  6004 0000326F CE02                    	dw KeyPgUp	-_start	;^y 19
  6005                                  %ifdef SYS_kill	
  6006 00003271 351C                    	dw KeySuspend	-_start ;^z 1A  (not in pico)
  6007                                  %else
  6008                                  	dw SimpleRet	-_start	;^z
  6009                                  %endif
  6010 00003273 7202                    	dw SimpleRet	-_start	;^[ 1B
  6011 00003275 7202                    	dw SimpleRet	-_start	;^\ 1C
  6012 00003277 7202                    	dw SimpleRet	-_start	;^] 1D
  6013 00003279 9A07                    	dw KeyEmaMark	-_start	;^^ 1E	see ^L
  6014 0000327B 7202                    	dw SimpleRet	-_start ;1F
  6015                                  ;--- 32 more for NE------
  6016 0000327D 9A07                    	dw KeyEmaMark	-_start	;^Space toggle selection mode (no shift cursor keys available!)
  6017 0000327F B905                    	dw KeyNedCtrlA	-_start	;^a 1   Mark all
  6018 00003281 4503                    	dw KeyIns	-_start	;^b 2   toggle Ins mode
  6019 00003283 B814                    	dw KeyEmaAltW	-_start	;^c 3	COPY
  6020 00003285 7202                    	dw SimpleRet	-_start ;^d 4
  6021 00003287 9D1A                    	dw KeyEditMode	-_start	;^e 5   set EDit mode
  6022 00003289 2E05                    	dw KeyCtrlQF	-_start	;^f 6   find
  6023 0000328B 9205                    	dw KeyCtrlL	-_start	;^g 7   find again
  6024 0000328D 8D03                    	dw KeyDell	-_start	;^h 8   DEL
  6025 0000328F 1601                    	dw NormChar	-_start	;^i 9	TAB
  6026 00003291 2A02                    	dw KeyRet	-_start	;^j a   RETURN
  6027 00003293 4E1E                    	dw KeyCtrlKN	-_start	;^k b   numerics
  6028 00003295 EF05                    	dw KeyCtrlQI	-_start	;^l c   LINE #
  6029 00003297 2A02                    	dw KeyRet	-_start	;^m d   RETURN
  6030 00003299 E807                    	dw KeyEmaCtrlXF	-_start	;^n e	OPEN another
  6031 0000329B E807                    	dw KeyEmaCtrlXF	-_start	;^o f   OPEN another
  6032 0000329D 7202                    	dw SimpleRet	-_start	;^p 10
  6033 0000329F 5408                    	dw KeyCtrlKQ	-_start	;^q 11  EXIT
  6034 000032A1 CE04                    	dw KeyCtrlQA	-_start	;^r 12  REPLACE
  6035 000032A3 2F08                    	dw KeyCtrlKS	-_start	;^s 13	SAVE
  6036 000032A5 7202                    	dw SimpleRet	-_start	;^t 14
  6037                                  %ifdef USE_UNDO
  6038 000032A7 7C21                    	dw KeyUndo	-_start ;^u 15	UNDO
  6039                                  %else
  6040                                  	dw SimpleRet	-_start	;^u 15
  6041                                  %endif
  6042 000032A9 4414                    	dw KeyEmaCtrlY	-_start	;^v 16	PASTE
  6043 000032AB 0F08                    	dw KeyEmaCtrlXW	-_start	;^w 13	SAVE_AS/WRITE TO
  6044 000032AD 9C06                    	dw KeyEmaCtrlW	-_start	;^x 18	CUT
  6045                                  %ifdef UTF8RTS
  6046                                  	dw KeyUTF8switch-_start	;^y 19
  6047                                  %else
  6048 000032AF 7202                    	dw SimpleRet	-_start	;^y 19
  6049                                  %endif
  6050                                  %ifdef SYS_kill
  6051 000032B1 351C                    	dw KeySuspend	-_start ;^z 1A
  6052                                  %else
  6053                                  	dw SimpleRet	-_start	;^z
  6054                                  %endif	
  6055 000032B3 7202                    	dw SimpleRet	-_start	;^[ 1B
  6056 000032B5 7202                    	dw SimpleRet	-_start	;^\ 1C
  6057 000032B7 7202                    	dw SimpleRet	-_start	;^] 1D
  6058 000032B9 7202                    	dw SimpleRet	-_start	;^^ 1E
  6059 000032BB 7202                    	dw SimpleRet	-_start ;1F
  6060                                  ;----------------------------------------------------------------------
  6061                                  ;
  6062                                  %ifdef W32
  6063                                   scolorslen	equ 0
  6064                                  %else
  6065 000032BD 07                       BeepChar	db 7
  6066 000032BE 1B5B34306D1B5B3337-      screencolors0	db 27,'[40m',27,'[37m'
  6066 000032C7 6D                 
  6067 000032C8 1B5B306D                 bold0		db 27,'[0m'		;reset to b/w
  6068 000032CC 1B5B34346D1B5B3333-      screencolors1	db 27,'[44m',27,'[33m'	;yellow on blue
  6068 000032D5 6D                 
  6069                                   reversevideoX:
  6070 000032D6 1B5B316D                 bold1:		db 27,'[1m'		;bold
  6071                                   scolorslen	equ $-screencolors1
  6072                                   boldlen	equ $-bold1		;take care length of bold0 == length of bold1
  6073                                  %ifdef LINUX
  6074 000032DA 1B5B376D                		db 27,'[7m'		;good for "linux" terminal on /dev/tty (but not xterm,kvt)
  6075                                  					;again take care length = length of boldX
  6076                                  					;!! important: store directly after bold1 !!
  6077                                  %ifdef NEW_CURSOR_MGNT
  6078 000032DE 1B5B3F31373B303B36-      blockcurs	db 27,'[?17;0;64c'	;see e3.h
  6078 000032E7 3463               
  6079                                   blockcurslen	equ $-blockcurs
  6080 000032E9 1B5B3F3263               normcurs	db 27,'[?2c'
  6081                                   normcurslen	equ $-normcurs
  6082                                  %endif
  6083                                  %endif
  6084                                  %endif
  6085                                  %ifdef SELFTEST
  6086                                   pipein		db 'PIPE_IN',0
  6087                                  %endif
  6088                                  ;-------
  6089                                  %ifdef UTF8
  6090                                  %ifdef UTF8RTS
  6091                                   getPos		db 13, 0c3h, 0B6h,27,'[6n',13	;write carriage_return, followed by 1 UTF8 char
  6092                                   						;german umlaut oe = ö in UTF-8
  6093                                   gPlen		equ $-getPos			;and clean up with another carriage_return
  6094                                  						;Terminal should answer ESC[<line>;<column>R
  6095                                  %endif						;on UTF8 terminals should be column==2 else ==3
  6096                                  %endif
  6097                                  ;-------------------------------------------------------------------------
  6098                                  %ifdef ARMCPU
  6099                                  align 2
  6100                                  %endif
  6101 000032EE 702057537020506970-     editmode:db 'p WSp Pip Emp NE'
  6101 000032F7 20456D70204E45     
  6102                                  ;
  6103                                  helptext:
  6104 000032FE 4D6963726F45646974-     db "MicroEditor e3 v2.7.1"
  6104 00003307 6F722065332076322E-
  6104 00003310 372E31             
  6105                                  %ifndef NASM
  6106                                  db "Y"
  6107                                  %endif
  6108                                  %ifdef UTF8
  6109 00003313 2D5554463820C2A9        db "-UTF8 ",0C2h,0A9h
  6110                                  %else
  6111                                  db " (C)"
  6112                                  %endif
  6113 0000331B 323030302D30372041-     db "2000-07 A.Kleine",10
  6113 00003324 2E4B6C65696E650A   
  6114 0000332C 456E7465722066696C-     db "Enter filename or leave with RETURN",10,10
  6114 00003335 656E616D65206F7220-
  6114 0000333E 6C6561766520776974-
  6114 00003347 682052455455524E0A-
  6114 00003350 0A                 
  6115                                  %ifdef YASM
  6116                                  %ifdef UTF8
  6117                                  helptextsize equ 54h
  6118                                  %else
  6119                                  helptextsize equ 50h
  6120                                  %endif
  6121                                  %else
  6122                                  helptextsize equ $-helptext
  6123                                  %if helptextsize>127
  6124                                   %error helptextsize
  6125                                  %endif
  6126                                  %endif
  6127 00003351 0A0A0A0909092D3D20-     helpfoot:db 10,10,10,TABCHAR,TABCHAR,TABCHAR,"-= PRESS ANY KEY =-" ;at least 6 wasted byte ;-)
  6127 0000335A 505245535320414E59-
  6127 00003363 204B4559203D2D     
  6128                                  %ifdef YASM
  6129                                  helpfootsize equ 19h
  6130                                  %else
  6131                                  helpfootsize equ $-helpfoot
  6132                                  %if helpfootsize>127
  6133                                   %error helpfootsize
  6134                                  %endif
  6135                                  %endif
  6136                                  ;
  6137                                  %ifdef USE_BUILTINHELP
  6138                                  help_ws:
  6139 0000336A 4B65792062696E6469-     db "Key bindings in WS mode:",10,10
  6139 00003373 6E677320696E205753-
  6139 0000337C 206D6F64653A0A0A   
  6140 00003384 46696C65733A095E4B-     db "Files:	^KR Insert	^KS Save	^KX Save&Exit	^KQ Abort&Exit",10
  6140 0000338D 5220496E7365727409-
  6140 00003396 5E4B53205361766509-
  6140 0000339F 5E4B58205361766526-
  6140 000033A8 45786974095E4B5120-
  6140 000033B1 41626F727426457869-
  6140 000033BA 740A               
  6141                                  %ifndef USE_PIPE
  6142                                  db "	^KD Save&Load",10
  6143                                  %else
  6144                                  %ifdef USE_EX_NO_SED
  6145                                  db "	^KD Save&Load	^KP Pipe buffer thru 'ex' ",10
  6146                                  %else
  6147 000033BC 095E4B442053617665-     db "	^KD Save&Load	^KP Pipe buffer thru 'sed'",10
  6147 000033C5 264C6F6164095E4B50-
  6147 000033CE 205069706520627566-
  6147 000033D7 666572207468727520-
  6147 000033E0 27736564270A       
  6148                                  %endif
  6149                                  %endif
  6150 000033E6 0A                      db 10
  6151 000033E7 426C6F636B733A095E-     db "Blocks:	^KB Start	^KK End		^KC Copy	^KY Del",10
  6151 000033F0 4B4220537461727409-
  6151 000033F9 5E4B4B20456E640909-
  6151 00003402 5E4B4320436F707909-
  6151 0000340B 5E4B592044656C0A   
  6152 00003413 095E4B56204D6F7665-     db "	^KV Move	^KW Write",10
  6152 0000341C 095E4B572057726974-
  6152 00003425 650A               
  6153 00003427 0A                      db 10
  6154 00003428 5365617263683A095E-     db "Search:	^QF Find	^L  Repeat	^QA Srch&Repl",10
  6154 00003431 51462046696E64095E-
  6154 0000343A 4C2020526570656174-
  6154 00003443 095E51412053726368-
  6154 0000344C 265265706C0A       
  6155 00003452 4D6F76653A095E4520-     db "Move:	^E  Up		^X  Down	^S  Left	^D  Right",10
  6155 0000345B 20557009095E582020-
  6155 00003464 446F776E095E532020-
  6155 0000346D 4C656674095E442020-
  6155 00003476 52696768740A       
  6156 0000347C 095E52202050616765-     db "	^R  Page Up	^C  Page Dn	^W  Scroll Up	^Z  Scroll Dn",10
  6156 00003485 205570095E43202050-
  6156 0000348E 61676520446E095E57-
  6156 00003497 20205363726F6C6C20-
  6156 000034A0 5570095E5A20205363-
  6156 000034A9 726F6C6C20446E0A   
  6157 000034B1 517569636B2D095E51-     db "Quick-	^QE Wnd Top	^QX Wnd Bott	^QS Home	^QD End",10
  6157 000034BA 4520576E6420546F70-
  6157 000034C3 095E515820576E6420-
  6157 000034CC 426F7474095E515320-
  6157 000034D5 486F6D65095E514420-
  6157 000034DE 456E640A           
  6158 000034E2 2D4D6F76653A095E51-     db "-Move:	^QR BOF		^QC EOF		^QB Blk Begin	^QK Blk End",10
  6158 000034EB 5220424F4609095E51-
  6158 000034F4 4320454F4609095E51-
  6158 000034FD 4220426C6B20426567-
  6158 00003506 696E095E514B20426C-
  6158 0000350F 6B20456E640A       
  6159 00003515 095E4620204E657874-     db "	^F  Next Word	^A  Prev Word	^QI Line#	^QV Last Find",10
  6159 0000351E 20576F7264095E4120-
  6159 00003527 205072657620576F72-
  6159 00003530 64095E5149204C696E-
  6159 00003539 6523095E5156204C61-
  6159 00003542 73742046696E640A   
  6160 0000354A 0A                      db 10
  6161 0000354B 44656C6574653A095E-     db "Delete:	^T  Word	^Y  Line	^H  Left	^G  Chr",10
  6161 00003554 542020576F7264095E-
  6161 0000355D 5920204C696E65095E-
  6161 00003566 4820204C656674095E-
  6161 0000356F 4720204368720A     
  6162 00003576 095E5159204C696E65-     db "	^QY Line End	^QDel,^QH Line Beg",10
  6162 0000357F 20456E64095E514465-
  6162 00003588 6C2C5E5148204C696E-
  6162 00003591 65204265670A       
  6163                                  %ifdef USE_MATH
  6164 00003597 4F746865723A095E4B-     db "Other:	^KM Set mode	^KN Numerics"
  6164 000035A0 4D20536574206D6F64-
  6164 000035A9 65095E4B4E204E756D-
  6164 000035B2 6572696373         
  6165                                  %else
  6166                                  db "Other:	^KM Set mode"
  6167                                  %endif
  6168                                  %ifdef SYS_kill
  6169 000035B7 095E4B5A2053757370-     db "	^KZ Suspend "
  6169 000035C0 656E6420           
  6170                                  %endif
  6171                                  %ifdef USE_UNDO
  6172 000035C4 095E552020556E646F      db "	^U  Undo"
  6173                                  %endif
  6174                                  %ifdef UTF8RTS
  6175                                  db 10,"	^KU UTF8"
  6176                                  %endif
  6177                                  help_ws_size equ $-help_ws
  6178                                  ;-------------------------
  6179                                  help_pi:
  6180 000035CD 4B65792062696E6469-     db "Key bindings in PICO mode:",10,10
  6180 000035D6 6E677320696E205049-
  6180 000035DF 434F206D6F64653A0A-
  6180 000035E8 0A                 
  6181 000035E9 46696C65733A095E58-     db "Files:	^XN ExitNoSave	^XY Exit+Save	^XL Save+Load New File",10
  6181 000035F2 4E20457869744E6F53-
  6181 000035FB 617665095E58592045-
  6181 00003604 7869742B5361766509-
  6181 0000360D 5E584C20536176652B-
  6181 00003616 4C6F6164204E657720-
  6181 0000361F 46696C650A         
  6182 00003624 095E4F202053617665-     db "	^O  Save	^S  Save as	^R  Read",10
  6182 0000362D 095E53202053617665-
  6182 00003636 206173095E52202052-
  6182 0000363F 6561640A           
  6183 00003643 0A                      db 10
  6184 00003644 4D6F76653A095E5020-     db "Move:	^P  Up		^N  Down	^B  Left	^F  Right",10
  6184 0000364D 20557009095E4E2020-
  6184 00003656 446F776E095E422020-
  6184 0000365F 4C656674095E462020-
  6184 00003668 52696768740A       
  6185 0000366E 095E59202050616765-     db "	^Y  Page up	^V  Page down	^QN Next word	^QP Previous word",10
  6185 00003677 207570095E56202050-
  6185 00003680 61676520646F776E09-
  6185 00003689 5E514E204E65787420-
  6185 00003692 776F7264095E515020-
  6185 0000369B 50726576696F757320-
  6185 000036A4 776F72640A         
  6186 000036A9 095E412020486F6D65-     db "	^A  Home	^E  End		^QS Start	^QE EOF",10
  6186 000036B2 095E452020456E6409-
  6186 000036BB 095E51532053746172-
  6186 000036C4 74095E514520454F46-
  6186 000036CD 0A                 
  6187 000036CE 095E515420546F7020-     db "	^QT Top screen	^QB Bottom scr	^QL Line #	^QF last Find",10
  6187 000036D7 73637265656E095E51-
  6187 000036E0 4220426F74746F6D20-
  6187 000036E9 736372095E514C204C-
  6187 000036F2 696E652023095E5146-
  6187 000036FB 206C6173742046696E-
  6187 00003704 640A               
  6188 00003706 0A                      db 10
  6189 00003707 5365617263683A095E-     db "Search:	^W  Where is	^T  Search&Repl	^JT Repeat Search & Replace",10
  6189 00003710 572020576865726520-
  6189 00003719 6973095E5420205365-
  6189 00003722 61726368265265706C-
  6189 0000372B 095E4A542052657065-
  6189 00003734 617420536561726368-
  6189 0000373D 2026205265706C6163-
  6189 00003746 650A               
  6190 00003748 0A                      db 10
  6191 00003749 44656C6574653A095E-     db "Delete:	^H  Left char	^D  This char	^K  Kill line/region",10
  6191 00003752 4820204C6566742063-
  6191 0000375B 686172095E44202054-
  6191 00003764 686973206368617209-
  6191 0000376D 5E4B20204B696C6C20-
  6191 00003776 6C696E652F72656769-
  6191 0000377F 6F6E0A             
  6192 00003782 095E4A5720576F7264-     db "	^JW Word	^JL Line end	^JH Line begin",10
  6192 0000378B 095E4A4C204C696E65-
  6192 00003794 20656E64095E4A4820-
  6192 0000379D 4C696E652062656769-
  6192 000037A6 6E0A               
  6193 000037A8 0A                      db 10
  6194 000037A9 4F746865723A095E55-     db "Other:	^U  Unkill	^G  Help	^^,^L,^<SPC> Mark region",10
  6194 000037B2 2020556E6B696C6C09-
  6194 000037BB 5E47202048656C7009-
  6194 000037C4 5E5E2C5E4C2C5E3C53-
  6194 000037CD 50433E204D61726B20-
  6194 000037D6 726567696F6E0A     
  6195                                  %ifndef USE_PIPE
  6196                                  db "	^QM Set Edit Mode ",10
  6197                                  %else
  6198                                  %ifdef USE_EX_NO_SED
  6199                                  db "	^QM Set Edit Mode		^JP Pipe buffer thru 'ex' ",10
  6200                                  %else
  6201 000037DD 095E514D2053657420-     db "	^QM Set Edit Mode		^JP Pipe buffer thru 'sed'",10
  6201 000037E6 45646974204D6F6465-
  6201 000037EF 09095E4A5020506970-
  6201 000037F8 652062756666657220-
  6201 00003801 746872752027736564-
  6201 0000380A 270A               
  6202                                  %endif
  6203                                  %endif
  6204                                  %ifdef USE_MATH
  6205 0000380C 095E51432043616C63-     db "	^QC Calculate"
  6205 00003815 756C617465         
  6206                                  %else
  6207                                  db " "
  6208                                  %endif
  6209                                  %ifdef SYS_kill
  6210 0000381A 0909095E5A20537573-     db "			^Z Suspend"
  6210 00003823 70656E64           
  6211                                  %endif
  6212                                  %ifdef USE_UNDO
  6213 00003827 095E515520556E646F      db "	^QU Undo"
  6214                                  %endif
  6215                                  %ifdef UTF8RTS
  6216                                  db 10,"	^QV UTF8"
  6217                                  %endif
  6218                                  help_pi_size equ $-help_pi
  6219                                  ;-------------------------
  6220                                  help_em:
  6221 00003830 4B65792062696E6469-     db "Key bindings in EMACS mode:",10,10
  6221 00003839 6E677320696E20454D-
  6221 00003842 414353206D6F64653A-
  6221 0000384B 0A0A               
  6222 0000384D 46696C65733A095E58-     db "Files:	^X^C Exit	^XI  Insert	^X^S Save	^X^F Load New",10
  6222 00003856 5E432045786974095E-
  6222 0000385F 58492020496E736572-
  6222 00003868 74095E585E53205361-
  6222 00003871 7665095E585E46204C-
  6222 0000387A 6F6164204E65770A   
  6223                                  %ifndef USE_PIPE
  6224                                  db "	^X^W Write new	^X^H Help ",10
  6225                                  %else
  6226                                  %ifdef USE_EX_NO_SED
  6227                                  db "	^X^W Write new	^X^H Help	^X^P Pipe buffer thru 'ex' ",10
  6228                                  %else
  6229 00003882 095E585E5720577269-     db "	^X^W Write new	^X^H Help	^X^P Pipe buffer thru 'sed'",10
  6229 0000388B 7465206E6577095E58-
  6229 00003894 5E482048656C70095E-
  6229 0000389D 585E50205069706520-
  6229 000038A6 627566666572207468-
  6229 000038AF 72752027736564270A 
  6230                                  %endif
  6231                                  %endif
  6232 000038B8 0A                      db 10
  6233 000038B9 4D6F76653A095E5020-     db "Move:	^P   Up		^N  Down	^B   Left	^F   Right",10
  6233 000038C2 2020557009095E4E20-
  6233 000038CB 20446F776E095E4220-
  6233 000038D4 20204C656674095E46-
  6233 000038DD 20202052696768740A 
  6234 000038E6 09616C745620506720-     db "	altV Pg up	^V  Pg down	altB Left word	altF Right word",10
  6234 000038EF 7570095E5620205067-
  6234 000038F8 20646F776E09616C74-
  6234 00003901 42204C65667420776F-
  6234 0000390A 726409616C74462052-
  6234 00003913 6967687420776F7264-
  6234 0000391C 0A                 
  6235 0000391D 095E41202020486F6D-     db "	^A   Home	^E  End		alt< BOF	alt> EOF",10
  6235 00003926 65095E452020456E64-
  6235 0000392F 0909616C743C20424F-
  6235 00003938 4609616C743E20454F-
  6235 00003941 460A               
  6236 00003943 09616C744720476F20-     db "	altG Go line#	^L  Center Pos",10
  6236 0000394C 6C696E6523095E4C20-
  6236 00003955 2043656E7465722050-
  6236 0000395E 6F730A             
  6237 00003961 0A                      db 10
  6238 00003962 5365617263683A095E-     db "Search:	^S Find fwd	^R Find bwd	alt% Search&Replace like WS",10
  6238 0000396B 532046696E64206677-
  6238 00003974 64095E522046696E64-
  6238 0000397D 2062776409616C7425-
  6238 00003986 205365617263682652-
  6238 0000398F 65706C616365206C69-
  6238 00003998 6B652057530A       
  6239 0000399E 0A                      db 10
  6240 0000399F 4275666665723A0961-     db "Buffer:	altW Copy	^Y Yank		^<SPC> Mark	^X^X Xchg Mark/Pt",10
  6240 000039A8 6C745720436F707909-
  6240 000039B1 5E592059616E6B0909-
  6240 000039BA 5E3C5350433E204D61-
  6240 000039C3 726B095E585E582058-
  6240 000039CC 636867204D61726B2F-
  6240 000039D5 50740A             
  6241 000039D8 0A                      db 10
  6242 000039D9 44656C6574653A095E-     db "Delete:	^K Line		^W Region	^H Left	Chr	^D This Chr",10
  6242 000039E2 4B204C696E6509095E-
  6242 000039EB 5720526567696F6E09-
  6242 000039F4 5E48204C6566740943-
  6242 000039FD 6872095E4420546869-
  6242 00003A06 73204368720A       
  6243 00003A0C 0A                      db 10
  6244                                  %ifdef UTF8
  6245                                  ; FIXME: ^T
  6246 00003A0D 4F746865723A095E4F-     db "Other:	^O Open line	           	^I Ins Tab	^Q Quoted Ins",10
  6246 00003A16 204F70656E206C696E-
  6246 00003A1F 650920202020202020-
  6246 00003A28 20202020095E492049-
  6246 00003A31 6E7320546162095E51-
  6246 00003A3A 2051756F7465642049-
  6246 00003A43 6E730A             
  6247                                  %else
  6248                                  db "Other:	^O Open line	^T Xchg Chr	^I Ins Tab	^Q Quoted Ins",10
  6249                                  %endif
  6250 00003A46 095E4D204E4C09095E-     db "	^M NL		^J NL+indent	altX Set edit mode",10
  6250 00003A4F 4A204E4C2B696E6465-
  6250 00003A58 6E7409616C74582053-
  6250 00003A61 65742065646974206D-
  6250 00003A6A 6F64650A           
  6251                                  %ifdef USE_MATH
  6252 00003A6E 095E585E4E2043616C-     db "	^X^N Calculate"
  6252 00003A77 63756C617465       
  6253                                  %else
  6254                                  db "		"
  6255                                  %endif
  6256                                  %ifdef SYS_kill
  6257 00003A7D 0909095E5A20537573-     db "			^Z Suspend"
  6257 00003A86 70656E64           
  6258                                  %endif
  6259                                  %ifdef USE_UNDO
  6260 00003A8A 095E5F2020556E646F      db "	^_  Undo"
  6261                                  %endif
  6262                                  %ifdef UTF8RTS
  6263                                  db 10,"	^U UTF-8"
  6264                                  %endif
  6265                                  help_em_size equ $-help_em
  6266                                  ;-------------------------
  6267                                  help_vi:
  6268 00003A93 4B65792062696E6469-     db "Key bindings in vi mode:",10
  6268 00003A9C 6E677320696E207669-
  6268 00003AA5 206D6F64653A0A     
  6269 00003AAC 0A                      db 10
  6270 00003AAD 3C4553433E09090965-     db "<ESC>			enter cmd mode",10
  6270 00003AB6 6E74657220636D6420-
  6270 00003ABF 6D6F64650A         
  6271 00003AC4 682C6A2C6B2C6C2C2B-     db "h,j,k,l,+,-,<Ret>,<SPC>	move by chars&lines",10
  6271 00003ACD 2C2D2C3C5265743E2C-
  6271 00003AD6 3C5350433E096D6F76-
  6271 00003ADF 652062792063686172-
  6271 00003AE8 73266C696E65730A   
  6272 00003AF0 5E422C5E462C5E442C-     db "^B,^F,^D,^U		move by [half]page",10
  6272 00003AF9 5E5509096D6F766520-
  6272 00003B02 6279205B68616C665D-
  6272 00003B0B 706167650A         
  6273 00003B10 242C302C5E2C772C62-     db "$,0,^,w,b,e,H,L,M,z.	move in line/screen",10
  6273 00003B19 2C652C482C4C2C4D2C-
  6273 00003B22 7A2E096D6F76652069-
  6273 00003B2B 6E206C696E652F7363-
  6273 00003B34 7265656E0A         
  6274 00003B39 2F2C3F2C4709090973-     db "/,?,G			srch fwd/bwd, go EOF",10
  6274 00003B42 726368206677642F62-
  6274 00003B4B 77642C20676F20454F-
  6274 00003B54 460A               
  6275 00003B56 6D612C276109090973-     db "ma,'a			set/go marker a",10
  6275 00003B5F 65742F676F206D6172-
  6275 00003B68 6B657220610A       
  6276 00003B6E 782C582C3C44656C3E-     db "x,X,<Del>,dw,D		dele chr,word,EOL",10
  6276 00003B77 2C64772C4409096465-
  6276 00003B80 6C65206368722C776F-
  6276 00003B89 72642C454F4C0A     
  6277 00003B90 532C432C64642C6427-     db "S,C,dd,d'a,yy,y'a	subst,change,dele,yank",10
  6277 00003B99 612C79792C79276109-
  6277 00003BA2 73756273742C636861-
  6277 00003BAB 6E67652C64656C652C-
  6277 00003BB4 79616E6B0A         
  6278 00003BB9 702C50090909706173-     db "p,P			paste",10
  6278 00003BC2 74650A             
  6279 00003BC5 412C612C492C692C3C-     db "A,a,I,i,<Ins>,O,o	enter ins.mode",10
  6279 00003BCE 496E733E2C4F2C6F09-
  6279 00003BD7 656E74657220696E73-
  6279 00003BE0 2E6D6F64650A       
  6280 00003BE6 522C72090909656E74-     db "R,r			enter ovw.mode,ovw.chr",10
  6280 00003BEF 6572206F76772E6D6F-
  6280 00003BF8 64652C6F76772E6368-
  6280 00003C01 720A               
  6281 00003C03 4A0909096A6F696E20-     db "J			join lines",10
  6281 00003C0C 6C696E65730A       
  6282                                  %ifdef USE_UNDO
  6283                                   %ifdef SYS_kill
  6284 00003C12 5A5A2C5E5A2C207509-       db "ZZ,^Z, u		save&quit,suspend, undo!",10
  6284 00003C1B 097361766526717569-
  6284 00003C24 742C73757370656E64-
  6284 00003C2D 2C20756E646F210A   
  6285                                   %else
  6286                                    db "ZZ, u		save&ex, undo!",10
  6287                                   %endif
  6288                                  %else
  6289                                   %ifdef SYS_kill
  6290                                    db "ZZ,^Z			save&quit,suspend",10
  6291                                   %else
  6292                                    db "ZZ			save&ex",10
  6293                                   %endif
  6294                                  %endif
  6295                                  %ifdef USE_MATH
  6296 00003C35 3B2C23090909453320-     db ";,#			E3 SPECIAL: set edit mode,calculate",10
  6296 00003C3E 5350454349414C3A20-
  6296 00003C47 736574206564697420-
  6296 00003C50 6D6F64652C63616C63-
  6296 00003C59 756C6174650A       
  6297                                  %else
  6298                                  db ";			E3 SPECIAL:set edit mode",10
  6299                                  %endif
  6300 00003C5F 3A772C3A77712C3A78-     db ":w,:wq,:x,:q,:q!,:e	ex mode:save,quit,save_as,edit other",10
  6300 00003C68 2C3A712C3A71212C3A-
  6300 00003C71 65096578206D6F6465-
  6300 00003C7A 3A736176652C717569-
  6300 00003C83 742C736176655F6173-
  6300 00003C8C 2C65646974206F7468-
  6300 00003C95 65720A             
  6301 00003C98 3A302C3A242C3A3C6C-     db ":0,:$,:<line#>		ex mode:go BOF,EOF,line",10
  6301 00003CA1 696E65233E09096578-
  6301 00003CAA 206D6F64653A676F20-
  6301 00003CB3 424F462C454F462C6C-
  6301 00003CBC 696E650A           
  6302                                  %ifdef UTF8RTS
  6303                                  db ":h,:u			ex mode:help, UTF-8",10
  6304                                  %else
  6305 00003CC0 3A680909096578206D-     db ":h			ex mode:help",10
  6305 00003CC9 6F64653A68656C700A 
  6306                                  %endif
  6307                                  %ifndef USE_PIPE
  6308                                  db "         "
  6309                                  %else
  6310                                  %ifdef USE_EX_NO_SED
  6311                                  db ":<other cmd>		pipe buffer thru 'ex' "
  6312                                  %else
  6313 00003CD2 3A3C6F746865722063-     db ":<other cmd>		pipe buffer thru 'sed'"
  6313 00003CDB 6D643E090970697065-
  6313 00003CE4 206275666665722074-
  6313 00003CED 687275202773656427 
  6314                                  %endif
  6315                                  %endif
  6316                                  help_vi_size equ $-help_vi
  6317                                  ;-------------------------
  6318                                  help_ne:
  6319 00003CF6 4B65792062696E6469-     db "Key bindings in NEDIT mode:",10
  6319 00003CFF 6E677320696E204E45-
  6319 00003D08 444954206D6F64653A-
  6319 00003D11 0A                 
  6320 00003D12 0A                      db 10
  6321 00003D13 46696C65733A09095E-     db "Files:		^QN Exit_NoSave	^QY Exit&Save	^QL Save&Load new",10
  6321 00003D1C 514E20457869745F4E-
  6321 00003D25 6F53617665095E5159-
  6321 00003D2E 204578697426536176-
  6321 00003D37 65095E514C20536176-
  6321 00003D40 65264C6F6164206E65-
  6321 00003D49 770A               
  6322 00003D4B 09095E532020536176-     db "		^S  Save	^W  WriteTo=SaveAs",10
  6322 00003D54 65095E572020577269-
  6322 00003D5D 7465546F3D53617665-
  6322 00003D66 41730A             
  6323 00003D69 4D6F76653A09095E4C-     db "Move:		^L  Line#",10
  6323 00003D72 20204C696E65230A   
  6324 00003D7A 09095E46202046696E-     db "		^F  Find	^R Search&Replace (like WS)",10
  6324 00003D83 64095E522053656172-
  6324 00003D8C 6368265265706C6163-
  6324 00003D95 6520286C696B652057-
  6324 00003D9E 53290A             
  6325 00003DA1 09095E472020476F20-     db "		^G  Go repeat last ^F,^R",10
  6325 00003DAA 726570656174206C61-
  6325 00003DB3 7374205E462C5E520A 
  6326 00003DBC 0A                      db 10
  6327 00003DBD 53656C6563743A0909-     db "Select:		^<SPACE> begin&extend by cursor keys (like Emacs)",10
  6327 00003DC6 5E3C53504143453E20-
  6327 00003DCF 626567696E26657874-
  6327 00003DD8 656E64206279206375-
  6327 00003DE1 72736F72206B657973-
  6327 00003DEA 20286C696B6520456D-
  6327 00003DF3 616373290A         
  6328 00003DF8 09095E412020416C6C-     db "		^A  All buffer",10
  6328 00003E01 206275666665720A   
  6329 00003E09 09095E582020437574-     db "		^X  Cut		^C Copy 	^V Paste",10
  6329 00003E12 09095E4320436F7079-
  6329 00003E1B 20095E562050617374-
  6329 00003E24 650A               
  6330 00003E26 0A                      db 10
  6331 00003E27 4F746865723A09095E-     db "Other:		^E  Set edit mode",10
  6331 00003E30 452020536574206564-
  6331 00003E39 6974206D6F64650A   
  6332                                  %ifdef UTF8RTS
  6333                                  db "		^Y  UTF8 view",10
  6334                                  %endif
  6335                                  %ifdef USE_MATH
  6336 00003E41 09095E4B202043616C-     db "		^K  Calculate",10
  6336 00003E4A 63756C6174650A     
  6337                                  %endif
  6338 00003E51 0909616C7448204865-     db "		altH Help"
  6338 00003E5A 6C70               
  6339                                  %ifdef SYS_kill
  6340 00003E5C 095E5A205375737065-     db "	^Z Suspend"
  6340 00003E65 6E64               
  6341                                  %endif
  6342                                  %ifdef USE_UNDO
  6343 00003E67 095E5520556E646F        db "	^U Undo"
  6344                                  %endif
  6345                                  help_ne_size equ $-help_ne
  6346                                  %ifndef YASM
  6347                                  %if help_ws_size != help_pi_size || help_ws_size!= help_em_size || help_ws_size!= help_pi_size || help_ws_size!= help_vi_size
  6348                                  %error Helptext
  6349                                  dw help_vi_size
  6350                                  dw help_ws_size
  6351                                  dw help_pi_size
  6352                                  dw help_em_size
  6353                                  %endif
  6354                                  %endif
  6355                                  %else					;no help texts built in
  6356                                  help_ws:
  6357                                  help_pi:
  6358                                  help_em:
  6359                                  help_vi:
  6360                                  help_ne:
  6361                                  db "This e3 is built w/o help texts."
  6362                                  help_ws_size equ $-help_ws
  6363                                  help_ne_size equ $-help_ws
  6364                                  %endif
  6365                                  ;
  6366                                  errmsgs:errortext 			;see e3.h
  6366                              <1> errmsgs:
  6366 00003E6F 4F70206E6F74207065- <1> db "Op not permitted",10
  6366 00003E78 726D69747465640A    <1>
  6366 00003E80 4E6F20737563682066- <1> db "No such file|directory",10
  6366 00003E89 696C657C6469726563- <1>
  6366 00003E92 746F72790A          <1>
  6366 00003E97 0A                  <1> db 10
  6366 00003E98 0A                  <1> db 10
  6366 00003E99 496E7075742F6F7574- <1> db "Input/output",10
  6366 00003EA2 7075740A            <1>
  6366 00003EA6 4E6F20737563682064- <1> db "No such device",10
  6366 00003EAF 65766963650A        <1>
  6366 00003EB5 0A                  <1> db 10
  6366 00003EB6 0A                  <1> db 10
  6366 00003EB7 4261642066696C6520- <1> db "Bad file descriptor",10
  6366 00003EC0 64657363726970746F- <1>
  6366 00003EC9 720A                <1>
  6366 00003ECB 4E6F206368696C6420- <1> db "No child processes",10
  6366 00003ED4 70726F636573736573- <1>
  6366 00003EDD 0A                  <1>
  6366 00003EDE 0A                  <1> db 10
  6366 00003EDF 4D656D6F7279206578- <1> db "Memory exhausted",10
  6366 00003EE8 686175737465640A    <1>
  6366 00003EF0 5065726D697373696F- <1> db "Permission denied",10
  6366 00003EF9 6E2064656E6965640A  <1>
  6366 00003F02 0A                  <1> db 10
  6366 00003F03 0A                  <1> db 10
  6366 00003F04 4465766963657C7265- <1> db "Device|resource busy",10
  6366 00003F0D 736F75726365206275- <1>
  6366 00003F16 73790A              <1>
  6366 00003F19 46696C652065786973- <1> db "File exists",10
  6366 00003F22 74730A              <1>
  6366 00003F25 0A                  <1> db 10
  6366 00003F26 4E6F20737563682064- <1> db "No such device",10
  6366 00003F2F 65766963650A        <1>
  6366 00003F35 0A                  <1> db 10
  6366 00003F36 497320612064697265- <1> db "Is a directory",10
  6366 00003F3F 63746F72790A        <1>
  6366 00003F45 496E76616C69642061- <1> db "Invalid argument",10
  6366 00003F4E 7267756D656E740A    <1>
  6366 00003F56 546F6F206D616E7920- <1> db "Too many open files",10
  6366 00003F5F 6F70656E2066696C65- <1>
  6366 00003F68 730A                <1>
  6366 00003F6A 546F6F206D616E7920- <1> db "Too many open files",10
  6366 00003F73 6F70656E2066696C65- <1>
  6366 00003F7C 730A                <1>
  6366 00003F7E 496E617070726F7072- <1> db "Inappropriate ioctl",10
  6366 00003F87 6961746520696F6374- <1>
  6366 00003F90 6C0A                <1>
  6366 00003F92 546578742066696C65- <1> db "Text file busy",10
  6366 00003F9B 20627573790A        <1>
  6366 00003FA1 46696C6520746F6F20- <1> db "File too large",10
  6366 00003FAA 6C617267650A        <1>
  6366 00003FB0 4E6F20737061636520- <1> db "No space on device",10
  6366 00003FB9 6F6E20646576696365- <1>
  6366 00003FC2 0A                  <1>
  6366 00003FC3 496C6C6567616C2073- <1> db "Illegal seek",10
  6366 00003FCC 65656B0A            <1>
  6366 00003FD0 522F4F2066696C6520- <1> db "R/O file system",10
  6366 00003FD9 73797374656D0A      <1>
  6366 00003FE0 43616E277420657865- <1> db "Can't exec "
  6366 00003FE9 6320                <1>
  6366                              <1> %ifdef USE_EX_NO_SED
  6366                              <1> db EX_PATH,10
  6366                              <1> %else
  6366 00003FEB 2F62696E2F7365640A  <1> db SEDPATH,10
  6366                              <1> %endif
  6366 00003FF4 42726F6B656E207069- <1> db "Broken pipe",10
  6366 00003FFD 70650A              <1>
  6367                                  
  6368                                  ;-------
  6369                                  ;
  6370                                  %ifdef CRIPLED_ELF
  6371                                   filesize      equ     $ - $$
  6372                                  %endif
  6373                                  ;-----------------------------------------------------------------------
  6374                                  %ifdef ATHEOS
  6375                                  section .data				;unused in Linux/FreeBSD/BeOS: save byte in ELF header
  6376                                  bits 32					;unused in W32: save byte in PE header
  6377                                  %endif
  6378                                  ;-----------------------------------------------------------------------
  6379                                  %ifdef NETBSD				;added Sun Oct  9 10:10:00 CEST 2005 
  6380                                  section .note.netbsd.ident
  6381                                  align 4
  6382                                   dd 7
  6383                                   dd 4
  6384                                   dd 1
  6385                                   db "NetBSD",0,0
  6386                                   dd 0 
  6387                                  %endif 
  6388                                  ;-----------------------------------------------------------------------
  6389                                  %ifdef OPENBSD
  6390                                  section .note.openbsd.ident
  6391                                  align 4
  6392                                   dd 8
  6393                                   dd 4
  6394                                   dd 1
  6395                                   db "OpenBSD",0
  6396                                   dd 0 
  6397                                  %endif 
  6398                                  ;-----------------------------------------------------------------------
  6399                                  section .bss
  6400                                  bits 32
  6401                                  align 4
  6402                                  %ifdef CRIPLED_ELF
  6403                                   bssstart:
  6404                                  %endif
  6405                                  screenbuffer_size equ 62*(160+32)	;estimated 62 lines 160 columns, 32 byte ESC seq (ca.12k)
  6406                                  screenbuffer_dwords equ screenbuffer_size/4
  6407 00000000 <res 00002E80>          screenbuffer resb screenbuffer_size
  6408                                  screenbuffer_end equ $			;If you really have higher screen resolution,
  6409                                  					;...no problem, except some useless redrawing happens.
  6410                                  %ifdef W32
  6411                                   attribbuffer	resw 62*160		;estimated 62 lines 160 columns
  6412                                   attribbuffer_end equ $
  6413                                  %else
  6414 00002E80 <res 00000024>           termios:	resb termios_struc_size
  6415 00002EA4 <res 00000024>           termios_orig:	resb termios_struc_size
  6416 00002EC8 <res 00000008>           winsize:	resb winsize_struc_size
  6417                                   setkplen	equ 10
  6418 00002ED0 <res 0000000A>           setkp		resb setkplen		;to store cursor ESC seq like  db 27,'[000;000H'
  6419 00002EDA <res 00000002>           		resb 2			;fill up
  6420 00002EDC <res 00000004>           revvoff	resd 1
  6421                                  %endif
  6422                                  %ifdef USE_UNDO
  6423 00002EE0 <res 00000004>           enter_undo	resd 1			;a status byte: 1 while in a undo process, else 0
  6424 00002EE4 <res 00000004>           last_undo_file resd 1			;a pointer to undo info stored external in a disk file
  6425 00002EE8 <res 00000004>           undoptr	resd 1			;points on top frame in undo ringbuffer stack
  6426                                   undobuffer_size equ 0x10000		;64 k
  6427 00002EEC <res 00010000>           undobuffer	resb undobuffer_size
  6428                                   undobuffer_end equ $
  6429                                  %endif
  6430 00012EEC <res 00000004>          lines		resd 1			;equ 24 or similar i.e. screen lines-1 (1 for statusline)
  6431 00012EF0 <res 00000004>          columns		resd 1			;equ 80 or similar dword (using only LSB)
  6432 00012EF4 <res 00000004>          columne		resd 1			;helper for display of current column
  6433 00012EF8 <res 00000004>          zloffst		resd 1			;helper: chars scrolled out at left border
  6434 00012EFC <res 00000004>          fileptr		resd 1			;helper for temp storage of current pos in file
  6435 00012F00 <res 00000004>          kurspos		resd 1			;cursor position set by DispNewScreen()
  6436 00012F04 <res 00000004>          kurspos2	resd 1			;cursor position set by other functions
  6437                                  
  6438 00012F08 <res 00000004>          tabcnt		resd 1			;internal helper byte in DispNewScreen() only
  6439 00012F0C <res 00000004>          changed		resd 1			;status byte: (UN)CHANGED
  6440 00012F10 <res 00000004>          oldQFpos	resd 1
  6441 00012F14 <res 00000004>          bereitsges	resd 1			;byte used for ^L
  6442                                  
  6443 00012F18 <res 00000004>          blockbegin	resd 1
  6444 00012F1C <res 00000004>          blockende	resd 1
  6445 00012F20 <res 00000004>          endeedit	resd 1			;byte controls program exit
  6446 00012F24 <res 00000004>          old		resd 1			;helper for ^QP
  6447 00012F28 <res 00000004>          veryold		resd 1			;ditto
  6448 00012F2C <res 00000004>          linenr		resd 1			;current line
  6449 00012F30 <res 00000004>          showblock	resd 1			;helper for ^KH
  6450 00012F34 <res 00000004>          suchlaenge	resd 1			;helper for ^QA,^QF
  6451 00012F38 <res 00000004>          repllaenge	resd 1
  6452 00012F3C <res 00000004>          vorwarts	resd 1
  6453 00012F40 <res 00000004>          grossklein	resd 1			;helper byte for ^QF,^QA
  6454                                  					; ^ ^ ^ ^ TODO check UTF-8 stuff here
  6455 00012F44 <res 00000004>          ch2linebeg	resd 1			;helper keeping cursor pos max at EOL (up/dn keys)
  6456 00012F48 <res 00000004>          numeriere	resd 1			;byte controls re-numeration
  6457 00012F4C <res 00000004>          read_b		resd 1			;buffer for getchar
  6458                                  %ifdef W32
  6459                                  		resd 4			;4 extra due size INPUT_RECORD in w32
  6460                                  %endif		
  6461 00012F50 <res 00000004>          isbold		resd 1			;control of bold display of ws-blocks
  6462 00012F54 <res 00000004>          inverse		resd 1
  6463 00012F58 <res 00000004>          insstat		resd 1
  6464                                  
  6465                                  %ifdef AMD64
  6466                                  ErrNr		resq 1
  6467                                  %else
  6468 00012F5C <res 00000004>          ErrNr		resd 1			;used similar libc errno, but not excactly equal
  6469                                  %endif
  6470                                  errlen		equ 100
  6471 00012F60 <res 00000064>          error		resb errlen		;reserved space for string: 'ERROR xxx:tttteeeexxxxtttt',0
  6472                                  
  6473 00012FC4 <res 00000004>          maxlen		resd 1
  6474                                  ;-------
  6475                                  ;
  6476                                  maxfilenamelen	equ 255
  6477 00012FC8 <res 00000100>          filepath	resb maxfilenamelen+1
  6478 000130C8 <res 00000100>          bakpath		resb maxfilenamelen+1
  6479 000131C8 <res 00000100>          blockpath	resb maxfilenamelen+1
  6480 000132C8 <res 00000100>          replacetext	resb maxfilenamelen+1
  6481 000133C8 <res 00000100>          suchtext	resb maxfilenamelen+1
  6482 000134C8 <res 00000100>          suchtext2	resb maxfilenamelen+1	;for PICO mode
  6483 000135C8 <res 0000007C>          optbuffer	resb optslen		;buffer for search/replace options and for ^QI
  6484                                  linkbuffersize	equ 4
  6485 00013644 <res 00000004>          linkbuffer	resb linkbuffersize
  6486 00013648 <res 000000A0>          sigaction	resd 40
  6487                                  ;------
  6488 000136E8 <res 00000004>          perms		resd 1
  6489                                  %ifdef SYS_fstat
  6490 000136EC <res 00000040>           fstatbuf:	resb stat_struc_size	
  6491                                  %endif
  6492                                  %ifdef SYS_utime
  6493 0001372C <res 00000008>           accesstime:	resb utimbuf_struc_size
  6494                                  %endif
  6495                                  ;-------
  6496 00013734 <res 00000138>          screenline	resb 256+4*scolorslen	;max possible columns + 4 color ESC seq per line
  6497                                  					;(buffer for displaying a text line)
  6498                                  %ifdef W32
  6499                                   attribline	resb 256*2		;attrib is a word
  6500                                  %endif
  6501 0001386C <res 00000004>          EmaKiSize	resd 1
  6502 00013870 <res 00000004>          EmaKiSrc	resd 1
  6503 00013874 <res 00000004>          EmaMark		resd 1
  6504                                  EmaCtrl:
  6505 00013878 <res 00000001>          EmaCtrlK	resb 1
  6506 00013879 <res 00000001>          EmaCtrlS	resb 1
  6507 0001387A <res 00000002>          		resb 2
  6508 0001387C <res 00000004>          EmaNumHelper	resd 1
  6509 00013880 <res 00000004>          VICmdMode	resd 1
  6510 00013884 <res 00000004>          VIbufch		resd 1
  6511 00013888 <res 00000004>          VInolinebased	resd 1
  6512 0001388C <res 00000004>          PicoSearch	resd 1			;where search started
  6513                                  %ifdef UTF8RTS
  6514                                  isUTF8		resd 1
  6515                                  %endif
  6516                                  %ifdef USE_PIPE
  6517 00013890 <res 00000004>           sedpipeB0	resd 1
  6518 00013894 <res 00000004>           sedpipeB1	resd 1
  6519 00013898 <res 00000004>           sedpipeC0	resd 1
  6520 0001389C <res 00000004>           sedpipeC1	resd 1
  6521                                  %endif
  6522                                  
  6523 000138A0 <res 00000004>          mode		resd 1
  6524                                  
  6525 000138A4 <res 00000004>          readfds		resd 1			;select data struc
  6526 000138A8 <res 00000004>          timevalsec	resd 1			;lowest
  6527 000138AC <res 00000004>          timevalusec	resd 1			;most significant
  6528                                                                                  
  6529                                  
  6530                                  buffercopysize	equ 1024
  6531 000138B0 <res 00000400>          buffercopy	resb buffercopysize
  6532                                  %ifdef USE_MATH
  6533 00013CB0 <res 00000004>           level		resd 1			;balance
  6534 00013CB4 <res 00000004>           ptlevel	resd 1			;parenthesis balance
  6535                                   %ifdef AMD64
  6536                                   stackptr	resq 1
  6537                                   %else
  6538 00013CB8 <res 00000004>           stackptr	resd 1			;escape recursion
  6539                                   %endif
  6540 00013CBC <res 0000000C>           x87		resd 3			;12 byte (need 10 byte for 80 bit BCD)
  6541 00013CC8 <res 00000020>           lastresult87	resq 4			;8 byte
  6542 00013CE8 <res 00000004>           signctl	resd 1
  6543                                  %endif
  6544                                  %ifdef W32
  6545                                   heap		resd 1
  6546                                   hin		resd 1
  6547                                   hout		resd 1
  6548                                   w32result	resd 1			;for the w32 API calls
  6549                                   csbi		resd 6			;screen_buffer_info
  6550                                  %endif
  6551                                  
  6552                                  %ifdef SYS_brk
  6553                                   max		equ 1024000		;valid for NEW created files only
  6554                                  %else
  6555                                   max		equ 10240000
  6556                                  %endif
  6557                                  ;-------
  6558 00013CEC <res 000FA000>          text		resb max
  6559                                  sot 		equ (text+1)		;start-of-text
  6560                                  
  6561                                  %ifdef CRIPLED_ELF
  6562                                   bsssize equ $-bssstart
  6563                                  %endif
